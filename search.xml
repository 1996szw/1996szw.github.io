<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【毕设】数据挖掘算法之Apriori关联规则挖掘]]></title>
    <url>%2F2018%2F03%2F24%2F%E3%80%90%E6%AF%95%E8%AE%BE%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95%E4%B9%8BApriori%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[Apriori关联规则算法学习 关联分析关联分析是一种在大规模数据集中寻找有趣关系的任务。这些关系可以有两种形式: 频繁项集（frequent item sets）: 经常出现在一块的物品的集合。 关联规则（associational rules）: 暗示两种物品之间可能存在很强的关系。 相关术语 关联分析（关联规则学习): 从大规模数据集中寻找物品间的隐含关系被称作 关联分析(associati analysis) 或者 关联规则学习（association rule learning） 。 下面是用一个 杂货店 例子来说明这两个概念，如下图所示: 频繁项集: {葡萄酒, 尿布, 豆奶} 就是一个频繁项集的例子。 关联规则: 尿布 -&gt; 葡萄酒 就是一个关联规则。这意味着如果顾客买了尿布，那么他很可能会买葡萄酒。 那么 频繁 的定义是什么呢？怎么样才算频繁呢？度量它们的方法有很多种，这里我们来简单的介绍下支持度和置信度。 支持度: 数据集中包含该项集的记录所占的比例。例如上图中，{豆奶} 的支持度为 4/5。{豆奶, 尿布} 的支持度为 3/5。 置信度: 针对一条诸如 {尿布} -&gt; {葡萄酒} 这样具体的关联规则来定义的。这条规则的 置信度 被定义为 支持度({尿布, 葡萄酒})/支持度({尿布})，从图中可以看出 支持度({尿布, 葡萄酒}) = 3/5，支持度({尿布}) = 4/5，所以 {尿布} -&gt; {葡萄酒} 的置信度 = 3/5 / 4/5 = 3/4 = 0.75。 支持度 和 置信度 是用来量化 关联分析 是否成功的一个方法。假设想找到支持度大于 0.8 的所有项集，应该如何去做呢？一个办法是生成一个物品所有可能组合的清单，然后对每一种组合统计它出现的频繁程度，但是当物品成千上万时，上述做法就非常非常慢了。我们需要详细分析下这种情况并讨论下 Apriori 原理，该原理会减少关联规则学习时所需的计算量。 Apriori 原理假设我们一共有 4 个商品: 商品0, 商品1, 商品2, 商品3。所有可能的情况如下:如果我们计算所有组合的支持度，也需要计算 15 次。即 2^N - 1 = 2^4 - 1 = 15。随着物品的增加，计算的次数呈指数的形式增长 … 为了降低计算次数和时间，研究人员发现了一种所谓的 Apriori 原理，即某个项集是频繁的，那么它的所有子集也是频繁的。例如，如果 {0, 1} 是频繁的，那么 {0}, {1} 也是频繁的。 该原理直观上没有什么帮助，但是如果反过来看就有用了，也就是说如果一个项集是 非频繁项集，那么它的所有超集也是非频繁项集，如下图所示: 在图中我们可以看到，已知灰色部分 {2,3} 是 非频繁项集，那么利用上面的知识，我们就可以知道 {0,2,3} {1,2,3} {0,1,2,3} 都是 非频繁的。也就是说，计算出 {2,3} 的支持度，知道它是 非频繁 的之后，就不需要再计算 {0,2,3} {1,2,3} {0,1,2,3} 的支持度，因为我们知道这些集合不会满足我们的要求。使用该原理就可以避免项集数目的指数增长，从而在合理的时间内计算出频繁项集。 Apriori 算法优缺点 123* 优点：易编码实现* 缺点：在大数据集上可能较慢* 适用数据类型：数值型 或者标准型数据。 Apriori 算法流程步骤： 123456* 收集数据：使用任意方法。* 准备数据：任何数据类型都可以，因为我们只保存集合。* 分析数据：使用任意方法。* 训练数据：使用Apiori算法来找到频繁项集。* 测试算法：不需要测试过程。* 使用算法：用于发现频繁项集以及物品之间的关联规则。 Apriori 算法的使用前面提到，关联分析的目标包括两项: 发现 频繁项集 和发现 关联规则。首先需要找到 频繁项集，然后才能发现 关联规则。Apriori 算法是发现 频繁项集 的一种方法。Apriori 算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个物品的项集列表。接着扫描交易记录来查看哪些项集满足最小支持度要求，那些不满足最小支持度要求的集合会被去掉。然后对生下来的集合进行组合以生成包含两个元素的项集。接下来再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集被去掉。 生成候选项集下面会创建一个用于构建初始集合的函数，也会创建一个通过扫描数据集以寻找交易记录子集的函数，数据扫描的伪代码如下: 对数据集中的每条交易记录 tran 对每个候选项集 can 检查一下 can 是否是 tran 的子集: 如果是则增加 can 的计数值 对每个候选项集 can 如果其支持度不低于最小值，则保留该项集 返回所有频繁项集列表 以下是一些辅助函数。 加载数据集123# 加载数据集def loadDataSet(): return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]] 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset1234567891011121314151617181920212223# 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozensetdef createC1(dataSet): """createC1（创建集合 C1） Args: dataSet 原始数据集 Returns: frozenset 返回一个 frozenset 格式的 list """ C1 = [] for transaction in dataSet: for item in transaction: if not [item] in C1: # 遍历所有的元素，如果不在 C1 出现过，那么就 append C1.append([item]) # 对数组进行 `从小到大` 的排序 print 'sort 前=', C1 C1.sort() # frozenset 表示冻结的 set 集合，元素无改变；可以把它当字典的 key 来使用 print 'sort 后=', C1 print 'frozenset=', map(frozenset, C1) return map(frozenset, C1) 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据1234567891011121314151617181920212223242526272829303132333435# 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据def scanD(D, Ck, minSupport): """scanD（计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度 minSupport 的数据） Args: D 数据集 Ck 候选项集列表 minSupport 最小支持度 Returns: retList 支持度大于 minSupport 的集合 supportData 候选项集支持度数据 """ # ssCnt 临时存放选数据集 Ck 的频率. 例如: a-&gt;10, b-&gt;5, c-&gt;8 ssCnt = &#123;&#125; for tid in D: for can in Ck: # s.issubset(t) 测试是否 s 中的每一个元素都在 t 中 if can.issubset(tid): if not ssCnt.has_key(can): ssCnt[can] = 1 else: ssCnt[can] += 1 numItems = float(len(D)) # 数据集 D 的数量 retList = [] supportData = &#123;&#125; for key in ssCnt: # 支持度 = 候选项（key）出现的次数 / 所有数据集的数量 support = ssCnt[key]/numItems if support &gt;= minSupport: # 在 retList 的首位插入元素，只存储支持度满足频繁项集的值 retList.insert(0, key) # 存储所有的候选项（key）和对应的支持度（support） supportData[key] = support return retList, supportData 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 组织完整的 Apriori 算法输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ck12345678910111213141516171819202122232425262728293031# 输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ckdef aprioriGen(Lk, k): """aprioriGen（输入频繁项集列表 Lk 与返回的元素个数 k，然后输出候选项集 Ck。 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; 仅需要计算一次，不需要将所有的结果计算出来，然后进行去重操作 这是一个更高效的算法） Args: Lk 频繁项集列表 k 返回的项集元素个数（若元素的前 k-2 相同，就进行合并） Returns: retList 元素两两合并的数据集 """ retList = [] lenLk = len(Lk) for i in range(lenLk): for j in range(i+1, lenLk): L1 = list(Lk[i])[: k-2] L2 = list(Lk[j])[: k-2] # print '-----i=', i, k-2, Lk, Lk[i], list(Lk[i])[: k-2] # print '-----j=', j, k-2, Lk, Lk[j], list(Lk[j])[: k-2] L1.sort() L2.sort() # 第一次 L1,L2 为空，元素直接进行合并，返回元素两两合并的数据集 # if first k-2 elements are equal if L1 == L2: # set union # print 'union=', Lk[i] | Lk[j], Lk[i], Lk[j] retList.append(Lk[i] | Lk[j]) return retList 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。1234567891011121314151617181920212223242526272829303132333435363738394041# 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。def apriori(dataSet, minSupport=0.5): """apriori（首先构建集合 C1，然后扫描数据集来判断这些只有一个元素的项集是否满足最小支持度的要求。那么满足最小支持度要求的项集构成集合 L1。然后 L1 中的元素相互组合成 C2，C2 再进一步过滤变成 L2，然后以此类推，知道 CN 的长度为 0 时结束，即可找出所有频繁项集的支持度。） Args: dataSet 原始数据集 minSupport 支持度的阈值 Returns: L 频繁项集的全集 supportData 所有元素和支持度的全集 """ # C1 即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset C1 = createC1(dataSet) # 对每一行进行 set 转换，然后存放到集合中 D = map(set, dataSet) print 'D=', D # 计算候选数据集 C1 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 L1, supportData = scanD(D, C1, minSupport) # print "L1=", L1, "\n", "outcome: ", supportData # L 加了一层 list, L 一共 2 层 list L = [L1] k = 2 # 判断 L 的第 k-2 项的数据长度是否 &gt; 0。第一次执行时 L 为 [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]]。L[k-2]=L[0]=[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]，最后面 k += 1 while (len(L[k-2]) &gt; 0): print 'k=', k, L, L[k-2] Ck = aprioriGen(L[k-2], k) # 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; print 'Ck', Ck Lk, supK = scanD(D, Ck, minSupport) # 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 # 保存所有候选项集的支持度，如果字典没有，就追加元素，如果有，就更新元素 supportData.update(supK) if len(Lk) == 0: break # Lk 表示满足频繁子项的集合，L 元素在增加，例如: # l=[[set(1), set(2), set(3)]] # l=[[set(1), set(2), set(3)], [set(1, 2), set(2, 3)]] L.append(Lk) k += 1 # print 'k=', k, len(L[k-2]) return L, supportData 到这一步，我们就找出我们所需要的 频繁项集 和他们的 支持度 了，接下来再找出关联规则即可！ 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 从频繁项集中挖掘关联规则前面我们介绍了用于发现 频繁项集 的 Apriori 算法，现在要解决的问题是如何找出 关联规则。 要找到 关联规则，我们首先从一个 频繁项集 开始。我们知道集合中的元素是不重复的，但我们想知道基于这些元素能否获得其它内容。某个元素或某个元素集合可能会推导出另一个元素。从先前 杂货店 的例子可以得到，如果有一个频繁项集 {豆奶,莴苣}，那么就可能有一条关联规则 “豆奶 -&gt; 莴苣”。这意味着如果有人买了豆奶，那么在统计上他会购买莴苣的概率比较大。但是，这一条件反过来并不总是成立。也就是说 “豆奶 -&gt; 莴苣” 统计上显著，那么 “莴苣 -&gt; 豆奶” 也不一定成立。 前面我们给出了 频繁项集 的量化定义，即它满足最小支持度要求。对于 关联规则，我们也有类似的量化方法，这种量化指标称之为 置信度。一条规则 A -&gt; B 的置信度定义为 support(A | B) / support(A)。（注意: 在 python 中 | 表示集合的并操作，而数学书集合并的符号是 U）。A | B 是指所有出现在集合 A 或者集合 B 中的元素。由于我们先前已经计算出所有 频繁项集 的支持度了，现在我们要做的只不过是提取这些数据做一次除法运算即可。 一个频繁项集可以产生多少条关联规则呢？如下图所示，给出的是项集 {0,1,2,3} 产生的所有关联规则:与我们前面的 频繁项集 生成一样，我们可以为每个频繁项集产生许多关联规则。如果能减少规则的数目来确保问题的可解析，那么计算起来就会好很多。通过观察，我们可以知道，如果某条规则并不满足 最小置信度 要求，那么该规则的所有子集也不会满足 最小置信度 的要求。如上图所示，假设 123 -&gt; 3 并不满足最小置信度要求，那么就知道任何左部为 {0,1,2} 子集的规则也不会满足 最小置信度 的要求。即 12 -&gt; 03 , 02 -&gt; 13 , 01 -&gt; 23 , 2 -&gt; 013, 1 -&gt; 023, 0 -&gt; 123 都不满足 最小置信度 要求。 可以利用关联规则的上述性质属性来减少需要测试的规则数目，跟先前 Apriori 算法的套路一样。以下是一些辅助函数: 计算置信度123456789101112131415161718192021222324252627# 计算置信度（confidence）def calcConf(freqSet, H, supportData, brl, minConf=0.7): """calcConf（对两个元素的频繁项，计算置信度，例如： &#123;1,2&#125;/&#123;1&#125; 或者 &#123;1,2&#125;/&#123;2&#125; 看是否满足条件） Args: freqSet 频繁项集中的元素，例如: frozenset([1, 3]) H 频繁项集中的元素的集合，例如: [frozenset([1]), frozenset([3])] supportData 所有元素的支持度的字典 brl 关联规则列表的空数组 minConf 最小置信度 Returns: prunedH 记录 置信度大于阈值的集合 """ # 记录置信度大于最小置信度（minConf）的集合 prunedH = [] for conseq in H: # 假设 freqSet = frozenset([1, 3]), H = [frozenset([1]), frozenset([3])]，那么现在需要求出 frozenset([1]) -&gt; frozenset([3]) 的置信度和 frozenset([3]) -&gt; frozenset([1]) 的置信度 # print 'confData=', freqSet, H, conseq, freqSet-conseq conf = supportData[freqSet]/supportData[freqSet-conseq] # 支持度定义: a -&gt; b = support(a | b) / support(a). 假设 freqSet = frozenset([1, 3]), conseq = [frozenset([1])]，那么 frozenset([1]) 至 frozenset([3]) 的置信度为 = support(a | b) / support(a) = supportData[freqSet]/supportData[freqSet-conseq] = supportData[frozenset([1, 3])] / supportData[frozenset([1])] if conf &gt;= minConf: # 只要买了 freqSet-conseq 集合，一定会买 conseq 集合（freqSet-conseq 集合和 conseq 集合是全集） print freqSet-conseq, '--&gt;', conseq, 'conf:', conf brl.append((freqSet-conseq, conseq, conf)) prunedH.append(conseq) return prunedH` 递归计算频繁项集的规则1234567891011121314151617181920212223242526272829303132# 递归计算频繁项集的规则def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7): """rulesFromConseq Args: freqSet 频繁项集中的元素，例如: frozenset([2, 3, 5]) H 频繁项集中的元素的集合，例如: [frozenset([2]), frozenset([3]), frozenset([5])] supportData 所有元素的支持度的字典 brl 关联规则列表的数组 minConf 最小置信度 """ # H[0] 是 freqSet 的元素组合的第一个元素，并且 H 中所有元素的长度都一样，长度由 aprioriGen(H, m+1) 这里的 m + 1 来控制 # 该函数递归时，H[0] 的长度从 1 开始增长 1 2 3 ... # 假设 freqSet = frozenset([2, 3, 5]), H = [frozenset([2]), frozenset([3]), frozenset([5])] # 那么 m = len(H[0]) 的递归的值依次为 1 2 # 在 m = 2 时, 跳出该递归。假设再递归一次，那么 H[0] = frozenset([2, 3, 5])，freqSet = frozenset([2, 3, 5]) ，没必要再计算 freqSet 与 H[0] 的关联规则了。 m = len(H[0]) if (len(freqSet) &gt; (m + 1)): print 'freqSet******************', len(freqSet), m + 1, freqSet, H, H[0] # 生成 m+1 个长度的所有可能的 H 中的组合，假设 H = [frozenset([2]), frozenset([3]), frozenset([5])] # 第一次递归调用时生成 [frozenset([2, 3]), frozenset([2, 5]), frozenset([3, 5])] # 第二次 。。。没有第二次，递归条件判断时已经退出了 Hmp1 = aprioriGen(H, m+1) # 返回置信度大于最小置信度的集合 Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf) print 'Hmp1=', Hmp1 print 'len(Hmp1)=', len(Hmp1), 'len(freqSet)=', len(freqSet) # 计算置信度后，还有数据大于最小置信度的话，那么继续递归调用，否则跳出递归 if (len(Hmp1) &gt; 1): print '----------------------', Hmp1 # print len(freqSet), len(Hmp1[0]) + 1 rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf) 生成关联规则12345678910111213141516171819202122232425# 生成关联规则def generateRules(L, supportData, minConf=0.7): """generateRules Args: L 频繁项集列表 supportData 频繁项集支持度的字典 minConf 最小置信度 Returns: bigRuleList 置信度规则列表（关于 (A-&gt;B+置信度) 3个字段的组合） """ bigRuleList = [] # 假设 L = [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])], [frozenset([1, 3]), frozenset([2, 5]), frozenset([2, 3]), frozenset([3, 5])], [frozenset([2, 3, 5])]] for i in range(1, len(L)): # 获取频繁项集中每个组合的所有元素 for freqSet in L[i]: # 假设：freqSet= frozenset([1, 3]), H1=[frozenset([1]), frozenset([3])] # 组合总的元素并遍历子元素，并转化为 frozenset 集合，再存放到 list 列表中 H1 = [frozenset([item]) for item in freqSet] # 2 个的组合，走 else, 2 个以上的组合，走 if if (i &gt; 1): rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) else: calcConf(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList 到这里为止，通过调用 generateRules 函数即可得出我们所需的 关联规则。 分级法： 频繁项集-&gt;关联规则 1.首先从一个频繁项集开始，接着创建一个规则列表，其中规则右部分只包含一个元素，然后对这个规则进行测试。 2.接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。 如下图： 最后： 每次增加频繁项集的大小，Apriori 算法都会重新扫描整个数据集，是否有优化空间呢？ 信息来源于 ApacheCN GitHub地址: https://github.com/apachecn/MachineLearning]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
        <tag>关联规则算法</tag>
        <tag>apriori</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Vue+Webpack打造todoApp应用]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%9F%BA%E4%BA%8EVue%2BWebpack%E6%89%93%E9%80%A0todoApp%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 此源码基于vue和webpack编写。前置知识有JavaScript、Css、Html、ES6、Stylus、Vue、Webpack、Webpack-cli、Bable等。 源码地址此Demo源码托管在本人Github，点击此链接直达。 使用步骤安装依赖 需要安装npm包管理工具 需要安装的npm依赖包详见pakage.json 开发环境 启动项目：npm run dev 浏览器调试：localhost:8000 生产环境 项目打包：npm run build 过程记录笔记前端的价值 搭建前端工程 网络优化（HTTP的理解） API定制 Node.js层 初始化一个项目 npm init 需要安装的依赖 npm install webpack -g(全局安装webpack)npm install webpack –save-dev(局部安装webpack，并且默认是安装最新版本)npm install css-loadernpm install vue-template-compilernpm install vuenpm install vue-loader vue中的render函数 render方法的实质就是生成template模板，通过调用一个方法来生成，而这个方法是通过render方法的参数传递给他的。 Vue中\$mount() Vue 的\$mount()为手动挂载，在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等），之后要手动挂载上,new Vue时，el和$mount并没有本质上的区别。 “webpack –config webpack.config.js”配置的含义 “build”: “webpack –config webpack.config.js”以上配置的意义是强制终端在执行npm run build的时候调用的是本地安装的webpak，而不是全局的webpack，并且在执行npm run build命令的时候，会执行webpack.config.js文件 css-loader、style-loader说明 loader: ‘css-loader’，这个只是帮我们处理CSS文件。以下写法能帮我们把CSS样式插到HTML结构中: 1234use: [ 'style-loader', 'css-loader'] (在此之前需要安装依赖：npm install style-loader) webpack处理图片文件代码解析 代码： 123456789&#123; test: /\\.(gif|jpg|jpeg|svg)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 1024 , name: '[name]-aa.[ext]' &#125;&#125; 该代码的作用就是使用url-loader来处理后缀名为.gif、.jpg、.jpeg、.svg的文件，将其转化为base64代码，直接写在js文件里面，而不用生成一个新的文件。 使用对象的写法是为了配置url-loader的一些选项。limit:1024的含义就是当图片小于1024kb的时候，转化为base64代码，减少了HTTP请求。name配置的含义是定义输出文件的名字】(配置里面的name是原来图片的名字，ext是转化后的后缀名)可以使用下面两段代码来进行测试 12345678910111213141516body &#123; color: blue; background-image: url(../images/bg.jpg);&#125;//vue组件不能直接挂载到HTML文件中的解决方案import Vue from 'vue'import App from './app.vue'import './assets/styles/test.css'import './assets/images/bg.jpg'const root = document.createElement('div')document.body.appendChild(root)new Vue(&#123; // 将app.vue组件挂载到HTML文件中 render: (h) =&gt; h(App)&#125;).$mount(root) 使用命令：npm run build，将可以在dist目录下看到一张转化后的图片(bg-aa.jpg) webpack强大的地方之一就是能够处理任何的依赖文件，比如在CSS文件中定义的图片，webpack也会使用配置好的url-loader将其进行处理。 CSS预处理器(使用stylus)安装： npm install stylus stylus-loader 配置：1234&#123; test: /\.styl/, use: ['style-loader', 'css-loader', 'stylus-loader']&#125;, 使用npm安装依赖包的细节 1、npm install webapck –save-dev：表示安装的webpack只在开发环境(dev)中使用，项目发布之后就不会用到，简写方式为npm i webapck -D。2、npm install vue –save：表示安装的vue在开发环境和正式环境中都会被用到，简写方式为npm i vue -S webpack-dev-server的配置和使用 安装：npm i webpack-dev-server配置：”dev”: “webpack-dev-server –config webpack.config.js” 通过以上的配置，那么使用命令npm run dev也能够实现打包项目，并且它是开发模式打包项目 如何分辨是在开发环境还是正式环境 步骤一： npm i cross-env步骤二：为了能够在不同的平台都运行webpack.config.js文件，我们需要在package.json中这样来配置：“build”: “cross-env NODE_ENV=production webpack –config webpack.config.js”,“dev”: “cross-env NODE_ENV=development webpack-dev-server –config webpack.config.js”步骤三：配置webpack.config.js文件 如何让打包好的js文件自动包含到HTML文件中 步骤一：npm install html-webpack-plugin]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>npm</tag>
        <tag>stylus</tag>
        <tag>todo</tag>
        <tag>bable</tag>
        <tag>es6</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目中的数据可视化]]></title>
    <url>%2F2017%2F11%2F21%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[近几年随着大数据逐渐火热，数据可视化也就显得格外重要。。 最近几年随着大数据的兴起，以及浏览器性能的提升，数据可视化成为了一个热点，前端也冒出来了很多数据可视化的岗位。本人也做过一些数据可视化相关的产品，下面聊聊对数据可视化的一些思考。本文的数据可视化一般专指互联网公司web前端接触的数据可视化。 数据可视化，是关于数据视觉表现形式的科学技术研究。其中，这种数据的视觉表现形式被定义为，一种以某种概要形式抽提出来的信息，包括相应信息单位的各种属性和变量。它是一个处于不断演变之中的概念，其边界在不断地扩大。主要指的是技术上较为高级的技术方法，而这些技术方法允许利用图形、图像处理、计算机视觉以及用户界面，通过表达、建模以及对立体、表面、属性以及动画的显示，对数据加以可视化解释。与立体建模之类的特殊技术方法相比，数据可视化所涵盖的技术方法要广泛得多. ———————-百度百科 而前端常说的视觉可视化大部分是指借助曲线图表等展示形式把一些相关数据更直接、形象、生动、具体的展示在web页面上。要做一个好的数据产品是需要 产品经理-&gt;设计师-&gt;前端-&gt;后端-&gt;用户整个链路紧密配合密切合作并且协调的。 产品需要懂数据可视化的理论基础，哪些数据可以可视化，哪些数据是用户最想要的。 设计师包括视觉和交互，需要理清楚数据怎么展示最合理，曲线，柱状图，饼状图，都有哪些优缺点，不能仅仅为了美观设计了一个好看的图形，而不顾实际数据情况，展示出来就很奇怪。 前端其实在里面是最紧密的一环，数据怎么获取，什么格式对前后端最友好，采用什么技术方案，是svg的库，还是canvas的库，是自己撸还是用现成的库。实现成本有多高，性能、扩展性怎么样都是需要考虑的问题 后端需要考虑的就是数据的拉取，需要考虑数据格式以及能获取哪些数据。 以上分工只是一个粗略的说明。这里看了一篇文章小心，这饼有毒！论饼图的正确打开方式里面讲的一些经历可能大家都遇到过，我也深有同感。 我的这些数据，好像柱状图、折线图、饼图都能表示啊，到底应该选哪个？ 饼图和环形图也差不多，取决于我要不要在中间显示其他内容吗？ 我可不可以将数据映射到饼图的半径维度上 数据可视化最重要的不是好看，而是让人一目了然的明白这个图表传达出来的意思。 其实这方面是有相关的信息图表学的相关知识储备的话就不会犯这些错误了。支付宝有个G2 里面有两个相关的图表学基础知识介绍，我个人认为这是G2 比echart更近一步，更规范化的点之一。 详见这里 可视化基础-图表使用建议 https://antv.alipay.com/vis/doc/chart/classify/compare.html 可视化基础-图表设计指引规范 https://antv.alipay.com/vis/doc/design/index.html 以及经典文献： 在数据可视化的研究和实现中，《数据可视化》、《The Grammarof Graphics》、《深入浅出统计学》、《计算机图形学几何工具算法详解》、《Visualization Analysis and Design》 、《ggplot2：数据分析与图形艺术》 。 叨叨了这么多基础，下面说说前端在可视化里的一些相关的发展和技术选型 首先需要明白一个观点：技术选型没有一劳永逸的，永远是根据你的项目实际情况以及你的个人偏好和技术基础来做的选择。 下面说说常见的一些图表库和相关技术： 1. echartsecharts算是国产的图表库里最好的了。EFE团队也是国内技术实力最雄厚的可视化团队.采用canvas作为渲染容器。底层一些实现比如鼠标事件啥的用的自己开发的zrender框架。 echart2.0对应不同的组件比如坐标轴图例是用不同的canvas来渲染的，echart3之后都合并到一个canvas里面了，猜测应该是底层的框架升级了 博客： http://efe.baidu.com/， 这个博客更的很慢了。 http://echarts.baidu.com/blog/posts/ 这个更得多点。 2.highcharts这个框架用的人也不少，主打就是IE6也支持。。。。。。。。。然并卵微软都不支持IE6了。淘宝连ie8都不支持了。。。。收费的库，底层用的SVG。私以为他的API使用起来没有Echart友好。 3.G2-支付宝蚂蚁金服的产品，图标容器为canvas，玉伯的团队开发的。怎么说呢。。这个东西看着还不错，不过实际使用的时候大部分人还是会不由自主的去选择前面两个，大阿里的开源东西就是这么个鬼情况。东西是不错，就怕搞着搞着团队没了。。 4.d3.jsd3也算是资历比较老的一个产品了，采用svg作为图标容器。刚开始出来的时候各种动画比较惊艳，图标类型也比较丰富，感觉echarts一开始也参照它的图表类型新增了好几个图表示例。 d3的优点是各种示例demo比较完善适合拿来就用，缺点就是demo不适合二次开发，熟悉api的话也可以直接自己画，他的api是对svg的dom的一种整理和兼容，类比于jquery对应html的dom。 其他： 一两年前阿里妈妈貌似出过一个图表库，我当初还给他们留言说：为啥不先出一个移动端的图表库说不定更有市场。貌似最后沦为KPI的牺牲品 以上就是最常见的一些图表库，那么我们需要根据实际项目需要来做一些技术选型。 移动端图表库，echarts和G2应该都可以。pc端就看个人喜好了。报表类型的项目看设计师画的效果稿吧，echarts可定制性最高，G2没用过，highcharts文档不健全。 监控类型的项目需要频繁更新数据的优选选择canvas的性能应该更好。 下面说说数据可视化的一般应用场景： 报表类 报表类使用场景最多，使用的图表也最简单一般echarts里面的示例图表就能满足了。 监控类 监控类稍微复杂点，一般涉及到实时性和稳健性，开发的时候需要考虑后端的接口性能，以及页面图表渲染的性能问题，数据量大了之后对前后端都很有挑战性。做起来也比较有意思，和业务场景结合起来能做一整套的数据可视化的产品系统。 动效PR稿类 这种类型的项目一般都有一个特点：急，炫，累。项目周期很急，动画效果要很炫，干起活来很累。偶尔做做还行，一直搞，就感觉路走的有点偏，而且一般很少能找到现成的库和框架，前期需要大量的技术调研和技术储备。相关的库一般需要canvas的效果库，webGL的库，比如:http://www.pixijs.com/ ，threejs，要求更高的可能需要一些游戏库来帮忙了比如：https://www.egret.com/ ，http://www.createjs.com/等等。 地图类 这类的数据可视化单独拿出来是因为现在越来越多的数据可视化场景里需要用到地图。这也是数据可视化最麻烦的一直，一般我们借助echart的地图，或者百度地图，高德地图等来开发，其实百度地图也出了个地图可视化的库 http://mapv.baidu.com/ ，展示效果没有echart好。。。。需要定制开发的同学其实可以直接拿百度地图之类的然后在地图上蒙一层覆盖类，然后在这个覆盖类里填充一个canvas做一些自己的扩展参见百度地图的demo；背后的地图。。可以用css隐藏掉。。。。。 数据可视化系统 这个范畴比较大，还是需要看业务场景，某些业务场景就特别适合做一堆相关联的数据可视化系统。做好了成就感还是满满的。 ================================================ 参考于：https://www.56way.com/p/102.html]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>前端</tag>
        <tag>数据可视化</tag>
        <tag>数据</tag>
        <tag>echarts</tag>
        <tag>highcharts</tag>
        <tag>G2</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的基础知识]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vue的三个特点： 易用 123&lt;div id='app'&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el:'#app', data:&#123; message:'hello vue!' &#125;&#125;) 灵活（渐进式） 无论是单页面程序还是多页面程序，我们首先都需要通过声明式渲染来渲染页面上的每一个字段；因为我们的界面需要去展现一些功能，展现一些信息，就需要渲染来实现； 把一些公共的头部和公共的尾部抽出来去做成一个组件； 做单页面程序用到路由,需要把vue-resource、vue-router等等插件拉进来去做一个路由的功能； 如果实现的业务足够复杂，需要用到大量的组件，而且难以管理这些组件的状态，此时就需要引进vuex，用来集中管理组件的状态； 整个项目做完之后，需要通过构建工具来build系统，提升效率，最后形成一个完整的项目。 高效 vue的min+gzip的运行大小：16kb； 超快虚拟DOM； 最省心的优化。 Vue组件的重要选项： data（数据源） methods（方法） watch（监听） Vue模版指令（html和vue对象的粘合剂）： 数据渲染：v-text 、v-html 、&#123;&#123; &#125;&#125; 控制模块隐藏：v-if 、v-show 渲染循环列表：v-for 事件绑定：v-bind 表单渲染：v-model: 用于文本框、下拉框、单选复选、textarea等等，具有一个双向绑定的特性。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几道Codewars上面的编程题]]></title>
    <url>%2F2017%2F07%2F24%2F%E8%AE%B0%E5%87%A0%E9%81%93Codewars%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每次做完看到别人的答案：wtf ??? NO.1题目描述： 解法:12345678function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); Math.min()方法: 可以得到数组中最小的数,Math.min.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 splice()方法: arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 NO.2题目描述： 我的解法：123456function isTriangle(a,b,c)&#123; var p = (a + b + c)/2; var S = Math.sqrt(p*(p-a)*(p-b)*(p-c)); return S &gt; 0;&#125; 得票最高的解法： orz。。 NO.3题目描述： 我的解法：123456789101112function sumArray(array) &#123; if(!array || array == null)&#123;return 0&#125;; var max = Math.max.apply(null,array); var min = Math.min.apply(null,array); array.splice(array.indexOf(max),1); array.splice(array.indexOf(min),1); console.log(array); for(var sum = 0,i = 0;i &lt; array.length;i++)&#123; sum += array[i]; &#125; return sum;&#125; 得票最高的解法：1sumArray = a =&gt; a ? a.sort((x, y) =&gt; x - y).slice(1, -1).reduce((s, e) =&gt; s + e, 0) : 0 ??? (黑人问号脸。。 NO.4题目描述： 我的解法：1234567var gimme = function(inputArray) &#123; let min = inputArray.indexOf(Math.min(...inputArray)), max = inputArray.indexOf(Math.max(...inputArray)); if (min === 0 &amp;&amp; max === 2 || max === 0 &amp;&amp; min === 2) return 1; if (min === 1 &amp;&amp; max === 2 || max === 1 &amp;&amp; min === 2) return 0; if (min === 0 &amp;&amp; max === 1 || max === 0 &amp;&amp; min === 1) return 2;&#125;; 得票最高的解法： 溜了溜了。。 PS。虽然这些高票答案精简得不行，但至少我写的代码块可读性强啊。。（微笑]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>codewars</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【二】]]></title>
    <url>%2F2017%2F07%2F20%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO : 前端面试。 基础部分 1.prototype和proto的关系是什么2.meta viewport原理3.域名收敛是什么4.float和display：inline-block；的区别5.前端优化策略列举6.首屏、白屏时间如何计算7.闭包8.作用域链9.ajax如何实现、readyState五种状态的含义10.jsonp如何实现11.怎么处理跨域12.restful的method解释13.get和post的区别14.事件模型解释15.编写一个元素拖拽的插件16.编写一个contextmenu的插件17.编写web端cookie的设置和获取方法18.兼容ie６的水平垂直居中19.兼容ie的事件封装20.h5和原生android的优缺点21.编写h5需要注意什么22.xss和crsf的原理以及怎么预防23.css优先级24.如何实现点击radio的文字描述控制radio的状态（通过label实现）25.delegate如何实现 框架原理angularjs 1.angular的directive怎么写2.angular的脏检查（双向绑定）是如何实现的3.依赖注入如何实现4.scope如何实现5.$parse模块如何实现（主要自己写了一个类似的库） react 1.react在setState后发生了什么（直接说了setState源码）2.flux解释3.对react有什么了解（直接说了react中虚拟dom内部表示，mount过程源码和同步过程源码） jsBridge 如何说服对方使用jsBridge requirejs 1.amd和cmd区别，怎么了解到这些区别的，是否是去看了规范2.requirejs那些经常用的方法，然后对其进行解释 weex weex实现大致原理（只写过demo，面试管很好没有难为我，只问了这一个问题） http协议 1.accept是什么，怎么用2.http协议状态码，302和303的区别3.前端缓存如何实现、etag如何实现、etag和cache-control的max-age的优先级哪个比较高以及为什么、cache-control和expire优先级哪个比较高以及为什么 node 1.Buffer模块是干什么的2.Stream是什么，使用的两种模式3.http模块如何将异步处理方式实现成同步处理方式，具体解析请参考http模块如何将异步处理转成同步处理http://blog.csdn.net/wanglei20116527/article/details/62892070 其他问题 1.utf8和gbk的区别2.知道页面上某个点的坐标，如何获取该坐标上的所有元素3.angular、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）4.7点15分小于180度的夹角是多少5.大数相加6.给５升和６升的水杯如何倒出３升的水7.一班喜欢足球的人60%，喜欢排球的70%，喜欢篮球的80%，求喜欢足球和排球的占多少8.前端异常监测如何实现9.直播点赞按钮的冒泡功能如何实现10.js的uglify如何实现11.项目架构、如何带人（自己带过一个小团队）12.前端工程化方面做了哪些东西 面试中的收获 最开始面试时只阅读过angular源码，一面完后面试官对我说react用的不熟悉没关系，弄懂原理也可以，之后三天疯狂阅读react源码，对于react中虚拟dom内在表示、mount过程、setState的同步过程有了清晰的认识。面试官建议去阅读node的http模块和Stream模块源码，其中node-v0.1.100的http模块源码已经阅读完，并且写了一个基于net模块的http模块。node-v6.9.1的Stream模块源码现在还在阅读中。初步了解了前端异常监测，并且了解了百姓网、腾讯和阿里在前端异常监测的一些方案和框架。阅读了大量前端工程化方面的博文，对前端工程化有了进一步的理解。了解了angular和react产生背景。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html/css</tag>
        <tag>http</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【一】]]></title>
    <url>%2F2017%2F07%2F18%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO ：这段时间遇到的面试题。 1.前端页面由哪三层构成及各层的作用 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本语言负责。解决了页面上“内容应该如何对事件作出反应”的问题。 2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea; 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote; 空元素：br、meta、hr、link、input、img。 3.简述盒模型 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。CSS3中有个box-sizing属性可以控制盒子的计算方式。 W3C盒子模型：content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。 IE6盒子模型：border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。 4.什么是CSS Hack针对不同的浏览器写不同的CSS,就是 CSS Hack。IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：123456789101112131415 // 1、条件Hack&lt;!--[if IE]&gt; &lt;style&gt; .test&#123;color:red;&#125; &lt;/style&gt;&lt;![endif]--&gt;// 2、属性Hack .test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */ &#125;// 3、选择符Hack * html .test&#123;color:#090;&#125; /* For IE6 and earlier */ * + html .test&#123;color:#ff0;&#125; /* For IE7 */ 5.简述同步和异步 同步是阻塞模式：同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步是非阻塞模式：异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 6.浏览器的内核分别是什么 IE: trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 7.什么叫优雅降级和渐进增强及其区别 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 8.px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 9.浏览器本地存储 sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 10.web storage和cookie的区别 Cookie的大小是受限的； 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽； cookie还需要指定作用域，不可以跨域调用； Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie； Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生； IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage； 11.请列举几种可以清除浮动的方法 浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部由于不存在其他普通流元素了，表现出高度为0（高度塌陷）。 添加额外标签，例如&lt;div style=”clear:both”&gt;&lt;/div&gt; 使用br标签和其自身的html属性，例如&lt;br clear=”all” /&gt; 父元素设置 overflow：hidden；在IE6中还需要触发hasLayout，例如zoom:1； 父元素设置 overflow：auto 属性；同样IE6需要触发hasLayout； 父元素也设置浮动； 父元素设置display:table； 使用:after 伪元素；由于IE6-7不支持:after，使用 zoom:1触发hasLayout。 在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称BFC。 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。 IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。 12.对BFC规范的理解 BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动，防止与浮动元素重叠。 13.WEB应用从服务器主动推送Data到客户端有那些方式 Html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe &lt;script&gt;标签的长时间连接(可跨域) 14.网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 15.对标签语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 16.HTML与XHTML二者有什么区别 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 17.请列举几种隐藏元素的方法 visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。 opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 display: none；元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。 HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态 height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。 filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。 18.CSS的选择器 元素选择器：* 、E、 E#id、 E.class 关系选择器：E、F、E&gt;F、E+F、E~F 属性选择器：E[att]、E[att=”val”]、E[att~=”val”]、E[att^=”val”]、E[att$=”val”]、E[att*=”val”]、E[att|=”val”] 伪类选择器：E:link、E:visited、E:hover、E:active、E:focus、E:lang(fr)、E:not(s)、E:root、E:first-child、E:last-chil等 伪对象选择器：E:first-letter/E::first-letter、E:first-line/E::first-line、E:before/E::before、E:after/E::after、E::selection 19.CSS的权重规则 一个行内样式：+1000； 一个ID：+100； 属性选择器/class类/伪类选择器：+10； 一个元素名/伪对象选择器：+1。 20.CSS伪类与CSS伪对象的区别 CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西，根本区别在于：它们是否创造了新的元素（抽象） 伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类。 伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 21.position的几个取值 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）。 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。 static：默认值。没有定位，元素出现在正常的流中。 22.position的absolute与fixed的异同点 相同： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上 区别： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 23.外边距重叠 外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 24.什么是JavaScript闭包 当函数可以记住并访问所在的作用域时，就产生了闭包，即使函数是在当前作用域之外执行。闭包有如下特性： JavaScript允许你使用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量 闭包可以更新外部变量的值 用闭包模拟私有方法 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 25.JS如何实现面向对象和继承机制 创建对象方法： 利用json创建对象 使用JavaScript中的Object类型 通过创建函数来生成对象 继承机制： 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上 prototype模式，继承new函数的模式 直接继承函数的prototype属性，对b的一种改进 利用空对象作为中介 在ECMAScript5中定义了一个新方法Object.create()，用于创建一个新方法 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《JavaScript中的对象克隆》 26.对this指针的理解 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this指的是：调用函数的那个对象。 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 作为对象方法的调用，这时this就指这个上级对象。 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 27.JS常用的绑定事件的方法有哪些 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，查看事件列表。 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。 绑定事件监听函数，标准浏览器使用 addEventListener() ，IE11以下版本attachEvent() 来绑定事件监听函数，通称为DOM2事件系统。 28.解释下javascript的冒泡和捕获12345&lt;div id="click1"&gt; &lt;div id="click2"&gt; &lt;div id="click3"&gt;事件&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型。 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型。 W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段。 事件监听函数addEventListener()的第三个参数就是控制方法是捕获还是冒泡 29.jQuery的特点 一款轻量级的js库 丰富快速的DOM选择器 链式表达式 事件、样式、动画等特效支持 Ajax操作封装，支持跨域 跨浏览器兼容 插件扩展开发 30.js延迟加载的方式有哪些 将script节点放置在最后&lt;/body&gt;之前 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 通过监听onload事件，动态添加script节点 通过ajax下载js脚本，动态添加script节点 31.如何解决跨域问题 JSONP（JSON with Padding），填充式JSON iframe跨域 HTML5的window.postMessage方法跨域 通过设置img的src属性，进行跨域请求 跨域资源共享（CORS），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 32.哪些操作会造成内存泄漏 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。 闭包可以维持函数内局部变量，使其得不到释放。 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。 33.JavaScript中的变量声明提升 函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。 function优先声明于var。 函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。 123456789101112131415function foo() &#123; bar(); var x = 1;&#125;function foo() &#123;//等同于 var x; bar(); x = 1;&#125;function test() &#123; foo(); // TypeError "foo is not a function" bar(); // "this will run!" var foo = function () &#123; &#125;// 函数表达式被赋值给变量'foo' function bar() &#123; &#125;// 名为'bar'的函数声明&#125; 34.JavaScript原型和原型链 原型： 原型是一个对象，其他对象可以通过它实现属性继承。 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器proto。 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。 原型链： 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系称为原型链。 这条链的末端一般总是默认的对象原型。 35.JavaScript中的作用域和作用域链 变量的作用域（scope）：程序源代码中定义这个变量的区域。 作用域链：是一个对象列表或链表，这组对象定义了这段代码“作用域中”的变量。查找变量会从第一个对象开始查找，有则用，无则查找链上的下一个对象。 36.jQuery源码以及jQuery的实现原理 jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件), 一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想 37.输入完网址按下回车到看到网页这个过程中发生了什么 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 38.关于前端性能优化 请求优化：合并JS和CSS，减少DNS查找次数，避免重定向，使用GET完成AJAX请求，减小请求中的Cookie，缓存资源，使用CDN，开启GZip，压缩HTML页面，开启长连接，避免行内脚本阻塞并行下载，少用iframe（阻塞onload事件，影响并行下载）。 CSS优化：样式表置于页面顶部，避免使用CSS表达式，使用外部JS和CSS，压缩JS和CSS，避免滤镜。 JavaScript优化：脚本置于页面底部，减少DOM访问，减少重绘和重排，尽量使用局部变量，使用定时器分割大型任务，用合适的正则操作字符串，惰性模式减少分支，事件委托，第三方代码异步加载，节流与去抖动，使用localStorage替代cookie。 图片优化：内联图使用Data:URL，压缩图片或使用WebP格式，固定图片尺寸，图片预加载，图片延迟加载，使用字体矢量图标，Sprites图片。 39.减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 40.以前端角度出发做好SEO需要考虑什么 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 41.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 42.请求服务器时的状态码。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败 常见的有： 200 OK 访问正常表示成功访问,为网站可正常访问时的状态。 301 Moved Permanently 301重定向永久重定向对搜索引擎相对友好的跳转方式，当网站更换域名时可将原域名作301永久重定向到新域名，原域名权重可传递到新域名，也常有将不含www的域名301跳转到含www的，如xxx.com通过301跳转到www.xxx.com 302 Found 为临时重定向易被搜索引擎判为作弊,比如asp程序的response.Redirect()跳转、js跳转或静态http跳转。 400 Bad Request 域名绑定错误一般是服务器上域名未绑定成功，未备案等情况。 401 Unauthorized 未授权您的Web服务器认为，客户端发送的 HTTP 数据流是正确的，但进入网址 (URL) 资源 ， 需要用户身份验证 ， 而相关信息 1 ）尚未被提供, 或 2 ）已提供但没有通过授权测试。这就是通常所知的“ HTTP 基本验证 ”。 需客户端提供的验证请求在 HTTP 协议中被定义为 WWW – 验证标头字段 (WWW-Authenticate header field) 403 Forbidden 没有权限访问此站你的IP被列入黑名单，连接的用户过多，可以过后再试，网站域名解析到了空间，但空间未绑定此域名等情况。 404 Not Found 文件或目录不存在表示请求文件、目录不存在或删除，设置404错误页时需确保返回值为404。常有因为404错误页设置不当导致不存在的网页返回的不是404而导致搜索引擎降权。 500 Internal Server Error 程序或服务器错误表示服务器内部程序错误，出现这样的提示一般是程序页面中出现错误，如小的语法错误，数据连接故障等。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html/css</tag>
        <tag>http</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则表达学习]]></title>
    <url>%2F2017%2F05%2F24%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是正则表达式正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，搜索模式可用于文本搜索和文本替换。 正则表达式的语法 /主体/修饰符(可选) 其中，第一个“/“是这个正则表达式的头部,主体是我们想要匹配的模式,第二个“/“是这个正则表达式的尾部，修饰符有三个： i（intensity）：大小写不敏感； g（global）：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行； m（multiple）：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用。 正则表达式的常用方法 test( ) : 在字符串中查找符合正则的内容，若查找到返回true,反之返回false。用法：正则.test(字符串) 123456789// 测试是否是数字：var str = '374829348791';var re = /\D/; // \D代表非数字if( re.test(str) )&#123; // 返回true,代表在字符串中找到了非数字。 console.log('不全是数字');&#125;else&#123; console.log('全是数字');&#125; search( ) ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回-1。用法：字符串.search(正则) 123456// 在字符串中找字母b，且不区分大小写：var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i'); 也可以这样写console.log( str.search(re) ); // 1 match( ) : 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。用法： 字符串.match(正则)量词：+ 至少出现一次 匹配不确定的次数（匹配就是搜索查找的意思）。 12345//找出指定格式的所有数字，如下找到 123，54，33，879var str = 'haj123sdk54hask33dkhalsd879';var re = /\d+/g; // 每次匹配至少一个数字 且全局匹配 如果不是全局匹配，当找到数字123，它就会停止了。就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，8，7，9并不是我们想要的，有了加号，每次匹配的数字就是至少一个了。console.log( str.match(re) ); // [123，54，33，879] match方法也会返回自己的子项，如下： 12345// 当match不加g的时候才可以获取到子项的集合:var str = 'abc';var re = /(a)(b)(c)/;console.log( str.match(re) ); //[abc,a,b,c](返回的是匹配结果,以及每个子项) replace() :查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。用法： 字符串.replace(正则,新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符） 12345678910111213141516171819202122//敏感词过滤，比如 我爱北京天安门，天安门上太阳升。------我爱*****，****上太阳升。即北京和天安门变成*号。~~//一开始我们可能会想到这样的方法：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,'*'); console.log(str2) //我爱**，*上太阳升 //这种只是把找到的变成了一个*，并不能几个字就对应几个*。~~//要想实现几个字对应几个*，我们可以用回调函数实现：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,function(str)&#123; console.log(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门 var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; //所以搜索到了几个字就返回几个* &#125;);console.log(str2) //我爱*****，***上太阳升 //整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。 正则表达式中的字符 ^ : 正则的最开始位置，就代表起始的意思。注意：/[ ^ a] / 和 / ^ [a]/ 是不一样的，前者是排除的意思，后者是代表首位。 eg:”^ The”–表示所有以”The”开始的字符串（”There”，”The cat”等）; 1234567// 判断是不是QQ号:// 首先想QQ号的规则：1.首位不能是0 ；2.必须是 5-12位的数字。 var str = '1445427773';var re = /^[1-9]\d&#123;4,11&#125;$/;console.log( re.match(str) ); $ : 正则的最后位置，就代表结束的意思。eg:”of despair$”–表示所以以”of despair”结尾的字符串; 12345678910// 去掉前后空格（面试题经常出现）:function trim(str)&#123; var re = /^\s+|\s+$/g; // |代表或者 \s代表空格 +至少一个 前面有至少一个空格 或者后面有至少一个空格 且全局匹配 return str.replace(re,''); //把空格替换成空&#125;var str = ' hello ';console.log('('+str+')');console.log( '('+trim(str)+')' ); //为了看出区别所以加的括号。 ( ) : 小括号，叫做分组符。就相当于数学里面的括号。如下： 12345678var str = '2013-6-7';var re1 = /\d-+/g; // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为： 3- 6-var re2 = /(\d-)+/g; // 全局匹配数字，横杠，数字和横杠整体数量至少为1 3-6-var re3 = /(\d+)(-)/g; // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-console.log(str.match(re1));console.log(str.match(re2));console.log(str.match(re3)); 同时，正则中的每一个带小括号的项，都叫做这个正则的子项。子项在某些时候非常的有用，比如下面这个例子： 123456789101112131415// 让2013-6-7 变成 2013.6.7：var str = '2013-6-7';var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; // replace()中如果有子项， // 第一个参数：$0（匹配成功后的整体结果 2013- 6-）, // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d 2013, 6) // 第三个参数 : $1(匹配成功的第二个分组，这里指的是- - - ) return $1 + '.'; // 分别返回2013. 6. &#125;);console.log( str ); // 整个过程就是利用子项把2013- 6- 分别替换成了2013. 6. 最终弹出2013.6.7 转义字符: \s : 空格 \S : 非空格 \d : 数字 \D : 非数字 \w : 字符 ( 字母 ，数字，下划线_ ) \W : 非字符 .（点）: 任意字符 . : 真正的点 \b : 独立的部分 （ 起始，结束，空格 ） \B : 非独立的部分 1234567var str1 = 'onetwo';var str2 ="one two";var re = /one\b/; // e后面必须是独立的 可以是起始，空格，或结束console.log( re.test(str1) ); // falseconsole.log( re.test(str2) ); // true 量词：代表出现的次数。 {n,m} : 至少出现n次，最多m次;“ab{3,5}”：表示一个字符串有一个a跟着3到5个b;“ab{2,}”：表示一个字符串有一个a跟着至少2个b; {n,} : 至少n次; * : 任意次,相当于{0,};“ab*”：表示一个字符串有一个a后面跟着零个或若干个b。（”a”, “ab”, “abbb”,……）； ？：零次或一次,相当于{0,1};“ab?”：表示一个字符串有一个a后面跟着零个或者一个b; + ：一次或任意次,相当于 {1,};“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多; {n} ：正好n次;“ab{2}”：表示一个字符串有一个a跟着2个b（”abb”). [ ]： 表示某个集合中的任意一个。方括号表示某些字符允许在一个字符串中的某一特定位置出现。“[ab]”：表示一个字符串有一个”a”或”b”（相当于”a¦b”);“[a-d]”：表示一个字符串包含小写的’a’到’d’中的一个（相当于”a¦b¦c¦d”或者”[abcd]”);“ ^ [a-zA-Z]”：表示一个以字母开头的字符串;“[0-9]%”：表示一个百分号前有一位的数字;“, [a-zA-Z0-9] \$ “ ：表示一个字符串以一个逗号后面跟着一个字母或数字结束。你也可以在方括号里用’ ^ ‘表示不希望出现的字符，’ ^ ‘应在方括号里的第一位。（如：”%[ ^ a-zA-Z]%”表示两个百分号中不应该出现字母)。为了逐字表达，你必须在” ^ .$ ( ) ¦ * + ? { \ “这些字符前加上转移字符’ \ ‘。请注意在方括号中，不需要转义字符。 12345// 匹配HTML标签 比如&lt;div class="b"&gt;hahahah &lt;/div&gt; 找出标签&lt;div class="b"&gt;&lt;/div&gt;var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号 中间至少一个非右括号的内容(因为标签里面还有属性等一些东西)，然后匹配右括号var re = /&lt;[\w\W]+&gt;/g; //匹配左括号 中间至少一个字符或者非字符的内容，然后匹配右括号// 其实就是找到左括号，然后中间可以有至少一个内容，一直到找到右括号就代表是一个标签。 \a ：表示重复的某个子项。比如： \1 : 重复的第一个子项; \2 : 重复的第二个子项; 12/ (a) (b) (c) \1/ // 匹配 abca/ (a) (b) (c) \2/ // 匹配 abcb 12345678910111213141516171819202122// 找重复项最多的字符个数(面试题中经常问到）:var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split(''); // 把字符串转换为数组str = arr.sort().join(''); // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串console.log(str); // aaddjjkklsssssssssssssssssvar value = '';var index = 0; var re = /(\w)\1+/g; // 匹配字符，且重复这个字符，重复次数至少一次。str.replace(re,function($0,$1)&#123; // alert($0); 代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss // alert($1); 代表每次匹配成功的第一个子项，也就是\w: a d j k l S if(index&lt;$0.length)&#123; // 如果index保存的值小于$0的长度就进行下面的操作 index = $0.length; // 这样index一直保存的就在最大的长度 value = $1; // value保存的是出现最多的这个字符 &#125;&#125;); console.log('最多的字符:'+value+',重复的次数:'+index); // s 17 split( ):字符串中的方法，把字符串转成数组。sort( ):数组中的排序方法，按照ACALL码进行排序。join( ):数组中的方法，把数组转换为字符串 常用的一些正则表达式 校验是否全由数字组成（[0-9]中的字符出现次数的范围是1到20次): /\^[0-9]{1,20}$ / 校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串: /\^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$ / 校验用户姓名：只能输入1-30个以字母开头的字串: /\^[a-zA-Z]{1,30}$/ 校验密码：只能输入6-20个字母、数字、下划线: /\^(\w){6,20}$/ 校验普通电话、传真号码：可以“+”或数字开头，可含有”-“ 和 “ “ /\^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/ 校验URL: /\^http[s]{0,1}:\/\/.+$/ 校验身份证： /[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x/ 校验Email(起始至少为一个字符(\w字母，数字或者下划线)，然后匹配@,接着为任意个字母或者数字，\.代表真正的点，.后面为至少一个的字符（a-z）,同时这个(比如.com)整体为一个子项作为结束，可以出现1-3次。因为有的邮箱是这样的.cn.net。)： /\^\w+@[a-z0-9]+(.[a-z]+){1,3}$ /]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个测试颜色辨识度的小游戏]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A2%9C%E8%89%B2%E8%BE%A8%E8%AF%86%E5%BA%A6%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[testColorResolution A small game that can test your eyes for color recognition 简介之前有段时间网上有一个挺流行的小游戏叫做“看你有多色”。然后我看了网上的教程用createJS仿写了一个，具体实现后效果如下： 游戏开始 点击与其它方块颜色不一样的方块 一定步数之后，方块数量达到9*9后不再增加 以下是部分关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243var stage = new createjs.Stage("gameView");createjs.Ticker.setFPS(30);createjs.Ticker.addEventListener("tick",stage);var gameView = new createjs.Container();stage.addChild(gameView);var n = 2;function addRect()&#123; var cl = parseInt(Math.random()*1000000); var color = "#" + cl; var cl1 = cl+90000; var RectColor = "#" + cl1; var x = parseInt(Math.random()*n); var y = parseInt(Math.random()*n); for(var indexX = 0;indexX &lt; n ;indexX++)&#123; for(var indexY = 0;indexY &lt; n;indexY++)&#123; var r = new Rect(n,color,RectColor); gameView.addChild(r); r.x = indexX; r.y = indexY; if(r.x == x &amp;&amp; r.y == y)&#123; r.setRectType(2); &#125; r.x = indexX*(400/n); r.y = indexY*(400/n); if(r.getRectType() == 2)&#123; r.addEventListener("click",function()&#123; var audio = document.getElementById("clickSound"); audio.play(); if(n&lt;9)&#123; ++n; &#125; gameView.removeAllChildren(); addRect(); &#125;) &#125; &#125; &#125;&#125;addRect(); 表示颜色的时候用的十六进制而不是RGB，然后随机颜色用的是random函数。而唯一一个不同于其他方块的方块颜色是要比其他颜色浅一些的。点击其他方块没有任何特效，点击唯一正确的方块会进入下一关并且伴随有音效提示，同时整个游戏会有BGM。 源码地址：https://github.com/1996szw/testColorRecognition]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP的三次握手和四次挥手]]></title>
    <url>%2F2017%2F04%2F02%2F%E5%85%B3%E4%BA%8ETCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[1.TCP报文格式 几个重点字段： （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 需要注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。 2.三次握手 TCP(Transmission Control Protocol)即传输控制协议，TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 位码即tcp标志位,有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码)Acknowledge number(确认号码)establish 建立，创建 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。SYN攻击： 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： netstat -nap | grep SYN_RECV 3.四次挥手所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。 4.问答1.为什么建立连接是三次握手，而关闭连接却是四次挥手呢？答：这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>http</tag>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现垂直水平居中]]></title>
    <url>%2F2017%2F03%2F18%2FCSS%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[CSS实现垂直水平居中 第一种方法（position:absolute，负margin法） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的左外边距、上外边距为宽高的负1/2--&gt;margin-left:-100px;margin-top:-200px;&#125; 优点：兼容性好；缺点：必须固定元素的宽高 第二种方法（使用css3的新属性transform:translate(x,y)） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的相对于自身的偏移度为负50%(也就是元素自身尺寸的一半)--&gt;transform:translate(-50%,-50%);&#125; 这是css3里的样式，在移动端用得较多；缺点：兼容性不好，只支持IE9+的浏览器。 第三种方法（设置margin为auto） 1234567891011121314151617div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、下、左、右都为0--&gt;left:0;right:0;top:0;bottom:0;&lt;!--设置元素的margin样式值为 auto--&gt;margin:auto;&#125; 优点：兼容性较好；缺点：不支持IE7以下的浏览器。 第四种方法（inline-block方法） 场景： 一个块状元素A内 有若干个块状元素B，要达到的效果是 ，所有块状元素B 在 元素A 内水平居中显示。 12345&lt;div class="A"&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt;&lt;/div&gt; 首先，我们要设置元素A的大小为500px，设置背景色为green方便查看。 1234.A｛ width:500px; backgrond-color:green;｝ 然后， 设置所有元素B 的宽度为100px，高度为100px，外边据都为5px，背景色为#000方便查看。 123456.B｛ width:100px; height:100px; magin:5px; backgrond-color:green;｝ 此时的效果： 我们要做的是，先把所有的元素B都设置为行内块级元素，让他们都排成一行，即使用：display:inline-block； 最后就是让所有的元素B居中了， 到这里，相信很多人就猜到下一步要做什么了，我锦上添花，解释一下。 先想一想，如果是行内元素， 我们一般让它怎么居中呢？答：当然是给它的父容器加一个text-align:center的样式。 这里我们已经把所有的元素B变成了行内块， 也就有了行内元素的特性，所以，我们下一步要做的就是给元素A加text-align:center， 这样我们的目的就达到了，请看效果： 优点：兼容性较好；缺点：父元素和子元素的宽度都要已知。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
        <tag>study</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的DOM对象学习]]></title>
    <url>%2F2017%2F03%2F12%2FJavascript%E4%B8%AD%E7%9A%84DOM%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DOM 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 先来看看下面代码:12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html"; charset="gb2312"&gt;&lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;…&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作（DOM常见的API）: 注意:前两个是document方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeCodeCamp上面的JS算法题]]></title>
    <url>%2F2017%2F03%2F11%2FFreeCodeCamp%E4%B8%8A%E9%9D%A2%E7%9A%84JS%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Info:Javascript中操作字符串和数组一些常见的方法。 Split Strings with split()12345var string = "Split me into an array";var array = [];array = string.split(" ");console.log(array); //[ 'Split', 'me', 'into', 'an', 'array' ] // split() 方法用于把一个字符串分割成字符串数组。// 提示： 如果把空字符串 (“ “) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。// 注意： split() 方法不改变原始字符串。 Get the sub string with substring/substr/slice()1234567891011var s = 'hello, world'var r1 = s.substring(0, 5); // 从索引0开始到5(不包括5)var r2 = s.substring(7); // 从索引7开始到结束var r3 = s.substr(2,4); //从索引开始找接下来的4个字符var r4 = s.slice(-5);console.log(r1); //helloconsole.log(r2); //worldconsole.log(r3); //llo,console.log(r4); //world Title Case a Sentence with toUpper/LowerCase()12345678910111213141516171819202122// 句中单词首字母大写:function titleCase(str) &#123; // 请把你的代码写在这里 arr = str.split(" "); var newStr = ""; for(var i = 0;i&lt;arr.length;i++)&#123; newStr += arr[i][0].toUpperCase(); for(var j = 1;j&lt;arr[i].length;j++)&#123; newStr += arr[i][j].toLowerCase(); &#125; if(i!=arr.length-1)&#123; newStr += " "; &#125;&#125; return newStr;&#125;var r = titleCase("I'm a little tea pot");console.log(r); //I'm A Little Tea Pot Get the index of string in a stringObj with indexOf/lastIndexOf()123456789var s = 'hello, world';var r1 = s.indexOf('world'); // 找到指定的子串,返回该子串第一次出现的位置var r2 = s.indexOf('sorld'); // 没有找到指定的子串，返回-1var r3 = s.lastIndexOf('l'); // 找到指定的子串，返回该子串最后一次出现的位置console.log(r1); //7console.log(r2); //-1console.log(r3); //10 Iterate over Arrays with map()1234567891011121314151617var oldArray = [1,2,3,4,5];// 只能在这一行下面写代码var newArray = oldArray.map(function(val)&#123; return val + 3;&#125;);console.log(newArray); //[ 4, 5, 6, 7, 8 ]// another// var numbers = [4, 9, 16, 25];// function myFunction() &#123;// x = document.getElementById("demo")// x.innerHTML = numbers.map(Math.sqrt);// &#125; // map() 方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。// map() 方法按照原始数组元素顺序依次处理元素。// 注意： map() 不会对空数组进行检测。// 注意： map() 不会改变原始数组。 Condense arrays with reduce()12345678910var array = [4,5,6,7,8];var singleVal = 0;// 只能在这一行下面写代码singleVal = array.reduce(function(pre,cur)&#123; return pre + cur ;&#125;);console.log(singleVal); //30 // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并(迭代)，最终计算为一个值。// 注意: reduce() 对于空数组是不会执行回调函数的。 Filter Arrays with filter()123456789var oldArray = [1,2,3,4,5,6,7,8,9,10];// 只能在这一行下面写代码var newArray = oldArray.filter(function(val)&#123; return val &lt; 6;&#125;);console.log(newArray); //[ 1, 2, 3, 4, 5 ] // filter 方法用来迭代一个数组，并且按给出的条件过滤出符合的元素。// filter 方法传入一个回调函数，这个回调函数会携带一个参数，参数为当前迭代的项（我们叫它 val ）。// 回调函数返回 true 的项会保留在数组中，返回 false 的项会被过滤出数组。 Sort Arrays with sort()1234567var array = [1, 21, 12, 2];array.sort(function(a, b) &#123; return b - a;&#125;); // 将数组元素从大到小排序console.log(array); //[ 21, 12, 2, 1 ] 1234567891011121314151617// 数组排序并找出元素索引:function where(arr, num) &#123; // 请把你的代码写在这里 var newArr = []; newArr = arr.concat(num); newArr.sort(function(a,b)&#123; return a-b; &#125;); for(var i =0;i&lt;newArr.length;i++)&#123; if(newArr[i] === num)&#123; return i;&#125; &#125;&#125;var r = where([40, 60], 50);console.log(r); //1 // sort() 方法将改变原数组，返回被排序后的数组。// sort() 可以把比较函数作为参数传入。比较函数有返回值，当 a 小于 b，返回一个负数；当 a 大于 b ，返回一个正数；相等时返回0。// 如果没有传入比较函数，它将把值全部转成字符串，并按照字母顺序进行排序。 Reverse Arrays with reverse()12345678var array = [1,2,3,4,5,6,7];var newArray = [];// 只能在这一行下面写代码newArray = array.reverse();console.log(newArray); //[ 7, 6, 5, 4, 3, 2, 1 ] // reverse()方法用于颠倒数组中元素的顺序。// reverse()方法会改变原来的数组，而不会创建新的数组。 Concatenate Arrays with concat()12345678var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe);console.log(newArray); //[ 1, 2, 3, 4, 5, 6 ] // concat()方法用于连接两个或多个数组。// concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 Join Strings with join()12345678var joinMe = ["Split","me","into","an","array"];var joinedString = ' ';// 只能在这一行下面写代码joinedString = joinMe.join(joinedString);console.log(joinedString); //Split me into an array // join() 方法用于把数组中的所有元素转换一个字符串。// 元素是通过指定的分隔符进行分隔的。 Find the Longest Word in a String with Math.max.apply()12345678910111213141516171819// 找到字符串中最长的单词function findLongestWord(str) &#123; var maxLength = 0; var arr = []; var s = str.split(" "); console.log(str); for(var i = 0;i&lt;s.length;i++)&#123; arr[i] = s[i].length; &#125; maxLength = Math.max.apply(null,arr); return maxLength;&#125;var r = findLongestWord("The quick brown fox jumped over the lazy dog");console.log(r); //6 //Math.max.apply()方法可以得到数组中最大的数,Math.max.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 Remove the smallest number in an array with splice()123456789function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); //[ 2, 3, 4, 1, 2, 5 ] //splice()方法:arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>algorithm</tag>
        <tag>freecodecamp</tag>
        <tag>array</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记【二】]]></title>
    <url>%2F2017%2F03%2F08%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:JS学习的补充笔记，包括JS-Web-Api、事件绑定、事件冒泡、事件代理、AJAX、跨域和存储 日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date(); //Date()是一个构造函数，.now是他的一个属性函数dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月（0 - 11）dt.getDate(); //日（0 - 31）dt.getHours(); //小时（0 - 23）dt.getMinutes(); //分钟（0 - 59）dt.getSeconds(); //秒（0 - 59） MathMath.random()获取随机数 数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否至少有一个元素符合条件 sort 排序 map 对元素重新组装，生成一个新数组 filter 过滤符合条件的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.forEachvar arr = [1,2,3];arr.forEach( function(item, index) &#123; console.log(index,item);// 0 1 1 2 2 3&#125;);// 2.everyvar arr = [1,2,3];var result = arr.every(function(item,index)&#123; if(item &lt; 4)&#123; return true; &#125;&#125;)console.log(result); // true// 3.somevar arr = [1,2,3];var result = arr.some(function(item,index)&#123; if(item &lt; 2)&#123; return true; &#125;&#125;)console.log(result); //true// 4.sortvar arr = [1,4,3,5,2];var arr2 = arr.sort(function(a,b)&#123; return a - b; //从小到大排序&#125;)console.log(arr2); //[1,2,3,4,5]// 5.mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index)&#123; return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;)console.log(arr2); //[ '&lt;b&gt;1&lt;/b&gt;', '&lt;b&gt;2&lt;/b&gt;', '&lt;b&gt;3&lt;/b&gt;', '&lt;b&gt;4&lt;/b&gt;' ]// 6.filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index)&#123; //通过某个条件过滤数组 if(item &gt;= 2)&#123; return true; &#125;&#125;)console.log(arr2); //[2,3] 对象API1234567891011var obj = &#123; x: 100, y: 200, z: 300&#125;var key;for (key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key,obj[key]); &#125;&#125; // x 100 y 200 z 300 事件通用事件绑定123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href="http://baidu.com" id="link1"&gt; &lt;button type="button" id="btn1"&gt;我是按钮&lt;/button&gt; &lt;/a&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById('btn1'); btn.addEventListener('click', function(event)&#123; console.log('clicked'); &#125;) function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var a = document.getElementById('link1'); bindEvent(a,'click', function(e)&#123; e.preventDefault(); //阻止默认行为 alert('clicked'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件冒泡123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var p1 = document.getElementById('p1'); var body = document.body; bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); //阻止事件冒泡 alert('激活'); &#125;) bindEvent(body,'click',function(e)&#123; alert('取消'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代理 （冒泡的应用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;a href="http://baidu.com" id="link1"&gt;a1&lt;/a&gt; &lt;a href="http://baidu.com" id="link2"&gt;a2&lt;/a&gt; &lt;a href="http://baidu.com" id="link3"&gt;a3&lt;/a&gt; &lt;a href="http://baidu.com" id="link4"&gt;a4&lt;/a&gt; &lt;p id = "p1"&gt;激活&lt;/p&gt; &lt;p id = "p2"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id = "p3"&gt;取消&lt;/p&gt; &lt;p id = "p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function bindEvent(elem,type,selector,fn)&#123; //selector:选择器，是字符串 if (fn == null)&#123; fn = selector; selector = null; &#125; elem.addEventListener(type,function(e)&#123; var target; if (selector)&#123; // 代理 target = e.target; if (target.matches(selector))&#123; fn.call(target,e); &#125; &#125; else &#123; // 不是代理 fn(e); &#125; &#125;) &#125; var div1 = document.getElementById('div1'); bindEvent(div1,'click','a',function(e)&#123; e.preventDefault(); console.log(this.innerHTML); &#125;); var p1 = document.getElementById('p1'); bindEvent(p1,'click',function(e)&#123; console.log(p1.innerHTML); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代理的两个优点：1.使得代码比较简洁2.给浏览器的压力比较小 AJAXXMLHttpRequest123456789101112var xhr = new XMLHttpRequest()xhr.open("GET","/api",false)xhr.onreadystatechange = function () &#123; // 这里的函数为异步执行 if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.send(null) 跨域什么是跨域 可以跨域的三个标签但是有三个标签可以跨域加载资源 &lt;img src = “XXX”&gt; （图片） &lt;link herf = “XXX”&gt; （CSS） &lt;script src = “XXX”&gt; （JS） 这三个标签的场景 &lt;img&gt;用于打点统计，统计网站可能是其他域 &lt;link&gt;&lt;script&gt;可以使用CDN，CDN的也是其他域 &lt;script&gt;可以用于JSONP 跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许就能够获取到，那就是浏览器的同源策略出现了漏洞 解决跨域的方法 JSONP JSONP的工作原理： 很简单，就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，形如：&lt;script src=”http://www.example.net/api?param1=1&amp;param2=2&quot;&gt; &lt;/script&gt;并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）形如:callback({“name”:”hax”,”gender”:”Male”})。 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 补充：“历史遗迹”的意思就是，如果在今天重新设计的话，也许就不会允许这样简单的跨域了嘿，比如可能像XHR一样按照CORS规范要求服务器发送特定的http头。 服务器端设置 http header（即CORS（跨域资源共享）） 存储 cookie localStorage 和 sessionStorage cookie与webStorage的区别]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>js-web-api</tag>
        <tag>ajax</tag>
        <tag>事件</tag>
        <tag>跨域</tag>
        <tag>cookie</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记【一】]]></title>
    <url>%2F2017%2F03%2F06%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:之前JS学习的一些笔记，包括JS变量类型以及JS的三个重点：原型和原型链、作用域与闭包、异步和单线程 变量类型和计算引用类型（3种）对象、数组、函数。 引用类型的内存只存一份，而值类型是存多份 引用类型可以无限扩展属性 typeof（6种）undefined、number、string、boolean、object、function。 强制类型转换 字符串拼接； ==运算符； if条件语句； 逻辑运算（与或非)。 何时使用==if(obj.a == null){ … } //这里是简写，相当于obj.a === null || obj.a === undefined。其他时候全部用三等“===”。 if(…){ }条件为假的几种情况 0； NaN； “”; null; undefined; false。 JS中的内置函数（数据封装内对象） Object； Array； Boolean； Number； String； Function； Date； RegExp； Error。 如何理解JSON JSON.stringify({a:10,b:20}); // 把对象变成字符串 JSON.parse(‘{“a”:10,”b”:20}’)。 // 把字符串变成对象 （JSON只不过是一个JS对象）上面就是JSON常见的两个API。 原型与原型链构造函数12345678910111213function Foo(name,age)&#123; //构造函数首字母大写 this.name = name; this.age = age; this.class = 'class-1'; //return this; //返回这个对象&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);console.log(f); //Foo &#123; name: 'zhangsan', age: 20, class: 'class-1' &#125;console.log(f instanceof Object); //true 构造函数—拓展 var a = { } 其实是var a = new Object()的语法糖； var a = [ ] 其实是var a = new Array()的语法糖； function Foo(){…} 其实是var Foo = new Function()的语法糖； 使用instanceof判断一个函数是否是一个变量的构造函数。 原型规则和示例 所有的引用类型（对象、数组、函数）都具有对象特性，即可自由拓展属性（除了”null”之外）； 所有的引用类型（对象、数组、函数）都有一个proto（隐式原型）属性，属性值是一个普通的对象； 所有的函数都有一个prototype（显式原型）属性，属性值是一个普通的对象； 所有的引用类型（对象、数组、函数），proto属性值指向它的构造函数的prototype属性值； 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的proto(即它的构造函数的prototype)中寻找。 123456789101112131415//第一条规则：var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn()&#123;&#125;; fn.a = 100;//第二条规则：console.log(obj.__proto__); //&#123;&#125;console.log(arr.__proto__); //[]console.log(fn.__proto__); //[Function]//第三条规则：console.log(fn.prototype); //fn &#123;&#125;//第四条规则：console.log(obj.__proto__ === Object.prototype); //true 12345678910111213141516171819202122// 第五条规则：// 构造函数function Foo (name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function()&#123; alert(this.name);&#125;// 创建示例var f = new Foo('zhangsan');f.printName = function () &#123; console.log(this.name);&#125;// 测试f.printName(); //zhangsanf.alertName(); //zhangsanf.toString(); //要去 f.__proto__.__proto__中去寻找//console.log(f.__proto__.__proto__.__proto__); //null 补充： 12345678var item;for(item in f)&#123; // 虽然高级浏览器已经在 for in 中屏蔽了来自原型的属性 // 但是还是建议加上这个判断，保证程序的健壮性 if(f.hasOwnProperty(item))&#123; console.log(item); &#125;&#125; 原型链 instanceof用于判断引用类型属于那个构造函数的方法。 关于原型和原型链的几个问题1.如何准确判断一个变量是数组类型： 123var arr = [];arr instanceof Array; //truetypeof arr; //Object(typeof是无法准确判断是否是数组的 2.写一个原型链继承的例子： 12345678910111213141516171819202122232425//普通版：// 动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125;// 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat() 12345678910111213141516171819202122232425262728293031323334//高级版（写一个封装DOM查询的例子）：function Elem (id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val)&#123; var elem = this.elem; if(val)&#123; elem.innerHTML = val; return this; //链式操作 &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function (type,fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem('div1');// console.log(div.html())div1.html('&lt;p&gt;hello world&lt;/p&gt;');div1.on('click',function () &#123; alert('clicked!');&#125;)//因为有第十行的“return this”（返回的是this这个对象），所以可以进行链式操作：// div1.html('&lt;p&gt;hello world&lt;/p&gt;').on('click',function()&#123;// alert('clicked!');// &#125;); 3.描述new一个变量的过程： 即考察对构造函数的理解。 创建一个新对象； this指向这个对象； 执行代码，即对this赋值； 返回this。 4.zepto（或其他框架）源码中如何使用原型链： zepto设计和源码分析 作用域与闭包执行上下文 范围：一段&lt;script&gt;或者一个函数 全局：变量定义、函数声明 （一段&lt;script&gt;） 函数：变量定义、函数声明、this、arguments （一个函数） 123456789console.log(a); //undefinedvar a = 100;fn('zhangsan');function fn (name) &#123; age = 20; console.log(name,age); //zhangsan 20 var age;&#125; this this要在执行时才能确认值，定义时无法确认。 作为构造函数执行； 作为对象属性执行； 作为普通函数执行； call()、apply()、bind()； 1234567891011121314151617181920212223242526272829303132333435363738394041//1.作为构造函数执行function Foo (name) &#123; this.name = name;&#125;var f = new Foo('zhangsan');//2.作为对象属性执行var obj = &#123; name: 'A', printName: function () &#123; console.log(this.name); &#125;&#125;obj.printName(); //A (this ===obj)//3.作为普通函数执行function fn()&#123; console.log(this);&#125;fn(); ///undefined (this === window)//4.call和apply（都用来改变this的值，call在实际工作中用的更多,两者传参方式不一样，apply用数组格式）function fn1(name,age)&#123; alert(name) alert(age) console.log(this)&#125;fn1.call(&#123;x:100&#125;,'zhangsan',22)//bind（同样用来改变this的值，注意函数声明要用函数表达式的方式）var fn2 = function (name,age)&#123; alert(name) alert(age) console.log(this)&#125;.bind(&#123;x:100&#125;)fn2('zhangsan',22) 作用域 JS没有块级作用域； 只有函数和全局作用域； 1234567891011121314// 无块级作用域if(true)&#123; var name = 'zhangsan';&#125; //大括号相当于一个块console.log(name); //zhangsan// 函数和全局作用域var a = 100;function fn () &#123; var a = 200; console.log('fn',a);&#125;fn(); //fn 200console.log('global',a); //global 100 作用域链1234567891011121314var a = 100;function fn1 () &#123; var b =200; function fn2 () &#123; var c = 300; //当前作用域没有定义的变量，即“自由变量”，自由变量要去声明时候的作用域去找，而不是执行时候的作用域 console.log(a); //a是自由变量，则要到当前fn2作用域的父级作用域去找，没有找到，则继续到fn1的父级作用域去找 console.log(b); //b是自由变量，则要到当前fn2作用域的父级作用域去找，即fn1的作用域，找到了 console.log(c); &#125; fn2();&#125;fn1(); //100 200 300 闭包闭包的使用场景 函数作为返回值； 函数作为参数传递； 123456789101112// 1.函数作为返回值： function fn1 () &#123; var a = 100; return function () &#123; // 返回一个函数（函数作为返回值） console.log(a); // 自由变量，父作用域查找 &#125;&#125;// fn1得到一个函数var f1 = fn1();var a = 200;f1(); //100 123456789101112131415// 2.函数作为参数传递function fn1 () &#123; var a = 100; return function () &#123; console.log(a); &#125;&#125;var f1 = fn1();function fn2 (fn) &#123; //函数作为参数传递 var a = 200; fn()&#125;fn2(f1); //100 闭包的示例12345678910111213141516171819202122// 1.查询是否是第一次载入：// 闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad () &#123; var _list = []; return function (id) &#123; if(_list.indexOf(id) &gt;= 0)&#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;// 使用var firstLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true// 在isFirstLoad函数外面，根本不可能改掉_list的值 123456789101112131415// 2.创建10个a标签，点击弹出相应的序号：var i;for(i = 0;i &lt; 10;i++)&#123; (function (i)&#123; // 自执行函数，就是不用调用，只要定义完成，立刻执行的函数 // 函数作用域 var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function(e)&#123; e.preventDefault(); alert(i); //自由变量，要去父级作用域获取值 &#125;) document.body.appendChild(a); &#125;)(i)&#125; 异步和单线程什么是异步（对比同步）1234567891011// 异步：console.log(100);setTimeout(function()&#123; console.log(200);&#125;,1000)console.log(300); //先打印100，然后打印300，过一秒钟再打印200// 对比同步：console.log(100);alert(200); //程序阻塞在这里，如果不点击确认就会卡在这里console.log(300); 何时需要异步 在可能发生等待的情况； 等待过程中不能像alert一样阻塞程序的执行； 因此，所有“等待的情况”都需要异步； //并非“阻塞的情况” 前端使用异步的场景 定时任务：setTimeout、setInterval； 网络请求：ajax请求、动态&lt;img&gt;加载； 事件绑定； setTimeout(表达式,延时时间)和setInterval(表达式,延时时间)经常被用来处理延时和定时任务。setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,而setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。 很多人会将setTimeout包含于被执行函数中,然后在函数外再次使用setTimeout来达到定时执行的目的。这样,函数外的setTimeout在执行函数时再次触发setTimeout从而形成周而复始的定时效果； 使用的时候各有各的优势，使用setInterval，需要手动的停止tick触发。而使用方法中嵌套setTimeout，可以根据方法内部本身的逻辑不再调用setTimeout就等于停止了触发。其实两个东西完全可以相互模拟，具体使用那个，看当时的需要而定了。 12345678910111213141516171819202122// ajax请求代码示例：console.log('start');$.get('./datta1.json',function(data1)&#123; console.log(data1);&#125;)console.log('end');// &lt;img&gt;加载示例：console.log('start');var img = document.createElement('img');img.onload = function()&#123; console.log('loaded');&#125;img.src = '/xxx.img';console.log('end');// 事件绑定示例：console.log('start');document.getElementById('btn1').addEventListener('click', function()&#123; alert('clicked');&#125;)console.log('end'); 异步和单线程1234567891011// 单线程：一次只能干一件事，一个一个排队来console.log(100);setTimeout(function()&#123; console.log(200);&#125;)console.log(300);// 1. 执行第一行，打印100；// 2. 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）；// 3. 执行最后一行，打印300；// 4. 待所有的程序执行完，处于空闲状态时，会立马看有没有暂存起来的需要执行；// 5. 发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行； 关于异步和单线程的几个问题 同步和异步的区别是什么。分别举一个同步和异步的例子： 同步会阻塞代码执行，而异步不会； alert是同步，setTimeout是异步。 一个关于setTimeout的笔试题： 12345678910console.log(1);setTimeout(function()&#123; console.log(2)&#125;,0);console.log(3);setTimeout(function()&#123; console.log(4);&#125;,1000);console.log(5);// result: 1 3 5 2 4]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>JS变量类型</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
        <tag>异步</tag>
        <tag>单线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F03%2F04%2FGithub-Pages-Hexo%E5%8D%9A%E5%AE%A2-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这两天也算是摸爬滚打终于搭建成功了这个Hexo博客，然后也是想把过程记录一下，把整个步骤分享给大家（虽然可能也不会有人看到。。 Hexo本地环境搭建Git环境 首先我们需要一个git环境，MacOS的XCode是自带git的所以也无需重复安装。 如果是Windows用户的话，可以去Git官网根据自己的电脑操作系统位数下载相应的版本，下载完成后点击安装，一路next即可。 Windows用户还需要配置环境变量，具体操作可参考度娘上面的教程：Git的安装与配置 测试是否安装配置成功：win+R打开运行，输入cmd打开命令提示窗口，输入如下命令： git –version 如果正确打印出安装的Git版本号，则说明安装成功。 Node.js环境 Mac用户可以通过Homebrew来安装(推荐)，具体步骤如下： 先安装Homebrew： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 然后更新brew确保其可用： brew update 再安装环境所需的Node.js： brew install node 验证是否安装成功： node -vnpm -v 如果正确打印出安装的Node版本号，则说明安装成功。 Windows用户，可以去Node官网根据自己的操作系统位数下载安装（过程跟上述安装Git的步骤类似，在此不再赘述。。 Hexo环境Hexo是一款基于Node.js的静态博客框架，所以之前的那些步骤都是为了安装hexo所做的准备，具体安装hexo的步骤如下： 选择一个你喜欢的目录，用来存放你的hexo博客的所有文件，在此目录下运行你的Git Bash（Windows直接右键你所选择的目录会有个Git Bash选项，点击即可。Mac用户则是打开你的Terminal工具，cd到你所选择的目录再进行一系列的操作） 正式安装Hexo，输入如下指令： npm install -g hexo-cli 当然由于我国的社会主义核心建设，上述命令可能被墙，从而导致安装失败。此时将命令中的npm镜像源改成国内万能的某宝提供的镜像源即可： sudo npm install -g hexo-cli –registry=https://registry.npm.taobao.org 初始化hexo： hexo init hexo 正确初始化后会得到这样的反馈：INFO Start blogging with Hexo! 安装依赖文件： npm install 部署形成文件： hexo generate(或者 hexo g) 本地测试： hexo server(或者 hexo s) 正确完成到了这一步后，在浏览器输入 http://localhost:4000 后就能看到搭建好的hexo站点了。 接下来的步骤则是将本地的hexo放到github上托管，再重定向到你的个人域名以方便访问。 Github Pages注册Github如果不是程序员的话，可能会没有Github账号，这时就需要去Github官网去注册一个账号。注册成功后记得去你填的那个邮箱查收验证确认邮件。 新建一个仓库（new repository）注册登录成功后，去你的github主页点击”New repository”，取名为 “your_user_name.github.io”。 启用Github Pages 进入版本库后，点击右上方的setting，往下翻到Github Pages，点击Launch automatic page generator。 再然后来到New user site页面后点击右下角的Continue to layouts。 最后点击”Publish page”,发布github默认生成的一个静态站点。此时我们就可以通过在浏览器输入“your_user_name.github.io”来访问你的github站点主页。 将Hexo本地项目托管到GitHub Pages建立关联进入到你的本地hexo博客目录，有个_config.yml文件（全局配置文件），打开它，翻到最后面，将deploy改成如下所示： type: gitrepository: https://github.com/your_user_name/your_user_name.github.io.gitbranch: master 安装hexo-deployer-git插件在你的博客目录下输入如下命令： npm install hexo-deployer-git –save 将本地博客部署到GitHub Pages上依次执行下面三条命令： hexo cleanhexo generator 或 hexo ghexo deploy 或 hexo d 如果得到如下输出： INFO Deploy done: git 则说明部署成功。此时你可以通过在浏览器输入“your_user_name.github.io”来访问到你的hexo博客了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F03%2FHello%20World%2F</url>
    <content type="text"><![CDATA[写在开始 阮一峰老师说，喜欢写blog的人，会经历三个阶段。 （1）第一阶段，刚接触blog，觉得很新鲜，试着注册一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我就是这个样子。本来用的博客园，但总感觉不属于自己，再加上个人对博客园的界面颇有微词，一个偶然间看到了别人的hexo个人网站，觉得简洁的风格很好看也挺geek，于是瞬间倒戈。。 再然后Hexo是一个基于Node.JS的静态博客程序，生成的静态网页可以直接放到GitHub Pages上面（ps。顺便还能绿化一下GitHub的Contributions岂不是挺美滋滋？？ 然后我又想到自己之前买过腾讯家的服务器还送了域名，就准备将博客绑定下自己的域名，这样感觉就像是拥有了自己的小窝（虽然一系列的过程也是挺折腾的。。orz 到现在对着别人的“5分钟 就能搭建好免费个人博客”教程，折腾了好几个小时，中间还出现很意外的错误，终于是搞定下来了。。 当通过访问自己的域名看到博客加载下来之后，还是有些喜悦和成就感的。毕竟这也不是QQ空间、不是新浪微博、不是豆瓣小站。它更像是身为码农的我辛辛苦苦分到一块地，加以耕耘后不再需要在地主的土地上创造流量价值，感觉还是非常不错的。。 写在最后虽然感觉这个博客上也不会有什么人一起交流，但认为博客的价值还是在于记录，等你回头看你的博客时，能够让你你看到时光在你身上翻飞的样子。 总之，Hello World ～ 😘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>note</tag>
      </tags>
  </entry>
</search>
