<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Alfred的有道翻译发音失效的解决方法]]></title>
    <url>%2F2020%2F03%2F16%2F%E5%85%B3%E4%BA%8EAlfred%E7%9A%84%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E5%8F%91%E9%9F%B3%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[发音失效​ Alfred作为我在mac上使用频率最高的app，提供了极多很实用的功能，但最近在使用有道词典的Workflow时，翻译是正常的，但就是不能像之前那样使用Shift+Enter来发音。 原因​ 这对于持着科学严谨态度（强迫症）的我来说难以接受。于是经过一番折腾（中英文论坛瞎逛+瞎猜+瞎组合关键词）终于让我找到了原因： mac 升级到 Catalina 正式版之后の 某个系统更新中，say 命令可能会发生冲突 123&gt; say --voice='Fiona' helloOpen speech channel failed: -76 ​ 查看相关进程： 1&gt; ps ax | grep speechsynthesisd 解决方法​ 重置进程，重启Alfred。 1&gt; sudo pkill speechsynthesisd say ​ Done！]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
        <tag>alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[往事做序，来日为章]]></title>
    <url>%2F2020%2F01%2F25%2F%E5%BE%80%E4%BA%8B%E5%81%9A%E5%BA%8F%EF%BC%8C%E6%9D%A5%E6%97%A5%E4%B8%BA%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[For 2019 .a38b0462f26067be6ab4506a842af4178a52cbe4b601a16b50ab0bfaf0fd258c17f92aeaef4ffde5079c1750397eea1315eb7620f9ef0efeda7ad143acadbfb20f2530f581ae855baab5c5d86100c9b322ccf9cb96815bc18f45c5c3ab7c275ce3ac9a035ae6642c05f1b2747133b657a58f75d06db46b14be6770da394eaf7b0b5f8429b71b71fcedb9c6ed5ac86c7b9e594bbc5f40c129dd1489683ffff0a5e0a32a9042fea589fe6106fb43596a75120d67ba92b8b632fb26be4f31ab0800dc1f80f37b2fb4de7ca45ce775b5feffcd1b023b1ea938d167a3d23589509976f654a7e39e750f463848991b7bd4b50977e3e43ca10bab438b42b172198e82337cb9a372a2752f483cce9caafc70b4bad3f9e07131daf57a20020a4cf53d808bf65cab82ea8bfc57ddc362052c35b67c371ab5bf43bdf85ec4760cd0fd5b10d7a136e8e68b76b9c3caee11f55f9011f54c0f32f1c903b9cbe92406a496aff3256b6adfd96d0b420bdd9ed57b428df8e5367ce13de08f2954510622ca33da21c488b22686e8243da585cc771cca07cd6cdc5bd975588865f74e7d23eed7afdad2c55100785b26b3a9765477a581aa74d8644022fb8fa5d18d71cd6c68dcd2e069f520ad28661b4271108b4a11e6ca661ae61e7408850a640c8d3e9ce6eb86f668ab6d45f50a5a6d2d8399427861efb12895a3d271adcb57008a9c86c73bacce9c9137d0ef8bb3908526747c921576c6999c6caf473ed7a10d963c522f37cc315cc641cb0d6c4c130ebad3e411fbf2f5439a73e7ce7181d9f8568e66cb59e771fbf6f7bc2754b16db534c1d98f670ccb32558c7d1f8de7a4feba6e2a9418abeac9a1657a9e9a6c38effca7fac365818513e66fa2c86d27706fc0e782644c22f1e8a649e84911a8510e195728915aaedc21ca5ae495e98037ee2bc4ce5cf6e7f863b63d451ea58bbf4be96774abc4cad9c563eb5c2c8a09c6e8dc5f826a056152923d506ea73458ce781fc25f3a1a6f0feba447ab54c495664b7ad1693d8e7dc77e48e1fee040ec70f2d0519312381b2e83a2208677209c7fd9a0b73522fcf071dbd04869ac4f2df94c5c4e354cc102d1335097fc0f868710d659ba81b5f6ae136777ce1234b69d5cf073f91de824ae0e103ed7e96114d2abb3b242727c90a7747a382f443df2cedc501a71a7506f25a66fcdf4871cfc5b4a299fd36adea79ad87bc30e252fd4f96d2b89352a17a7c3d2067f06d53314f402b0771621112a46ef84d0ecba2867e019bf247bc3b98fe203af10bf8c53553b8b362d88f6210183814553c02b9e5318ae88e56d99d5307c82e7bb9e51d486754a5862bd63d7fa3a3621cdfa7ce3ca6d09e793a5869913d11eff4c6e25908c96b3c1614da69ab8d2edc4e12e80a09f5756e540ded100a957c42d9d1127e4cad4c466a174cd2b1ec02ca0f2e44b5460ebaec4971b7b29df7ac778575a2c1c6c595756f9badd0c97b4d0c7b48fe37423e1521bf3c4eb6fd805e7e2f2be53151a4bbcb2a1e22c0fac194426c6f63822962c0758e946728a76b539b64dc672584338745619987087d661073811edb3bb0e05bbdd43d8610cd0a6326bb2321f4d39d5e45934c7fcbf138714a93b5f27d2af69c38eee66fd636f66a4c9a77aadb572fd4e76632ea94c57dcbc716717f4a07e1bd444d157efcf9e0f463da4ef68058e533e91debc57c596d78405e44e6bdb6ea8339c605c65aa053d4c6bdc7a14dfbd8e3177f21b66eb8bbddda8b66484cd92415539035bee787985229b494860ebc2b4d223cf56bfc798e5a7f522448071e7999514b1075a92dd20836b5e9bd996ca4ed3d098570ecc7bada5598730b792cc98393c78e218b817ae042eccf56ed3aefa974697eceecd921d2f7047f6a16fa91b77e68cfcab35ec94a3688c7fd83ef7678d7cc5b5e5cc5cab9ae411be0d11b6bea0190fc10591d997e64dd45aea07defb4ad7dff7a7ddb27e750fddbfd9871e399ca96aa82c11aada16d72c63511c129c661546c1dea2f606c9e3e104a4ca9bb729316223a2a0bd85729ecbc6373cf8e7a071038a0c581290e0ccd2e4cdcbc8de3ec5b41038b25e92d5769040d2585eafb8fc3c5da04496095c01aa365a356d32833adecfcface6a3ae6a85d9dcdee8235f9aadacae62dd623953a31001773c5b7781773fd5c76ff873bce585bae673172bdfea1c27a63a31af3a96eb9af0ce75f9f96ce49c0d3bf8b2f1ae5275328c4d1fbd7e0b51a6decede47fbc1c60a88559358cb79133b34fb3f788b8efa3359e8649a9ec3a41f3263607efbfa4952ed8d64d1fce5c58a17557cc49ed5bfb8d83f57a0a6eefdb0f8d653ea34340e453e651fba3bdc3164775d43628ad57c87329079cae94a63e55f09be70cf805eb20573ffda8d079db57f78ef5314acd8ac35c12031497338aaa8d76c9a0f0ab661cb996fdfbb75cf1d0b2ab1970e224186cb49b745ac4a35f72647bea344d8b55d7c7dc7520886de4e6837ba9ee07f39ca7bb98ab4d64c9f359a123ea391f151b2d2e525ab5f7911a2f505cd4ca767dd4e7c80466822950f083ea3825094732f4e8205fa96fe7ae141ce33f8da167f66633dcbd55341086fab952ff76d36f8079b09970a90338646dcbd1a10ddf5365ba9c9f967e86a6431aab2f06537362fae1f4ad2c22296280b98c7f58c257df0d1c77df5304ed9f76e19b640428d490fb5bc702fa57d71ac444117fabb79158d59f899f980eaebee4195e255d530d721bfc823f871406a65b6bb59bf22ea3bbceb84d121a391927071edb0ee443e9feaa67751a6f079812d39bb7bd230e699af0179280ee7a5f48956835ecb7d9f93b475283cf61c419f46edbdb3fdd301990356f4aca61875b4957fa66916678459e1125e9ddb5f4eb22893bca2b5950ef07c0c57c293636c774d9545b456b64dc71ed960a94de83570d9771fd25b884e5d06b59d2c52f8b03a240f854ed0b6af2b4f85dff55629c3d3a290352ce151f44bfb1bd54d02a22820e8df698e4795a15cfd5a4ea355416178ab4c3d84bcc72c487a15ab76fc0ced8cddc845a6720e62680b0fb78d9f11d7b1a4538b33010c3c40b17978aa1eb752c1b0597d2dc325e9df5fec2b6e224df5a56205076fa6060793767b0dc1da30bf8ce9024f8c308fa6933809ed3afbde494743d34a74eb88dc52fdbdf3ba80ed872aee373cc3a162b63b55546f4774c59a1e82bbb44a666a421580c35ea79ba8c9dd2b78028e044ab27583526f4ad8dc6d9957b4cc49ff3c6d1d5c56de1884106189edc646a23ffb4af3f3aa9250ee77bef3f0103e984d877260ac4ae2414ff20fabe416e053316c1b10bc81d4133480178cffb5e68d4d7a20893fdc2b69a01ff1192de2f31a1b0e77170811543fa91297fb8c7ebae4d5f660c87233347459e2ab252e94ce9fb076e583c47f31e4fb87e4de98af7cdc5bf533e14c75102a1656d5da83db6006771a29330303d593a8be6518b6174cd8283a53c7bcb14de2e77079fda28537d457ef4129f2e644a7804d24a52929199352da939e9d58e3adaa3ad10077797b5e1ee0a3fe7eb875544ac1c9990b19f69c69d16aafff91cd512fd1cf74bb9217ff8b4718756454e951e83fce560a8cae04b922a462861b3c582348dd7d55a4d7b24f880a83d34bec8f643a0bfa26ca113fc01138ad0698d22bb2e5704395e764321bda86d40b52a3a392431eed31eb1a37c16d7bf1fceda6b0e80803764d24d337c90061f6ee73e9bc84767ed52d96499d7f0e016a58327a65b0b1a0fea6866135060a96768efe7eac301a6347f295e53d2458a0c9603db45c979ce50acc391904e66fcd3cb1ed82892fa5311e1e7c87b3327f8fe9ecd08ba66deb16929b7aeb0ae78ef291fe338bfedcf4e3f9372d31a862a084112f33eca1911c24aa5b2e145ee9330f18c2fbb8789b6c49a5afcd2868314528097750b9d623b769514d21dd85ddebe453c64376c103a3b474fba870b37f39c51ea809806ffa366cd4386a98a663d36ac51c65f17ea1f92fdc697b54bfd9256bd0080cc1a070fedf6af6ddf0756d22d8713cdea0ae4b6f653de5f926006fd20674e667fb10bf5e1d67645f1695e640d8b32d4d5e99ec310b6bc4c18fe702d8327556416817a044ae4c4c45e311cbae20242ba93e23ba6f76692a43beb5ce475ad8252e9b9271ce51f8dbb45ca130e168af175701903ce54cf8a978a063ba119939e86c73ea424ec129aa82bf649fe74d857c9a0c849ed315b09a5f9dff9683269ff6217cdc73e537ed0f85b47b6300f02a5cb1f026436becceee1faf08fba75270e8fdee81abfd01a99856b37dff484c036ee4f06ef6f49c9bb5d263691420873554f103e8b6f86feca63bc3484eec7d7679712595f31e73f930d66e60227a46ac08c03dfd7e2d83505d13006428a8b569dd58828278edd67985feec2b1d13c38be67b934f1bfa434f9ff598f00cf592a72064c018bc57a3200241a0e48fce71715cf44c1246048f19e25f4b7476537f146c0827dff99c23b46abf024364a59a9790a5b840ab0688ddc8d46c9dcffe07dea35e79c111899645c845ed8669e93cf82b61580b9e3ced9e8653d62febf66fa10fc43b94523a75c7cb7cc6af33a33ed246a91189e65f7ff086f689f6280f7e76e1b71fd1cd25e2be1cb4bcce557387f5905e2d9ef568d1fd7c6a3a084e4d8945efb43707f57ffa08e1f19377db63b0b79e63b429f90f5429e764ec2fecce7f3506e0d5e8085a4bc7a54af2e7dfbdfc231e3b76dc6d5c3af911f63aaf52d7143e012d780cf241b420e67dc2347289fc2bc3630de6741d70f2496d1fe2fa942fc513772bf055771319eadde50573dd11afa301a992865be51c0579e7650716f15f3c664f29b71c64d89d4c4d6693eb07da5173eb9bfcad776199fdc95aa98d0d314c3266b59c6ba8f6167df75a6b585222c6685f746ce0b636ff1dd0b6d1be7d525aff189e39caaac4e05c2c0cebe293a883fb75c648393944c423a4bf73d270a6eb94627f481198c443e635cda2151e477567fb2899031a8a010bc8fc0fb8ca53f20454f900bff060dd04eb63b9674c20d6307c02bf8043f21fab90d930de80e286f29fba75f8cb1e87b0ec6f37cf08bc902fed14d9c7d19d04bb8ae6d3f298c6694f9aeac5a560b506719a0fcc64e9a07c0feb71535bb29d50632164c446ec6566479025662ded761a0371737d94a6ccfd58582ee9ac63b097156872c31bc7810505ae205f8716b8a62a3aa2dbfc3deb13720a75a1d2763690faf6ee29ddaca96f2a612ce7c48a41a46f427af6ee835122ffcbf8105987a7f7ed39f924f340e7bdfad8a7775116db5997fff14448727d9845a1a0dd230178f14de962b274e4387dffca0acc44451724de9f881bd2ff56e7617a3da746ef877be4d4ccb4adbef8dd172937276fcdaca005acdde1d71fc4f65032427d04a877cb34e8886b2c00231b1501ab6eea9a1560379033e993e2340c15755fda43e3355f19431208756e63e443807b2222477b83d43b3d78fe3b311a801d3608465e8236af7d4947a581c6941ba9f637b4b46aacde45b2e1beba00155a15b5959f047483daf4901f17cf41109b6f3a4d9852303aab3799ac8373fb388c91733845f75ab758bd3fc66222607e907e8de42a8c738f1bf5fc85c00597241234c421b5f8eb6cfe40afa80864ab0f517cf9d227b0131887ed66fa7297bbe43b17a7589d0fed97c0763123ab456948e68d90cd04ace640ac4056f534df8877e3849a749d23b2ea9dabf35dfe149a7b30a502186e3d89872ea49376bc4cd6c0da41458f50f72b2b0ad44ceb84fa5bbc90ef6dc92b6b12b106e193f3559346eb64d312608955520d3fb2a5bc20f8ba6f339a1736e6c36688d47c2b7f5a35f4857e8d408d33ada629493538ed50c37c9b7ff6e8223ea80669c56573ac750d20732019e2782b6fcd8c8d9bb66eb2ea5ae335de8b9977248cf5f922c12beb1559b915309e4d267d8f05864cf465d796ada0d87b7698f6d0661aaf40cc763e5bc4102f5ae727d247b3050b6a46077cc1fd157749660fb4f009a5d5ade4bd6b8e95761be42207fcf2a22f3d65aa926b90b255a2c188a49aa1eb8b025d99bbb103a21d90d2df7c9ccfbf6e3cbe435e11d6e9f8275fb5dd1976981a56fe79d9a050e577a8f666dcf074f0287c909179e88e5bc42f5344323070b2ea468c4820661208e4baf52681ef9a1ec6997f18ab7e734053288deaf2ffa36198a946e5bd5d46bc76f2e28c0c6950c59d8289449407f518fc2a24ae5456c4746388764d8cca07a686c265fc8e786b0c8e37f442781485d3aeacf881c367cda337ecce3324fd2855cf18ddac6747429799ec87fd9047e3f117961ed596d6e78d6822236384e388f6657fd7e5aa7a32226ca973829e530f729219462d4ab4a3caf2f620b07187e85534dc10a7a0a3c7e1ff6291f268d211abb8d05840265e1d8e6f45ba09c1a49474c5ebbf4df04d4503ad6ad8096b6a264dc766230e694bff93d02eb17a9b73a2]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack基本配置]]></title>
    <url>%2F2019%2F07%2F20%2FWebpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拆分配置和merge​ webpack两个最基本的功能: 1. 开发的代码运行一下看看是否有效 ; 2. 开发完毕了将代码打包出来。这两个操作的需求、配置都是完全不一样的。例如，运行代码时不需要压缩以便 debug ，而打包代码时就需要压缩以减少文件体积。所以可以把webpack配置拆分成下面三个文件来方便管理并且也能避免重复的配置内容： 1231. webpack.common.js // 公共配置（开发环境和生产环境都需要用到的配置）2. webpack.dev.js // 开发环境配置3. webpack.prod.js // 生产环境配置 然后在开发和生产环境中通过smart方法来引入公共配置： 123456789101112const &#123; smart &#125; = require('webpack-merge')// smart 方法也就是之前的 merge 方法module.exports = smart(webpackCommonConf, &#123; mode: 'development', module: &#123; &#125;, plugins: [ ], devServer: &#123; &#125;&#125;) 启动本地服务（开发环境配置）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// webpack.dev.jsconst path = require('path')const webpack = require('webpack')const webpackCommonConf = require('./webpack.common.js')const &#123; smart &#125; = require('webpack-merge')const &#123; srcPath, distPath &#125; = require('./paths')module.exports = smart(webpackCommonConf, &#123; mode: 'development', module: &#123; rules: [ // 直接引入图片 url &#123; test: /\.(png|jpg|jpeg|gif)$/, use: 'file-loader' &#125; ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; // window.ENV = 'development' ENV: JSON.stringify('development') &#125;) ], devServer: &#123; // 🌟🌟🌟 相关配置项 port: 8080, progress: true, // 显示打包的进度条 contentBase: distPath, // 根目录（启动服务是基于哪个目录来访问文件 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 // 🌟🌟🌟 设置代理（在webpack下怎么去跨域请求其他的一些接口 proxy: &#123; // 将本地 /api/xxx 代理到 localhost:3000/api/xxx '/api': 'http://localhost:3000', // 将本地 /api2/xxx 代理到 localhost:3000/xxx '/api2': &#123; target: 'http://localhost:3000', pathRewrite: &#123; '/api2': '' &#125; &#125; &#125; &#125;&#125;) 处理ES6（公共配置）12345678910111213141516171819202122232425262728293031323334353637383940// webpack.common.jsconst path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const &#123; srcPath, distPath &#125; = require('./paths')module.exports = &#123; entry: path.join(srcPath, 'index'), module: &#123; rules: [ &#123; test: /\.js$/, // es6 loader: ['babel-loader'], include: srcPath, exclude: /node_modules/ &#125;, &#123; test: /\.vue$/, loader: ['vue-loader'], include: srcPath &#125;, &#123; test: /\.css$/, // loader 的执行顺序是：从后往前（知识点） loader: ['style-loader', 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\.less$/, // 增加 'less-loader' ，注意顺序 loader: ['style-loader', 'css-loader', 'less-loader'] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(srcPath, 'index.html'), filename: 'index.html' &#125;) ]&#125; 配置babelrc12345// .babelrc&#123; "presets": ["@babel/preset-env"], // 这里面就包含了es6、es7、es8常用的一些语法 "plugins": []&#125; 配置postcss1234// postcss.config.jsmodule.exports = &#123; plugins: [require('autoprefixer')] // 用于加一些浏览器兼容的前缀，比如 -webkit-&#125; 处理图片（开发环境和生产环境都需要配置）开发环境下处理图片只需要用一个file-loader即可，而在生产环境下需要分情况： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// webpack.prod.jsconst path = require('path')const webpack = require('webpack')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')const webpackCommonConf = require('./webpack.common.js')const &#123; smart &#125; = require('webpack-merge')const &#123; srcPath, distPath &#125; = require('./paths')module.exports = smart(webpackCommonConf, &#123; mode: 'production', output: &#123; filename: 'bundle.[contentHash:8].js', // 🌟🌟🌟 打包代码时，加上 hash 戳，8代表8位 path: distPath, // publicPath: 'http://cdn.abc.com' // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到 &#125;, module: &#123; rules: [ // 图片 - 考虑 base64 编码的情况 &#123; test: /\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; // 🌟🌟🌟 小于 5kb 的图片用 base64 格式产出，这样可以少一次http请求 // 否则，依然延用 file-loader 的形式，产出 url 格式 limit: 5 * 1024, // 打包到 img 目录下 outputPath: '/img1/', // 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源） // publicPath: 'http://cdn.abc.com' &#125; &#125; &#125;, ] &#125;, plugins: [ new CleanWebpackPlugin(), // 🌟🌟🌟 会默认清空 output.path 文件夹 new webpack.DefinePlugin(&#123; // window.ENV = 'production' ENV: JSON.stringify('production') &#125;) ]&#125;) 多入口entry 入口配置（公共配置）1234567// 基础配置entry: path.join(srcPath, 'index'),// 多入口配置entry: &#123; index: path.join(srcPath, 'index.js'), other: path.join(srcPath, 'other.js') &#125;, output 输出配置（生产环境配置）12345678910// 基础配置output: &#123; filename: 'bundle.[contentHash:8].js', // 打包代码时，加上 hash 戳 path: distPath, &#125;,// 多入口配置output: &#123; filename: '[name].[contentHash:8].js', // name 即多入口时 entry 的 key （index、other） path: distPath, &#125;, html 文件配置（公共配置）123456789101112131415161718192021222324// 基础配置plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(srcPath, 'index.html'), filename: 'index.html' &#125;) ]// 多入口配置：针对每一个入口都要建一个HtmlWebpackPlugin配置项plugins: [ // 多入口 - 生成 index.html new HtmlWebpackPlugin(&#123; template: path.join(srcPath, 'index.html'), filename: 'index.html', // chunks 表示该页面要引用哪些chunk(js文件内容，即上面的index和other)，默认全部引用 chunks: ['index'] // 只引用 index.js &#125;), // 多入口 - 生成 other.html new HtmlWebpackPlugin(&#123; template: path.join(srcPath, 'other.html'), filename: 'other.html', // chunks 表示该页面要引用哪些chunk(js文件内容，即上面的index和other)，默认全部引用 chunks: ['other'] // 只引用 other.js &#125;) ] 处理样式、抽离 CSS 文件（开发环境和生产环境都需要配置）​ 之前那样将样式处理统一放在公共配置中，所有的样式都是打包写进了js文件里然后塞到html中的style标签中的，这样的话效率比较低。 ​ 开发环境下处理样式依然沿用之前公共配置里的处理样式的做法：采用style-loader。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// webpack.prod.jsconst path = require('path')const webpack = require('webpack')const &#123; smart &#125; = require('webpack-merge')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const TerserJSPlugin = require('terser-webpack-plugin')const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin')const webpackCommonConf = require('./webpack.common.js')const &#123; srcPath, distPath &#125; = require('./paths')module.exports = smart(webpackCommonConf, &#123; mode: 'production', output: &#123; // filename: 'bundle.[contentHash:8].js', // 打包代码时，加上 hash 戳 filename: '[name].[contentHash:8].js', // name 即多入口时 entry 的 key path: distPath, // publicPath: 'http://cdn.abc.com' // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到 &#125;, module: &#123; rules: [ &#123; test: /\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 5 * 1024, outputPath: '/img1/', &#125; &#125; &#125;, // 抽离 css &#123; test: /\.css$/, loader: [ // 🌟🌟🌟 注意，这里不再用style-loader 改用 MiniCssExtractPlugin.loader MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' ] &#125;, // 抽离 less --&gt; css &#123; test: /\.less$/, loader: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader' ] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), // 会默认清空 output.path 文件夹 new webpack.DefinePlugin(&#123; ENV: JSON.stringify('production') &#125;), // 🌟🌟🌟 抽离 css 文件 new MiniCssExtractPlugin(&#123; filename: 'css/main.[contentHash:8].css' &#125;) ], optimization: &#123; // 🌟🌟🌟 压缩 css minimizer: [new TerserJSPlugin(&#123;&#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)], &#125;&#125;)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>webpack</tag>
        <tag>打包</tag>
        <tag>工具</tag>
        <tag>babel</tag>
        <tag>smart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack性能优化]]></title>
    <url>%2F2019%2F07%2F20%2FWebpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化打包构建速度 - 开发体验和效率优化babel-loader 开启缓存（只用于开发环境即可） 明确范围 / 排除范围 （生产环境） 123456789// webpack.dev.jsrules: [ &#123; test: /\.js$/, loader: ['babel-loader?cacheDirectory'], // 开启缓存 include: srcPath, // 明确范围 // exclude: /node_modules/ // 排除范围，include 和 exclude 二选一即可 &#125;, ] IgnorePlugin 这是webpack内置插件 这个插件的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去 要用于生产环境 123456import moment from 'moment'//设置语言moment.locale('zh-cn');let r = moment().endOf('day').fromNow();console.log(r); ​ 比如我们要使用moment这个第三方依赖库，该库主要是对时间进行格式化，并且支持多个国家语言。这样打印出来的就是中文的时间，因为我在使用这个API的时候，前面设置了语言类型moment.locale为中文zh-cn。但是，虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢，所以，最好能够少打包一些没用的依赖目录进去，而moment的包含&#39;./locale/&#39;该字段路径的文件目录就是各国语言的目录，比如&#39;./locale/zh-cn&#39;就是中文语言。 12345let Webpack = require('webpack');plugins:[ // moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去 new Webpack.IgnorePlugin(/\.\/locale/,/moment/),] ​ 但这样问题又来了，我们虽然按照上面的方法忽略了包含’./locale/‘该字段路径的文件目录,但是也使得我们使用的时候不能显示中文语言了，所以这个时候需要手动引入中文语言的目录： 12345678import moment from 'moment'//手动引入所需要的语言包import 'moment/locale/zh-cn';//设置语言moment.locale('zh-cn');let r = moment().endOf('day').fromNow();console.log(r); ​ 这样就OK了。既能够显示中文，又把不必要的语言包都忽略打包了。 noParse​ noParse作用主要是过滤不需要解析的文件，比如打包的时候依赖了三方库（jQuery、lodash）等，而这些三方库里面没有其他依赖，可以通过配置noParse不去解析文件，提高打包效率。 1234567891011121314151617// webpack.dev.jsmodule.exports = &#123; mode:'development', entry:'./src/index.js', output:&#123; ... &#125;, module:&#123; noParse:/jquery/, // 🌟🌟🌟 不去解析jquery中的依赖库 rules:[ ... ] &#125;, plugins:[ ... ]&#125; happyPack - 多进程打包 JS是单线程，开启多进程打包更快 提高构建速度（特别是针对多核CPU） 可以单独在生产环境中配置，也可以放在公共配置中。 1234567891011121314151617181920212223// webpack.prod.js or webpack.common.jsconst HappyPack = require('happypack')rules: [ // js &#123; test: /\.js$/, // 🌟🌟🌟 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例（对应下面） use: ['happypack/loader?id=babel'], include: srcPath, // exclude: /node_modules/ &#125;, ]plugins: [ // happyPack 开启多进程打包 new HappyPack(&#123; // 🌟🌟🌟 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // 如何处理 .js 文件，用法和 Loader 配置中一样 loaders: ['babel-loader?cacheDirectory'] &#125;), ], parallelUglifyPlugin - 多进程压缩JS webpack 内置 Uglify 工具压缩JS 但它是单线程的，开启多进程压缩更快 要用于生产环境下 1234567891011121314151617181920212223const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')plugins: [ // 🌟🌟🌟 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程） uglifyJS: &#123; output: &#123; beautify: false, // 最紧凑的输出 comments: false, // 删除所有的注释 &#125;, compress: &#123; // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量：var c = a + b =&gt; var c = 30 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125; &#125;) ], 关于开启多线程的按需使用： 项目较大，打包较慢，开启多进程能提高速度 项目较小，打包很快，开启多进程会降低速度（进程开销） 自动刷新devServer默认开启浏览器的自动刷新，所以这里其实并不需要配置。 123456789101112// webpack.dev.jsmodule.exports = smart(webpackCommonConf, &#123; watch: true, // 开启监听，默认为 false // 注意： 开启监听之后，webpack-dev-server 会自动开启刷新浏览器 watchOptions: &#123; // 监听配置 ignored: /node_modules/, // 忽略哪些 // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 aggregateTimeout: 300, // 默认为 300ms // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的 poll: 1000 // 默认每隔1000毫秒询问一次 &#125;&#125;) 热更新 自动刷新：整个网页全部刷新，速度较慢，状态会丢失 热更新：新代码生效，网也不刷新，状态不丢失 热更新虽好，但是会消耗一定的性能，所以也要按需使用（网页比较大，刷新一次比较费力、经常要进入深层路由、表单输入框不重置） 开启热更新的代码一定要在生产环境前删除掉 12345678910111213141516171819202122// webpack.dev.jsconst HotModuleReplacementPlugin = require('webpack/lib/HotModuleReplacementPlugin');module.exports = smart(webpackCommonConf, &#123; entry: &#123; // index: path.join(srcPath, 'index.js'), // 🌟🌟🌟 热更新 index: [ 'webpack-dev-server/client?http://localhost:8080/', 'webpack/hot/dev-server', path.join(srcPath, 'index.js') ], other: path.join(srcPath, 'other.js') &#125;, plugins: [ new HotModuleReplacementPlugin() ], devServer: &#123; // 开启热更新 hot: true, &#125;,&#125;) 并且在代码中增加开启热更新之后的代码逻辑： 1234567// index.jsif (module.hot) &#123; module.hot.accept(['./math'], () =&gt; &#123; // accept后面接收的参数是指允许哪些模块进行热更新的监听 const sumRes = sum(10, 30) console.log('sumRes in hot', sumRes) &#125;)&#125; DllPlugin - 动态链接库插件​ 前端框架如vue、react ，体积大，构建慢。但它们都较稳定，不常升级版本，同一个版本只构建一次即可，不用每次都重新构建。 webpack 已内置 DllPlugin 支持 DllPlugin - 打包出 dll 文件 DllReferencePlugin - 使用 dll 文件 dll 只能满足于开发环境下打包带来的速度和体验优化，不能用于生产环境 具体做法： 新建一个webpack.dll.js： 12345678910111213141516171819202122232425262728293031323334// webpack.dll.jsconst path = require('path')const DllPlugin = require('webpack/lib/DllPlugin')const &#123; srcPath, distPath &#125; = require('./paths')module.exports = &#123; mode: 'development', // JS 执行入口文件 entry: &#123; // 把 React 相关模块的放到一个单独的动态链接库 react: ['react', 'react-dom'] &#125;, output: &#123; // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称， // 也就是 entry 中配置的 react 和 polyfill filename: '[name].dll.js', // 输出的文件都放到 dist 目录下 path: distPath, // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react // 之所以在前面加上 _dll_ 是为了防止全局变量冲突 library: '_dll_[name]', &#125;, plugins: [ // 接入 DllPlugin new DllPlugin(&#123; // 动态链接库的全局变量名称，需要和 output.library 中保持一致 // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 // 例如 react.manifest.json 中就有 "name": "_dll_react" name: '_dll_[name]', // 描述动态链接库的 manifest.json 文件输出时的文件名称 path: path.join(distPath, '[name].manifest.json'), &#125;), ],&#125; npm run dll 打包出 dll 文件 以及 manifest 文件 123456// pakage.json"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --config build/webpack.dev.js", "dll": "webpack --config build/webpack.dll.js" &#125;, 在 webpack.dev.js 中通过 DllReferencePlugin 使用dll 文件以及 manifest 文件 12345678910111213141516171819202122232425262728293031323334353637// webpack.dev.jsconst path = require('path')const webpack = require('webpack')const &#123; smart &#125; = require('webpack-merge')const webpackCommonConf = require('./webpack.common.js')const &#123; srcPath, distPath &#125; = require('./paths')// 🌟 第一，引入 DllReferencePluginconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');module.exports = smart(webpackCommonConf, &#123; mode: 'development', module: &#123; rules: [ &#123; test: /\.js$/, loader: ['babel-loader'], include: srcPath, exclude: /node_modules/ // 🌟 第二，不要再转换 node_modules 的代码 &#125;, ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; // window.ENV = 'production' ENV: JSON.stringify('development') &#125;), // 🌟 第三，告诉 Webpack 使用了哪些动态链接库 new DllReferencePlugin(&#123; // 描述 react 动态链接库的文件内容 manifest: require(path.join(distPath, 'react.manifest.json')), &#125;), ], devServer: &#123; ... &#125;&#125;) 优化产出代码 - 产品性能 体积更小 合理分包，不重复加载 速度更快，内存使用更小 小图片采用 base64 格式进行产出 小于一定大小的图片（可以是5kb、3kb）直接用 base64 格式产出，这样可以少一次http请求 123456789101112131415161718// webpack.prod.js&#123; test: /\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; // 小于 5kb 的图片用 base64 格式产出 // 否则，依然延用 file-loader 的形式，产出 url 格式 limit: 5 * 1024, // 打包到 img 目录下 outputPath: '/img1/', // 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源） // publicPath: 'http://cdn.abc.com' &#125; &#125;&#125;, 懒加载webpack默认支持懒加载：import() 12345678910// 同步加载import &#123; sum &#125; from './math'// 引用动态数据 - 懒加载// 这里打包的时候也会产出一个 chunksetTimeout(() =&gt; &#123; import('./dynamic-data.js').then(res =&gt; &#123; console.log(res.default.message) // 注意这里的default &#125;)&#125;, 1500) Vue里面的路由懒加载路由懒加载 babel-plugin-syntax-dynamic-import bundle 加 hash 代码如果变了，根据 content 计算出来的 hash 值就会变，那么就会缓存失效，从而重新请求新的文件； 代码如果没有变，contentHsh 值都是一样的，那么上线请求的时候，前端的代码就会命中缓存，加载就会更快。 123456output: &#123; // filename: 'bundle.[contentHash:8].js', // 打包代码时，加上 hash 戳 filename: '[name].[contentHash:8].js', // name 即多入口时 entry 的 key path: distPath, // publicPath: 'http://cdn.abc.com' // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到&#125;, module chunk bundle 的区别 module - 各个源码文件，webpack 中一切皆模块 chunk - 多模块合并而成的，如 entry 、 import() 、splitChunk bundle - 最终的输出文件 抽离公共代码、抽离第三方模块（生产环境配置） 一些公共代码，会在多个文件中被引用，打包的时候就会显得有些资源浪费，因为在多个文件中都要重复打包一下这些公共代码，类似于复制粘贴的方式。所以要把公共的部分单独抽离出来然后去相互引用，这样可以减少加载和执行的次数； 第三方模块比如lodash，在一个文件中a.js被引用的时候，只要修改一点a.js中的内容，打包a.js的时候lodash也会被重新打包，但是lodash本身并没有什么改动，所以这些第三方模块也要分离出来。 1234567891011121314151617181920212223242526272829303132333435// webpack.prod.jsoptimization: &#123; // 压缩 css minimizer: [new TerserJSPlugin(&#123;&#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)], // 🌟🌟🌟 分割代码块 splitChunks: &#123; /** * initial 入口 chunk，对于异步导入的文件不处理 async 异步 chunk，只对异步导入的文件处理 all 全部 chunk，一般这里都用 all */ chunks: 'all', // 🌟🌟🌟 缓存分组 cacheGroups: &#123; // 第三方模块 vendor: &#123; name: 'vendor', // chunk 名称 priority: 1, // 权限更高，优先抽离，重要！！！ test: /node_modules/, // 通过 test 来测试能不能命中第三方模块 minSize: 0, // 大小限制，一般用5kb minChunks: 1 // 第三方模块最少复用过 1 次就抽离出来 &#125;, // 公共的模块 common: &#123; name: 'common', // chunk 名称 priority: 0, // 优先级 minSize: 0, // 公共模块的大小限制 minChunks: 2 // 公共模块最少复用过 2 次就抽离出来，只引用过 1 次就不用 &#125; &#125; &#125; &#125; IngorePlugin同上。举一个 moment.js 例子。可以从 260kb 一下子 缩减到 50kb 。 使用 CDN 加速 在outPut里配置修改所有静态资源的url前缀（如CDN域名） 将这些静态资源（css文件、js文件、图片等）上传到公司购买的CDN服务中去 使用 production1234module.exports = smart(webpackCommonConf, &#123; mode: 'production', ...&#125; 使用 mode: &#39;production&#39;, 会自动开启代码压缩 Vue、React 等框架会在打包时自动删掉调试代码（如开发环境的 warning ） 启动 Tree-Shaking ，删除一些无用代码（ES6 Module才能让tree-shaking生效，而Commonjs就不行） ES6 Module 和 Commonjs 的区别 ES6 Module 静态引入，编译时引入 Commonjs 动态引入，执行时引入 只有 ES6 Module 才能静态分析，实现 Tree-Shaking 12345678910111213// ES6 Moduleimport apiList from '../config/api.js'if(isDev) &#123; // 编译时报错，只能像上面那样静态引入 import apiList from '../config/api_dev.js'&#125;// Commonjslet apiList = require('../config/api.js')if (isDev) &#123; // 可以动态引入，执行时引入 apiList = require('../config/api_dev.js')&#125; Scope Hosting 将多个相关联文件产生的函数合并成一个函数，使得代码体积更小 创建函数作用域更少，避免很多的跨作用域调用 线上代码可读性更好 ​ 多个js文件在互相调用时，打包出来的代码可能就会生成多个函数，这样就会产生很多函数作用域，这样对于整个js代码的执行以及内存的消耗都是很不友好的。所以我们就需要开启Scope Hosting： 12345678910111213// webpack.prod.jsconst ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');module.exports = &#123; resolve: &#123; // 针对 NPM 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件 mainFields: ['jsnext:main', 'browser', 'main'] &#125;, plugins: [ // 开启 Scope Hosting new ModuleConcatenationPlugin(), ]&#125;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>webpack</tag>
        <tag>打包</tag>
        <tag>工具</tag>
        <tag>优化</tag>
        <tag>chunk</tag>
        <tag>module</tag>
        <tag>bundle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Daliy FE Coding Tips]]></title>
    <url>%2F2019%2F06%2F06%2FDaliy%20FE%20Coding%20Tips%2F</url>
    <content type="text"><![CDATA[Vue的异步组件​ 在项目中有时候会有一些比较大的组件，类似于代码编辑器、echart图标渲染之类的组件，如果一次性全部直接同步打包的话，体积就会非常大，严重影响性能。 import()函数 按需加载，异步加载组件 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;p&gt;vue 高级特性&lt;/p&gt; &lt;hr&gt; &lt;!-- nextTick --&gt; &lt;NextTick/&gt; &lt;!-- 异步组件 --&gt; &lt;FormDemo v-if="showFormDemo"/&gt; &lt;button @click="showFormDemo = !showFormDemo"&gt;show form demo&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import NextTick from './NextTick'export default &#123; components: &#123; NextTick, // 异步加载：只有在需要渲染这个组件的时候才会加载 FormDemo: () =&gt; import('../BaseUse/FormDemo'), &#125;, data() &#123; return &#123; NextTickName: "NextTick", showFormDemo: false &#125; &#125;&#125;&lt;/script&gt; mixin 多个组件有相同的逻辑，抽离出来 mixin并不是完美的解决方案，会有一些问题 Vue 3提出的Composition API旨在解决这些问题 1234567891011121314151617181920212223242526&lt;!-- MixinDemo.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;name&#125;&#125; &#123;&#123;job&#125;&#125; &#123;&#123;city&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;showName&quot;&gt;显示姓名&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import myMixin from &#39;.&#x2F;mixin&#39;export default &#123; mixins: [myMixin], &#x2F;&#x2F; 可以添加多个，会自动合并起来 data() &#123; return &#123; name: &#39;tom&#39;, job: &#39;web&#39; &#125; &#125;, methods: &#123; &#125;, mounted() &#123; console.log(&#39;component mounted&#39;, this.name) &#125;&#125;&lt;&#x2F;script&gt; 12345678910111213141516// mixin.jsexport default &#123; data() &#123; return &#123; city: 'hangzhou' &#125; &#125;, methods: &#123; showName() &#123; console.log(this.name) &#125; &#125;, mounted() &#123; console.log('mixin mounted', this.name) &#125;&#125; ​ mixin的问题 变量来源不明确，不利于阅读 多 mixin 可能会造成命名冲突 mixin和组件可能出现多对多的关系，复杂度较高 this.$notify()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import operateFeedback from './operateFeedback.vue'const Plugin = &#123; install (Vue, options = &#123;&#125;) &#123; /** * Makes sure that plugin can be installed only once */ if (this.installed) return this.installed = true /** * Plugin API * tips: 提示文案 * existTime: 提示存在的时间 * ifSuccessed: 是否是操作成功的反馈 失败传0 成功传1或者不传 */ Vue.prototype.$notify = (tips = '操作成功', existTime = 1500, ifSuccessed = 1) =&gt; &#123; let feedback = Vue.extend(operateFeedback) let a = new feedback(&#123; data: &#123; tips, ifSuccessed &#125; &#125;) let domNotify = document.getElementById("ddr-notify"); let ele = document.createElement("div"); ele.setAttribute("id", "ddr-notify-child") domNotify.appendChild(ele) // ele2.setAttribute("id", "ddr-notify-child") // ele.setAttribute("class", "ddr-notify-child-2") setTimeout(() =&gt; &#123; a.$mount('#ddr-notify-child') &#125;, 300) setTimeout(() =&gt; &#123; let domNotifyChild = a.$el domNotifyChild.parentNode.removeChild(domNotifyChild); // let domNotify = document.getElementById("ddr-notify"); // console.log('domNotify:', domNotify) // console.log('a:', a) // a.$destroy() // console.log('a:', a) // domNotify.remove() &#125;, existTime) // let component = new feedback().$mount(); // let $dom = component.$el; // let root = document.getElementById("ddr") // root.appendChild($dom); &#125; &#125;&#125;export default Plugin 调用子组件的方法（vm.$refs.xx.xx()）12345678beforeRouteEnter(to, from, next) &#123; next(vm =&gt; &#123; if(from.name === 'noteUpload' &amp;&amp; vm.$route.query.from === 'upload') &#123; vm.$refs.topicListChild.reInitNoteList() vm.slideToNoteList() &#125; &#125;)&#125;, iPhone低版本输入框问题12345// 在输入框上绑定一个 @blur="inputBlur"// 防止输入框把页面顶上去 导致点击区域失效inputBlur () &#123; window.scrollTo(0, 2000)&#125;, 让文字在一个方框内水平垂直居中由于文字长度是不确定的，所以无法指定一个固定的宽高 fit-content 兼容性有问题，在ios10以上才能用，所以弃用。改为： 1234567891011text-align: center;line-height: 16px;position: absolute;top: 0;bottom: 0;left: 0;right: 0;display: flex;align-items: center;justify-content: center;padding: 0 14px 8px; 也就是说 flex和absolute结合起来也是可以实现居中的。 html占位符1234567&amp;#32; == 普通的英文半角空格&amp;#160; == &amp;nbsp; == &amp;#xA0; == no-break space （普通的英文半角空格但不换行）&amp;#12288; == 中文全角空格 （一个中文宽度）&amp;#8194; == &amp;ensp; == en空格 （半个中文宽度）&amp;#8195; == &amp;emsp; == em空格 （一个中文宽度）&amp;#8197; == 四分之一em空格 （四分之一中文宽度）相比平时的空格（&amp;#32;），nbsp拥有不间断（non-breaking）特性。即连续的nbsp会在同一行内显示。即使有100个连续的nbsp，浏览器也不会把它们拆成两行。 html2canvas &amp;&amp; canvas2image移动端保存带有个性化信息和样式的图片的方法，参考于基于html2canvas实现网页保存为图片及图片清晰度优化 正常用一个div来写样式 再写一个div作浅黑色蒙板 最上面的才是真正的图片，可以用appendChild将生成的img添加上去并为其写上样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import html2canvas from 'html2canvas'import Canvas2Image from '@/util/canvas2image'// html2canvas 生成图片的方法generateCanvas() &#123; this.$nextTick(() =&gt; &#123; let cntElem = this.$refs.hideBox; let shareContent = cntElem;//需要截图的包裹的（原生的）DOM 对象 let width = shareContent.offsetWidth; //获取dom 宽度 let height = shareContent.offsetHeight; //获取dom 高度 let canvas = document.createElement("canvas"); //创建一个canvas节点 let scale = 3; //定义任意放大倍数 支持小数 canvas.width = width * scale; //定义canvas 宽度 * 缩放 canvas.height = height * scale; //定义canvas高度 *缩放 canvas.getContext("2d").scale(scale, scale); //获取context,设置scale let opts = &#123; scale: scale, // 添加的scale 参数 canvas: canvas, //自定义 canvas // logging: true, //日志开关，便于查看html2canvas的内部执行流程 width: width, //dom 原始宽度 height: height, //dom 原始高度 // useCORS: true, // 【重要】开启跨域配置 &#125;; html2canvas(this.$refs.hideBox, opts).then((canvas) =&gt; &#123; let context = canvas.getContext('2d') // 【重要】关闭抗锯齿 context.mozImageSmoothingEnabled = false context.webkitImageSmoothingEnabled = false context.msImageSmoothingEnabled = false context.imageSmoothingEnabled = false // 【重要】默认转化的格式为png,也可设置为其他格式 let img = Canvas2Image.convertToJPEG(canvas, canvas.width, canvas.height) this.$refs.realImg.appendChild(img) // $(img).css(&#123; // "width": canvas.width / 2 + "px", // "height": canvas.height / 2 + "px", // &#125;).addClass('f-full') &#125;) &#125;)&#125; 内容溢出变成省略号(ellipsis)12345// 单行ellipsisoverflow: hidden; text-overflow:ellipsis; white-space: nowrap;// 多行ellipsisoverflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; Vue的渲染缺陷假如在v-if中这样写，v-if=&quot;obj.a&quot;且对象obj不存在a属性，那么这个页面将会整个不渲染，而不是在Vue中报错undefined。此时可以通过注释掉某片div来逐一排查是哪个判断出现问题。 Vue的watch缺陷 watch默认是浅监听，可能无法监测到对象的深层key属性变化 watch监听引用类型，拿不到oldVal 查阅: vue官方文档.得知如果是想watch检测到值变化并且立刻使用则需要加上 immediate: true, 1234567891011watch: &#123; 'uploaConfig.moreList': &#123; handler (newVal) &#123; if (this.uploadConfig.moreList &amp;&amp; this.uploadConfig.moreList.length &gt; 0) &#123; this.moreList = newVal.moreList &#125; &#125;, deep: true, immediate: true, &#125;&#125; 对象监听1234567891011121314151617181920212223242526&lt;div class="watch-demo-item"&gt; &lt;input type="text" v-model="obj.val2"&gt; &lt;div&gt;&#123;&#123;value2&#125;&#125;&lt;/div&gt;&lt;/div&gt;// ...data () &#123; return &#123; val1: '', value1: '', obj: &#123; val2: '' &#125;, value2: '' &#125;&#125;,watch: &#123; val1 (val, oval) &#123; this.value1 = val &#125;, obj (val, oval) &#123; this.value2 = val.val2 &#125;&#125;,methods: &#123;&#125; ​ 可以看到，监听的对象某个key发生变化时，watch并没有生效。 解决方案一1234567891011121314151617181920data () &#123; return &#123; val1: '', value1: '', obj: &#123; val2: '' &#125;, value2: '' &#125;&#125;,watch: &#123; val1 (val, oval) &#123; this.value1 = val &#125;, 'obj.val2' (val, oval) &#123; this.value2 = val &#125;&#125;,methods: &#123;&#125; ​ 确实是成功了，但现实开发过程中，我们的obj对象很难确定里面的key数量，假如很多个key的时候，总不能写多个监听去监听key吧？ 解决方案二123456789101112131415161718192021data () &#123; return &#123; val1: '', value1: '', obj: &#123; val2: '' &#125;, value2: '' &#125;&#125;,watch: &#123; val1 (val, oval) &#123; this.value1 = val &#125;, 'obj': &#123; handler (val, oval) &#123; this.value2 = val.val2 &#125;, deep: true &#125;&#125;, 解释：handler是watch的高级用法,里面有一个属性 deep，默认值是 false，代表是否深度监听, 还有一个属性 immediate，默认值也是 false ，但immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。deep深度监听会影响性能； 两者可以同时存在。 定义一个高度自适应的输入框前些日子有过textarea高度自适应的需求，找到一个插件flexText,虽然没有用上去，但是的精简的代码很吸引我。 它是原理是这样的，HTML结构如下： 1234&lt;div class="expandingArea"&gt; &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;textarea placeholder="输入文字"&gt;&lt;/textarea&gt;&lt;/div&gt; 其中的expandingArea的样式仅有 123.expandingArea&#123; position:relative;&#125; 目的是用于textarea相对于expandingArea绝对定位： 123456textarea&#123; position:absolute; top:0; left:0； height:100%;&#125; 通过这样的样式设置，textArea的高度会始终等于expandingArea的高度，要让textarea的高度变化也只需要调整expadingArea的高度即可。那么怎么样让expandingArea的高度变化随内容高度变化而变化呢？pre是比较重要的东西。 1234pre&#123; display:block; visibility:hidden;&#125; pre以块形式存在，并且不可见，但是是占用空间的，不像display:none;什么空间也不占。这时需要把textarea中的内容实时同步到pre里的span标签中，因为pre没有postion:absolute所以它的高度会一直影响expandingArea的高度。总结原理就是：pre会随内容的高度变化而变化，expandingArea的高度又随pre变化，因为textarea的高度100% textarea的高度会随expandingArea变化，只要同步textarea的内容到pre中，就达到一个textarea随内容高度变化的目的了。 关于这个方法的兼容性问题 在这个方法的创始人博客有提到NEIL JENKINS。个人觉得这个方法是牛逼的，没有通过计算，逻辑上它像上思维推导，代码实现不复杂，轻松愉快。在这个例子中又看到了一次合理的结构可以简化代码的案例:)。 参考于如何创建一个高度自适应的textarea 延伸阅读：line-height:normal是怎样计算的? - 知乎 https://www.zhihu.com/question/21786347 （提到了IFC的概念） Vue事件中的event参数12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;increment1&quot;&gt;+1&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;increment2(2, $event)&quot;&gt;+2&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; num: 0 &#125; &#125;, methods: &#123; increment1(event) &#123; console.log(&#39;event&#39;, event, event.__proto__.constructor) &#x2F;&#x2F; 是原生的 event 对象 console.log(event.target) console.log(event.currentTarget) &#x2F;&#x2F; 注意，事件是被注册到当前元素的，和 React 不一样 this.num++ &#125;, increment2(val, event) &#123; console.log(event.target) this.num &#x3D; this.num + val &#125;, loadHandler() &#123; &#x2F;&#x2F; do some thing &#125; &#125;, mounted() &#123; window.addEventListener(&#39;load&#39;, this.loadHandler) &#125;, beforeDestroy() &#123; &#x2F;&#x2F;【注意】用 vue 绑定的事件，组建销毁时会自动被解绑 &#x2F;&#x2F; 自己绑定的事件，需要自己销毁！！！ window.removeEventListener(&#39;load&#39;, this.loadHandler) &#125;&#125;&lt;&#x2F;script&gt; event 是原生的 事件被挂载到当前事件绑定的元素 和 DOM 事件一样 Vue非父子组件间的通信（自定义事件 event.js 123import Vue from 'vue'export default new Vue() input.vue 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;title&quot;&#x2F;&gt; &lt;button @click&#x3D;&quot;addTitle&quot;&gt;add&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import event from &#39;.&#x2F;event&#39;export default &#123; data() &#123; return &#123; title: &#39;&#39; &#125; &#125;, methods: &#123; addTitle() &#123; &#x2F;&#x2F; 调用父组件的事件 this.$emit(&#39;add&#39;, this.title) &#x2F;&#x2F;🌟🌟🌟 调用自定义事件，也可以传参 event.$emit(&#39;onAddTitle&#39;, this.title) this.title &#x3D; &#39;&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; list.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item.id&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;button @click&#x3D;&quot;deleteItem(item.id)&quot;&gt;删除&lt;&#x2F;button&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import event from &#39;.&#x2F;event&#39;export default &#123; props: &#123; list: &#123; type: Array, default() &#123; return [] &#125; &#125; &#125;, data() &#123; return &#123; &#125; &#125;, methods: &#123; deleteItem(id) &#123; this.$emit(&#39;delete&#39;, id) &#125;, addTitleHandler(title) &#123; console.log(&#39;on add title&#39;, title) &#125; &#125;, mounted() &#123; &#x2F;&#x2F;🌟🌟🌟 绑定自定义事件 &#x2F;&#x2F;🌟🌟🌟 之所以这里写的函数名而不是箭头函数是为了方便在beforeDestroy里解绑该自定义事件 event.$on(&#39;onAddTitle&#39;, this.addTitleHandler) &#125;, beforeDestroy() &#123; &#x2F;&#x2F;🌟🌟🌟 及时销毁，否则可能造成内存泄露 event.$off(&#39;onAddTitle&#39;, this.addTitleHandler) &#125;&#125;&lt;&#x2F;script&gt; 自定义一个Vue实例（这里的event），这个实例就可以实现$on、$emit、$off的功能。就不需要引入event bus总线了 $nextTick vue是异步渲染。（是为了减少DOM的操作次数以提高性能 data改变之后，DOM并不会立刻渲染 $nextTick会在DOM渲染之后被触发，以获取最新的DOM节点 vue会汇总 data 的修改，一次性更新视图 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;ul ref&#x3D;&quot;ul1&quot;&gt; &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;index&quot;&gt; &#123;&#123;item&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;button @click&#x3D;&quot;addItem&quot;&gt;添加一项&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;app&#39;, data() &#123; return &#123; list: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125; &#125;, methods: &#123; addItem() &#123; this.list.push(&#96;$&#123;Date.now()&#125;&#96;) this.list.push(&#96;$&#123;Date.now()&#125;&#96;) this.list.push(&#96;$&#123;Date.now()&#125;&#96;) &#x2F;&#x2F; 1. 异步渲染，$nextTick 待 DOM 渲染完再回调 &#x2F;&#x2F; 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次 this.$nextTick(() &#x3D;&gt; &#123; &#x2F;&#x2F; 获取 DOM 元素 const ulElem &#x3D; this.$refs.ul1 console.log( ulElem.childNodes.length ) &#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>tips</tag>
        <tag>work</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>html2canvas</tag>
        <tag>canvas2image</tag>
        <tag>refs</tag>
        <tag>ellipsis</tag>
        <tag>高度自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue深入理解]]></title>
    <url>%2F2019%2F04%2F15%2FVue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[组件化基础​ 传统组件，只是静态渲染，更新还是要依赖于操作DOM，比如JQuery。而Vue的MVVM、React的setState都是数据驱动视图的框架。 ​ 第一个M（Model）表示的是Vue组件中的Data部分，第二个V（View）表示的是Vue组件中的视图，也就是html模板，而VM（ViewModel）比较抽象，可以理解为Vue提供的能力，是View层和Model层连接的部分，具像化来说就是Vue的指令、方法等等。 Vue响应式 组件data的数据一旦变化，立刻触发视图的更新 实现数据驱动视图的第一步 核心API: Object.defineProperty() Object.defineProperty()基本用法 Object.defineProperty(obj, prop/key, descriptor) 12345678910111213141516const data = &#123;&#125;const name = 'zhangsan'Object.defineProperty(data, 'name', &#123; get: function() &#123; console.log('get') return name &#125;, set: function(newVal) &#123; console.log('set') name = newVal &#125;&#125;)// testconsole.log(data.name) // get zhangsandata.name = 'lisi' // set 深度监听data变化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 触发更新视图function updateView() &#123; console.log('视图更新')&#125;// 🌟🌟🌟重新定义数组原型const oldArrayProperty = Array.prototype// 🌟🌟🌟创建新对象，原型指向 oldArrayProperty ，再扩展新的方法（触发视图更新）不会影响原型const arrProto = Object.create(oldArrayProperty);['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName =&gt; &#123; arrProto[methodName] = function () &#123; updateView() // 触发视图更新 oldArrayProperty[methodName].call(this, ...arguments) // Array.prototype.push.call(this, ...arguments) &#125;&#125;)// 重新定义属性，监听起来function defineReactive(target, key, value) &#123; // ⭐⭐⭐深度监听 observer(value) // 核心 API Object.defineProperty(target, key, &#123; get() &#123; return value &#125;, set(newValue) &#123; if (newValue !== value) &#123; // 深度监听 observer(newValue) // 设置新值 // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值 value = newValue // 触发更新视图 updateView() &#125; &#125; &#125;)&#125;// 监听对象属性function observer(target) &#123; // 不是对象或数组 就直接返回 if (typeof target !== 'object' || target === null) &#123; return target &#125; // 污染全局的 Array 原型，不可取 // Array.prototype.push = function () &#123; // updateView() // ... // &#125; // 如果target是数组，那么将target的原型复制成重写过的数组原型 if (Array.isArray(target)) &#123; target.__proto__ = arrProto &#125; // 重新定义各个属性（for in 也可以遍历数组） for (let key in target) &#123; defineReactive(target, key, target[key]) &#125;&#125;// 准备数据const data = &#123; name: 'zhangsan', age: 20, info: &#123; address: '北京' // 需要深度监听 &#125;, nums: [10, 20, 30]&#125;// 监听数据observer(data)// 测试data.name = 'lisi'data.age = 21// console.log('age', data.age)data.x = '100' // 新增属性，监听不到 —— 所以有 Vue.setdelete data.name // 删除属性，监听不到 —— 所以有 Vue.deletedata.info.address = '上海' // 深度监听data.nums.push(4) // 监听数组 Object.defineProperty()的缺陷 深度监听时需要递归到底，一次性计算量大 无法监听新增属性/删除属性（Vue.set / Vue.delete） 无法原生监听数组，需要特殊处理 虚拟DOM(Virture DOM)背景​ DOM操作既耗时也耗费性能，而JS的执行是比较快的。以前用jQuery，可以自行控制DOM操作的时机，手动调整。而Vue和React都是数据驱动视图，如何有效控制DOM操作？当代web页面的复杂度日益提升，有了一定的复杂度，想减少计算次数比较难，那么能不能把计算，更多地转移为JS计算。解决方案就是vdom。用JS来模拟DOM结构，计算出最小的变更，再来操作DOM。 用JS模拟DOM结构123456&lt;div id="div1" class="container"&gt; &lt;p&gt;vdom&lt;/p&gt; &lt;ul style="font-size: 20px;"&gt; &lt;li&gt;a&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132/** * 🌟🌟🌟三要素 * tag/el/sel: 标签或者选择器 * props: 属性、样式、事件 * children: 子元素/子节点 */&#123; tag: 'div', props: &#123; className: 'container', id: 'div1' &#125;, children: [ &#123; tag: 'p', children: 'vdom' &#125;, &#123; tag: 'ul', props: &#123; style: 'font-size: 20px;' &#125;, children: [ &#123; tag: 'li', children: 'a' &#125; // ... ] &#125; ]&#125; diff算法diff算法概述 diff即对比，是一个广泛的概念，如linux 的diff命令、git diff等 两个js对象也可以做diff，如 http://github.com/cujojs/jiff 两棵树做diff，如这里的 vdom diff。 ![image-20200714140541476](/Users/su/Library/Application Support/typora-user-images/image-20200714140541476.png) 树的diff算法时间复杂度为O(n^3): 第一，遍历tree1；第二，遍历tree2； 第三，排序； 如果有1000个节点，那么就要计算10亿次，所以算法不可用 🌟🌟🌟优化时间复杂度到O(n) 只比较同一层级，不跨级比较； tag不相同，则直接删掉重建，不再深度比较； tag和key，两者都相同，则认为是相同节点，不再深度比较。 Snabbdom源码snabbdom是一个简洁强大的vdom库，易学易用。Vue也是参考它来实现的vdom和diff。 patch()函数12345678910111213141516171819202122232425262728293031323334353637return function patch (oldVnode: VNode | Element, vnode: VNode): VNode &#123; let i: number, elm: Node, parent: Node; const insertedVnodeQueue: VNodeQueue = []; // 执行 pre hook for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i](); // 第一个参数不是 vnode if (!isVnode(oldVnode)) &#123; // 创建一个空的 vnode ，关联到这个 DOM 元素 oldVnode = emptyNodeAt(oldVnode); &#125; // 相同的 vnode（key 和 sel 都相等） if (sameVnode(oldVnode, vnode)) &#123; // vnode 对比 patchVnode(oldVnode, vnode, insertedVnodeQueue); // 不同的 vnode ，直接删掉重建 &#125; else &#123; elm = oldVnode.elm!; parent = api.parentNode(elm); // 重建 createElm(vnode, insertedVnodeQueue); if (parent !== null) &#123; api.insertBefore(parent, vnode.elm!, api.nextSibling(elm)); removeVnodes(parent, [oldVnode], 0, 0); &#125; &#125; for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123; insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]); &#125; for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i](); return vnode; &#125;; patchVnode()函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 🌟🌟🌟 patchVnode过程 function patchVnode (oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123; // 执行 prepatch hook const hook = vnode.data?.hook; hook?.prepatch?.(oldVnode, vnode); // 设置 vnode.elem const elm = vnode.elm = oldVnode.elm!; // 旧 children let oldCh = oldVnode.children as VNode[]; // 新 children let ch = vnode.children as VNode[]; if (oldVnode === vnode) return; // hook 相关 if (vnode.data !== undefined) &#123; for (let i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); vnode.data.hook?.update?.(oldVnode, vnode); &#125; // vnode.text === undefined （vnode.children 一般有值） if (isUndef(vnode.text)) &#123; // 新旧都有 children if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue); // 新 children 有，旧 children 无 （旧 text 有） &#125; else if (isDef(ch)) &#123; // 清空 text if (isDef(oldVnode.text)) api.setTextContent(elm, ''); // 添加 children addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue); // 旧 child 有，新 child 无 &#125; else if (isDef(oldCh)) &#123; // 移除 children removeVnodes(elm, oldCh, 0, oldCh.length - 1); // 旧 text 有 &#125; else if (isDef(oldVnode.text)) &#123; api.setTextContent(elm, ''); &#125; // else : vnode.text !== undefined （vnode.children 无值） &#125; else if (oldVnode.text !== vnode.text) &#123; // 移除旧 children if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1); &#125; // 设置新 text api.setTextContent(elm, vnode.text!); &#125; hook?.postpatch?.(oldVnode, vnode); &#125; updateChildren()函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function updateChildren (parentElm: Node, oldCh: VNode[], newCh: VNode[], insertedVnodeQueue: VNodeQueue) &#123; let oldStartIdx = 0, newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx: KeyToIndexMap | undefined; let idxInOld: number; let elmToMove: VNode; let before: any; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx]; &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx]; // 开始和开始对比 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; // 结束和结束对比 &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; // 开始和结束对比 &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldStartVnode.elm!, api.nextSibling(oldEndVnode.elm!)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; // 结束和开始对比 &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; // 以上四个都未命中 &#125; else &#123; if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; // 拿新节点 key ，能否对应上 oldCh 中的某个节点的 key idxInOld = oldKeyToIdx[newStartVnode.key as string]; // 没对应上 if (isUndef(idxInOld)) &#123; // New element api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!); newStartVnode = newCh[++newStartIdx]; // 对应上了 &#125; else &#123; // 对应上 key 的节点 elmToMove = oldCh[idxInOld]; // sel 是否相等（sameVnode 的条件） if (elmToMove.sel !== newStartVnode.sel) &#123; // New element api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!); // sel 相等，key 相等 &#125; else &#123; patchVnode(elmToMove, newStartVnode, insertedVnodeQueue); oldCh[idxInOld] = undefined as any; api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!); &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; &#125; if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm; addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125; &#125; &#125; 模板编译​ 模板是Vue开发中最常用的部分，它不是html，有指令、插值、JS表达式。能实现判断、循环。html只是标签语言，只有JS才能实现顺序执行、判断、循环（图灵完备的）。因此，模板一定是转换为某种JS代码，即编译模板。了解了模板渲染，就能知道“组件渲染和更新过程”。 前置知识：JS的with语法 vue template complier 将模板编译为render函数 模板编译为render函数，执行render函数生成vnode，基于vnode再去执行patch和diff。 使用webpack的vue-loader，会在开发环境下编译模板，即解析模板为render函数（重要） with语法 改变 {} 内自由变量的查找方式，即当作obj属性来查找 如果找不到匹配的obj属性，就会报错 🌟🌟🌟 with要慎用，它打破了作用域规则，易读性变差（基本上不推荐使用） 模板编译具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const compiler = require('vue-template-compiler')// 插值const template = `&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`// with(this)&#123;return _c('p',[_v(_s(message))])&#125;// with(this)&#123;return createElement('p',[createTextVNode(toString(message))])&#125;// _c == createElement == h// h -&gt; vnode | createElement -&gt; vnode// // 表达式// const template = `&lt;p&gt;&#123;&#123;flag ? message : 'no message found'&#125;&#125;&lt;/p&gt;`// // with(this)&#123;return _c('p',[_v(_s(flag ? message : 'no message found'))])&#125;// // 属性和动态属性// const template = `// &lt;div id="div1" class="container"&gt;// &lt;img :src="imgUrl"/&gt;// &lt;/div&gt;// `// with(this)&#123;return _c('div',// &#123;staticClass:"container",attrs:&#123;"id":"div1"&#125;&#125;,// [// _c('img',&#123;attrs:&#123;"src":imgUrl&#125;&#125;)])&#125;// // 条件// const template = `// &lt;div&gt;// &lt;p v-if="flag === 'a'"&gt;A&lt;/p&gt;// &lt;p v-else&gt;B&lt;/p&gt;// &lt;/div&gt;// `// with(this)&#123;return _c('div',[(flag === 'a')?_c('p',[_v("A")]):_c('p',[_v("B")])])&#125;// 循环// const template = `// &lt;ul&gt;// &lt;li v-for="item in list" :key="item.id"&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;// &lt;/ul&gt;// `// with(this)&#123;return _c('ul',_l((list),function(item)&#123;return _c('li',&#123;key:item.id&#125;,[_v(_s(item.title))])&#125;),0)&#125;// 事件// const template = `// &lt;button @click="clickHandler"&gt;submit&lt;/button&gt;// `// with(this)&#123;return _c('button',&#123;on:&#123;"click":clickHandler&#125;&#125;,[_v("submit")])&#125;// v-model// const template = `&lt;input type="text" v-model="name"&gt;`// 主要看 input 事件// with(this)&#123;return _c('input',&#123;directives:[&#123;name:"model",rawName:"v-model",value:(name),expression:"name"&#125;],attrs:&#123;"type":"text"&#125;,domProps:&#123;"value":(name)&#125;,on:&#123;"input":function($event)&#123;if($event.target.composing)return;name=$event.target.value&#125;&#125;&#125;)&#125;// render 函数// 返回 vnode// patch// 编译const res = compiler.compile(template)console.log(res.render) 123456789101112131415161718192021// 🌟🌟🌟 从 vue 源码中找到缩写函数的含义function installRenderHelpers (target) &#123; target._c = createElement; target._o = markOnce; target._n = toNumber; target._s = toString; target._l = renderList; target._t = renderSlot; target._q = looseEqual; target._i = looseIndexOf; target._m = renderStatic; target._f = resolveFilter; target._k = checkKeyCodes; target._b = bindObjectProps; target._v = createTextVNode; target._e = createEmptyVNode; target._u = resolveScopedSlots; target._g = bindObjectListeners; target._d = bindDynamicKeys; target._p = prependModifier;&#125; vue组件中使用render代替template12345678910111213141516Vue.component('heading', &#123; // template: `xxx`, render: function(createElement) &#123; return createElement( 'h' + this.level, // h1、h2等标题 [ createElement('a', &#123; attrs: &#123; name: 'headerId', href: '#' + 'headerId' &#125; &#125;, 'this is a tag') ] ) &#125;&#125;); 在有些复杂情况中，不能用template，可以考虑用render React一直都在用render（没有模板），和这里一样 vue组件的渲染和更新 初次渲染过程 解析模板为 render 函数（或在开发环境中已完成，vue-loader） 触发响应式，监听 data 属性 getter setter 执行 render 函数，生成vnode ， patch(elem, vnode) 执行render函数 会触发getter123456789101112&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; message: 'hello', // 会触发 get city: 'hangzhou' // 不会触发 get 因为模板没有用到，即和视图没有关系 &#125; &#125;&#125;&lt;/script&gt; 更新过程 修改 data，触发setter（此前在getter中已被监听） 重新执行 render 函数，生成 newVnode patch(vnode, newVnode)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>响应式</tag>
        <tag>mvvm</tag>
        <tag>vdom</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令详解]]></title>
    <url>%2F2019%2F03%2F21%2FGit%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言尽管 Git是一款非常强大的工具。我发现在使用Git时，在头脑里可视化地想象它会非常有用：当我执行一个特定命令时，这些分支会如何交互，又会怎样影响历史记录？为什么当我在master 上执行硬重启，force push到原分支以及 rm -rf我们的.git文件夹时，我的同事却哭了？ 下面我将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。而我的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！ 合并 Merge拥有多个分支是很方便的，以使新变更彼此分离，并确保您不会意外将未经批准或破损的变更推到生产中。但一旦这些修改得到了批准许可，我们就可以将其部署到我们的生产分支中了！ 将更改从一个分支转移到另一个分支的一种方法是执行 git merge!Git 可以执行两种类型的合并：fast-forward 和no-fast-forward🐢 现在这可能没有多大意义，所以让我们看一下差异！ Fast-forward（–ff）在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward合并。 Git很懒，首先会尝试执行最简单的选项：fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。 完美！现在，我们可以在分支上获得对master分支所做的所有更改。 那么 no-fast-forward又是什么意思呢？ No-fast-foward （–no-ff）如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git将会执行no-fast-forward合并。 使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。 这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！ 没什么大不了的，完美的合并！ 现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。 合并冲突 Merge Conflicts尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。 当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git就不知道如何取舍了。 在这样的情况下，Git会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了README.md的第一行。 如果我们想把 dev 合并到master，就会出现一个合并冲突：你想要标题是 Hello! 还是 Hey!？ 当尝试合并这些分支时，Git 会向你展示冲突出现的位置。 我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。 完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git不应该瞎猜我们想要保留哪些修改。 变基（Rebase）我们刚看到可通过执行git merge 将一个分支的修改应用到另一个分支。 另一种可将一个分支的修改融入到另一个分支的方式是执行 git rebase。 git rebase 会将当前分支的提交复制到指定的分支之上。 完美，现在我们在dev 分支上获取了master分支上的所有修改。 变基与合并 有一个重大的区别：Git不会尝试确定要保留或不保留哪些文件。我们执行rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git历史记录。 上面这个例子展示了在 master分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。git rebase在为复制的提交创建新的 hash时会修改项目的历史记录。 如果你在开发一个 feature分支并且 master分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。 交互式变基（Interactive Rebase）在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。 在我们正在 rebase 的提交上，我们可以执行以下 6 个动作： reword：修改提交信息； edit：修改此提交； squash：将提交融合到前一个提交中； fixup：将提交融合到前一个提交中，不保留该提交的日志消息； exec：在每个提交上运行我们想要 rebase 的命令； drop：移除该提交。 很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 drop 即可。 如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！ 交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。 重置（Reset）当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 git reset。 git reset 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。 软重置软重置会将 HEAD 移至指定的提交（或与HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！ 假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。 输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！ 还原（Revert）另一种撤销修改的方法是执行 git revert。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。 假设 ec5be 添加了一个 index.js 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！ 完美！提交 9e78i 还原了由提交 ec5be 引入的修改。在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。 拣选（Cherry-pick）当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。 假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交！ 现在 master 分支包含 76d12 引入的修改了。 取回（Fetch）如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。 通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。 现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。 拉取（Pull）尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 git pull。git pull 实际上是两个命令合成了一个：git fetch 和 git merge。当我们从来源拉取修改时，我们首先是像 git fetch 那样取回所有数据，然后最新的修改会自动合并到本地分支中。 很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！ Reflog每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。 git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。 如果你犯了错，你可以根据 reflog 提供的信息通过重置 HEAD 来轻松地重做！ 假设我们实际上并不需要合并原有分支。当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。 我们可以看到最新的动作已被推送给 reflog。 Git有很多有用强大的命令，我希望我能掌握所有！😊 原文地址：https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1原文作者：Lydia Hallie ⭐⭐⭐ Rebase &amp;&amp; Merge基本git rebase用于把一个分支的修改合并到当前分支。 假设你现在基于远程分支origin，创建一个叫mywork的分支。 1$ git checkout -b mywork origin 假设远程分支origin已经有了2个提交，如图 现在我们在这个分支做一些修改，然后生成两个提交commit 123456789$ vi file.txt$ git commit$ vi otherfile.txt$ git commit。。。 但是与此同时，有些人也在origin分支上做了一些修改并且做了提交了. 这就意味着origin和mywork这两个分支各自”前进”了，它们之间”分叉”了。 在这里，你可以用pull命令把origin分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit): 但是，如果你想让mywork分支历史看起来像没有经过任何合并一样，你也许可以用 git rebase: 123$ git checkout mywork$ git rebase origin 这些命令会把你的mywork分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到.git/rebase目录中),然后把mywork分支更新 为最新的origin分支，最后把保存的这些补丁应用到mywork分支上。 当mywork分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. （请查看 git gc) 解决冲突​ 在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用git-add命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行: 1$ git rebase --continue 这样git会继续应用(apply)余下的补丁。 在任何时候，你可以用--abort参数来终止rebase的行动，并且mywork 分支会回到rebase开始前的状态。 1$ git rebase --abort git rebase和git merge的区别​ 现在我们可以看一下用合并(merge)和用变基(rebase)所产生的历史的区别： 当我们使用Git log来参看commit时，其commit的顺序也有所不同。 假设C3提交于9:00AM,C5提交于10:00AM,C4提交于11:00AM，C6提交于12:00AM, 对于使用git merge来合并所看到的commit的顺序（从新到旧）是：C7 ,C6,C4,C5,C3,C2,C1 对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：C7 ,C6‘,C5’,C4,C3,C2,C1 因为C6&#39;提交只是C6提交的克隆，C5&#39;提交只是C5提交的克隆， 从用户的角度看使用git rebase来合并后所看到的commit的顺序（从新到旧）是：C7 ,C6,C5,C4,C3,C2,C1 另外，我们在使用git pull命令的时候，可以使用--rebase参数，即git pull --rebase,这里表示把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到.git/rebase目录中),然后把本地当前分支更新 为最新的origin分支，最后把保存的这些补丁应用到本地当前分支上。关于git pull的更多内容请参考《git pull简介》 ⭐⭐⭐ 变基的风险变基也并非完美无缺，要用它得遵守一条准则： 一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行变基操作。 如果你遵循这条金科玉律，就不会出差错。否则，就去向全国人民谢罪吧。 在进行变基的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。 下面我们用一个实际例子来说明为什么公开的变基会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似下图 所示： 现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成这样： 接下来，那个推送 C6 上来的人决定用变基取代之前的合并操作；继而又用 git push --force 覆盖了服务器上的历史，得到 C4&#39;。而之后当你再从服务器上下载最新提交后，会得到： 下载更新后需要合并，但此时变基产生的提交对象 C4&#39; 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4&#39; 合并为 C8: C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4&#39;，两者有着不同的 SHA-1 校验值，如果用 git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些变基后的提交引入到中央服务器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用变基发布 C4&#39; 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。 如果把变基当成一种在推送之前清理提交历史的手段，而且仅仅变基那些尚未公开的提交对象，就没问题。如果变基那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortcut Key For VS Code]]></title>
    <url>%2F2019%2F01%2F11%2FShortcut%20Key%20For%20VS%20Code%2F</url>
    <content type="text"><![CDATA[Shortcut Key For VS Code 全局CMD + Shift + P / F1 显示命令面板CMD + P 快速打开CMD + Shift + N 打开新窗口CMD + W 关闭窗口 基本CMD + X 剪切（未选中文本的情况下，剪切光标所在行）CMD + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行CMD + Shift + K 删除行CMD + Enter 下一行插入CMD + Shift + Enter 上一行插入CMD + Shift + \ 跳转到匹配的括号CMD + [ 减少缩进CMD + ] 增加缩进Home 跳转至行首End 跳转到行尾CMD + Up 跳转至文件开头CMD + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动CMD + PgUp 按屏向上滚动CMD + PgDown 按屏向下滚动CMD + Shift + [ 折叠代码块CMD + Shift + ] 展开代码块CMD + K CMD + [ 折叠全部子代码块CMD + K CMD + ] 展开全部子代码块CMD + K CMD + 0 折叠全部代码块CMD + K CMD + J 展开全部代码块CMD + K CMD + C 添加行注释CMD + K CMD + U 移除行注释CMD + / 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行 多光标与选择Option + 点击 插入多个光标CMD + Option + Up 向上插入光标CMD + Option + Down 向下插入光标CMD + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标CMD + I 选中当前行CMD + Shift + L 选中所有与当前选中内容相同部分CMD + F2 选中所有与当前选中单词相同的单词CMD + Ctrl + Shift + Left 折叠选中CMD + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块CMD + Shift + Option + Up 列选择 向上CMD + Shift + Option + Down 列选择 向下CMD + Shift + Option + Left 列选择 向左CMD + Shift + Option + Right 列选择 向右CMD + Shift + Option + PgUp 列选择 向上翻页CMD + Shift + Option + PgDown 列选择 向下翻页 查找替换CMD + F 查找CMD + Option + F 替换CMD + G 查找下一个CMD + Shift + G 查找上一个Option + Enter 选中所有匹配项CMD + D 向下选中相同内容CMD + K CMD + D 移除前一个向下选中相同内容 进阶Ctrl + Space 打开建议CMD + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化CMD + K CMD + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容CMD + K F12 分屏查看具体声明内容CMD + . 快速修复Shift + F12 显示引用F2 重命名符号CMD + Shift + . 替换为上一个值CMD + Shift + , 替换为下一个值CMD + K CMD + X 删除行尾多余空格CMD + K M 更改文件语言 导航CMD + T 显示所有符号Ctrl + G 跳转至某行CMD + P 跳转到某个文件CMD + Shift + O 跳转到某个符号CMD + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点 编辑器管理CMD + W 关闭编辑器CMD + K F 关闭文件夹CMD + \ 编辑器分屏CMD + 1 切换到第一分组CMD + 2 切换到第二分组CMD + 3 切换到第三分组CMD + K CMD + Left 切换到上一分组CMD + K CMD + Right 切换到下一分组CMD + K CMD + Shift + Left 左移编辑器CMD + K CMD + Shift + Right 右移编辑器CMD + K Left 激活左侧编辑组CMD + K Right 激活右侧编辑组 文件管理CMD + N 新建文件CMD + O 打开文件CMD + S 保存文件CMD + Shift + S 另存为CMD + Option + S 全部保存CMD + W 关闭CMD + K CMD + W 全部关闭CMD + Shift + T 重新打开被关闭的编辑器CMD + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个CMD + K P 复制当前文件路径CMD + K R 在资源管理器中查看当前文件CMD + K O 新窗口打开当前文件 显示CMD + Ctrl + F 全屏、退出全屏CMD + Option + 1 切换编辑器分屏方式（横、竖）CMD + + 放大CMD + - 缩小CMD + B 显示、隐藏侧边栏CMD + Shift + E 显示资源管理器 或 切换焦点CMD + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板CMD + Shift + D 显示调试面板CMD + Shift + X 显示插件面板CMD + Shift + H 全局搜索替换CMD + Shift + J 显示、隐藏高级搜索CMD + Shift + C 打开新终端CMD + Shift + U 显示输出面板CMD + Shift + V Markdown预览窗口CMD + K V 分屏显示 Markdown预览窗口 调试F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过CMD + K CMD + I 显示悬停信息 集成终端Ctrl + 显示终端 Ctrl + Shift + 新建终端CMD + Up 向上滚动CMD + Down 向下滚动PgUp 向上翻页PgDown 向下翻页CMD + Home 滚动到顶部CMD + End 滚动到底部]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职场菜鸟的一些感想]]></title>
    <url>%2F2019%2F01%2F05%2F%E8%81%8C%E5%9C%BA%E8%8F%9C%E9%B8%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与本人联系。This is an encrypted article, the content may be personal emotional catharsis or charging technology. If you really want to see it, please contact me. 📩📩📩a38b0462f26067be6ab4506a842af4178a52cbe4b601a16b50ab0bfaf0fd258c17f92aeaef4ffde5079c1750397eea1315eb7620f9ef0efeda7ad143acadbfb20f2530f581ae855baab5c5d86100c9b322ccf9cb96815bc18f45c5c3ab7c275ce3ac9a035ae6642c05f1b2747133b657a58f75d06db46b14be6770da394eaf7b0b5f8429b71b71fcedb9c6ed5ac86c7b9e594bbc5f40c129dd1489683ffff0a5e0a32a9042fea589fe6106fb43596a75120d67ba92b8b632fb26be4f31ab0800dc1f80f37b2fb4de7ca45ce775b5feffcd1b023b1ea938d167a3d23589509976f654a7e39e750f463848991b7bd4b50977e3e43ca10bab438b42b172198e82337cb9a372a2752f483cce9caafc70b4bad3f9e07131daf57a20020a4cf53d808bbed55c05e9c1b4a40b58eb8a43659d8a9b2ebd84f4094428f894a2e082579820049c335f083497321d42581263449d75839490310e0f1120fcdcc8f330e4b73b4cc6d36a2a3bb747e76ed1f8460020598e3f6117ab2e03793a3180afa92cb42d73f5e9abe605b7408be74c3e97ca05810fd3800c0a0b186978ccac43b4739901ffe6adb1c2b71ba39cf47c6f5f40902d56f96fb66f09ad0ee8f2205e818e31b6ed6a9666774c524d960c91d17e2d08fa9d05ebf7418b0ccd6a2f90d322968efbe7bfa4b7590f99884cc20d48a81915bd07137a53c4c85632492c93befdff8216635f0e21df48ab89706f1269e9c5d4b0d386a5dc495802526f1cba0a3bb40ee1174c4d6856529fd7e6a477673386db397d8e860fa7c52677fecd22a771ee42fa9e017c062dbeb7d337d603ebe65206e9e6e5f25e3e0419b059f0dba65a257b11ee91747e095c502e06985a06186f0e5a195c0c807143e2cc79e7d68567e4a5eedf38d851815e5dc581cd72478299912859a5ae33538c4c8d4f993d2472bed3e079740d6027178cea60cf42b646d85547e6e56380b3c974b0fca2b53ea9da5d7c3d4bc70b716fde48535c5e4f55d48a9f9c352dd06d23ba8d5c0cf8140a21681b89964a93be443039d161ff635e0a6c2394b3f453cf47e70b03a5da78a23141c6ed64b18cec5301c0cfd5cc074ca81bd60cfab10574d3b70cec772f7f45c9fccf313aeb205f3fece0799f5d13181adc5b63394739555a79305b5f9089585db09081be70bb3789215e6828bde5e5c7b5947dffd1dcfc4c5fa61e6f88a71c1a0c18511a41378907cc780f3465dc69f533ca8dbeb382202dc4b4faf5d02f54296075bf575ba067e6423040df8da233722c8d907f301ab74b2a71575e93b1b1aebba074e4dbfd576f13b10c5db35e8248dbcfc28cd31db4abcb0f5b4e9bf8d216eb15960e0a89e03569e053cba70b4487def6a74cae51cd389331f8ac8c37217e17c8a5c6960c811ad090ad1d413c583fa56337480eb9c89fd3cd68e20f175602f45aab351370d351f58b1bfe1e7786b78742230b046bbdb3afc6118b85d4b8fdf9991f5975e15cbefcab4d798525d236239b89b055fb5ec64381b443ec2159ec13dea2f96da9267aac835477b8963fc20c6c0bb8a77dca39b6f1e66b2ffb46a2060aaed800f210c205321e0a1edaee53721f8653ab0ee68042c4432b4dd7263b2997edc26ff75d9e8e527b7a52c73078827e6ba85298c423d7ce9b93691fe8b1bc5cc766d1bf72d51ca8eb27f80a9e3fbf78e8882523c5ae630903fcf7fcf442e8213ffc3e1661c79a712088a58c58d52f7505f8477bf0ee5cbd6cd31ebdcfe5722b50dc8b5e4671c9ae6189da320928ffdf38abcad45b93dab44eb668fd07698a67e132ee371096faca49c2c38de978444b8e2ece13f0ff51acf56d2b44e16f592234c1cb3d8ee56f4f69198d07c7f40b813de5758a6a5d6426f3cd8dc584692b11386e6e4d6ca97eb32c48c29eefbe31a12ac74e65a291706ed95381ee988a09761f2fe1087709cd58f1796e308d48c4fc47b1a83152aec0e065fff715817116354ff5835d61eda56a527d11ed8a1287489d3346d4b23eae9299f29234618e2f81f2f3cb5ee96635eea77bec35f00aad0efeb9e9e3c1219e65f8e8982d44f2a3005cc4d861fccaf6464bd7f9347478e80b9353ed6f267eb04ee963e04ec7c80af27b9e1c73a79c75bed921db8fe3c04e2cee68b4e3da8d48866314a76ac4535d5104391eb4f71222d9a846cd79a1bc730018d26bc76f791f0025fca9dc500c03a2e221159311f4e2181b81dce6fa573df59c6397207c56106ff2ea1e3cc7a3eef12e5c6ab03c2a95bd14b59c0cd5a917ffe87c2c864f243f8dccfbab2ca7dcbf507d1095c7fa44fb691ff960fd018096838321919b83ab0747526f9864d89c982404b37141b2ccf3e19de2c0c275eca0ccc7bfae974b7b97669890776ae6b04ccca17fba004615dfb270d8b5fefb8124ca19a9d3bcb4df4425519fbfb1ff901727101a370113492e6be3938d8f112441e1dfd534f4d97ab5c3043972a1b79bcac6ce8a3d6d15d3b0a6a85ab43ead173992e6d245ed0a33fa1a888198fd058f78ec2c4be07417ffd7cd92ec82ea621c99a7a2fc5d7171f714e5aa038de9e76e5d20f710514879980d003d3f39a5ea342774cbaef03bf79e90c3b79b77a6df57df5231c63377101d32ea3fc263d2f8b59c1871374506aeab7e0f91097cc1d73574e1999c4a7efb40c6906612dd044320fb66f3642b48f05d8160b1003da3f353638a60e41939abc267f4b39f0caf28ff8fb724683b50333ae759276d866e482a120e331e95bdfdadaca4128f71de26f0e66a01e280a112913c1912752a0d11f3a77758a613467334646f042aa49590deae578a12c2d12b50e87a4971d3febba158ba158979b801129625cef1c568e05df2f137d41cffa73c391100d1673e49b1f18570e1be3437a2f60a21763baa4970c1be96bf1ca83ee533c82a9bbfbccd36df3c3ec971fd7c3faba960f424e548d145b4f9bac25f68ca1ae03b3fa283c2846b4a5033e3a6de54dc4442df1861d5142e8b33d50de4e8dd03f70c8f734044d50a329d622dac2c5a9d81832f9943b23b39f07e35bba4af2b81b5740f2f1ee9be3163bd58e8a3bf35ef84b1c378c611da2da1b71a71c8bbff9eaedfeefc75ccae063dcb16787703e810dfc50d560722eaa8dd2db54a91483d4bcdc05332804082545407a7ec5045d20ed103de346d49e499479ce7187a4a09335e17568e8b4b3ce5c3c96b2f0e4de4b0676384db5d8e27485f5c5cc10fa7de55670a3b3da7a858ed77da6d23dfc7ee7d277b31f5e0b6de884933dfe192004a4242f819c7809b25efacfd56001028931b2f3d928e210a3f7e69669e3e08a7cf7a4273ea044a3a72f939ad4d9ad7e8449c981ccf81b08658bdc9dd6a8f97bc336a15bba175215e4f43dae212aa763c729afcdde0f6e623fd93a33c2235e6627fc40f6d3095a0ee8cd214f01cfad7967fb59b6818a9404a64712aef91730245e59ed29cadd5f692100f69f72a07b51f2de32c1c103a4f6532cc9bbe1a6f551218c78c1e941c4311ecc968bbf6565e8cf4bb11c278e23e2ae59b38091be3611a646efb92b6bfdb1c20aa71f414eba30240c40035504c57d518734ea2af1508de4c1b54c5cd3a3212c779842d224160146fba5128675e1c7b052df1c64d3f3adc32232e9bc954d6ee107331c58da27b014cba3757a5e103e22acf5b25cf2bb30279083d83c0f9dc4bc3ad9bb35e8f39215f95e4ed765dfa4084cb554ebd9491f7daa6cdfa871c292a49f1214f9bba318a23bb72d3580d014442e1cc0a087d8577278d552c24c0a00397fddd91f6ea8de4688296e56e933c23f7e7b0f3d69e99f8b4a9c7f558fe23500c3541d913d3dbff8f23b6d1d9ccb51bcf64f4846b02d22c3a89238210fc9d852b035795af0cf3a81c327d754121cef342d05a8067e361ce89e3719b8e9d273a451e33f020851a03e4d9120fa6097e6617c34fa5b7c5024517fea60b12bd122c614725d0a5007ff371e1095e8a361186b34d49c5f543e61f2641dc416a53c7259d401055236d7dd6040d383006ce1f83579162e6be9afceac2d2dc2ea1b2df0435c7148b779225475b6c02067420b34e7116d9c78b47afecc7ef8238f452de6869da414958719116c952b88dfc522eeb3a9c9d280c6d8cceded56098cfacc8eb85c49a870f71d74640e81fbe9f45247aab5b7fc973d1224590922d0e8dd99e3e6f9df48b569ecb2caf395f6a9ad8c324cc05c990e52638d68572546ce5bebff85d3b137ee63ea0f1c8e467cd25a78c73f21bf9fda070af66f7d70211f5e0fc988d18c9ee666a4989daf82f18565ea57fd7b63037973ccbb36fdda7656fbd93c1a83be68fb658614360c58db06ed11dcacb7b32ff22a38370045d250cf78edaeb3e5bea85d329ed48cfac01336ec3c61aecb73820c379e69336902ffc7f5477da5bc250b75aa58905d6557aa7bfde97d5f79222c4e0fedc3828857961376d0f07c73b038104548971974d658586a9bf77146709fbba126e2c2022a8c9e42e24ec61975db28747dda83f672a2487977075fd9f1ec7b999f3d23449b28aa901f0c6ab5e7737c97464a0a7c1ea92e96be649240e5152ac4d66345ee1a2defd19cd21e9472701417ab367ac3d0b10a9d2b005a94eac27363cabdf34da73227d5fc7cda4d3bbf6253afdab5b3b56ba55a3c1b99c45434ddb1dd443a14af0f6b9db9475a42995cbc8e93054393a3a350c5f9fa2525f9d7ae4cda5fe3fd5c1372c539da97f2c6dc020c01fb0890a0c21dfabae22487631c4e65c153800dd1574408a9bd9f627c6c286779df14950f25c6ce9f34d9a9e1267e0304013c421f4730a80ec04c47b1a5b7bbed633f4af7d5f9f2d3079d4e197c09d82e80e94cc123717e054650937e5a4d0e2723a33e7357f64c34af4add20acad353a2c371a1001ce665465d1dae54af9d243181c814f6dee034553dc739a28c5ff5034ec95b1ae21c6550e43825c639de7c87beab2ccc6f199f028856111a2c2bbe5369420606875505279a32566043a8d208815814cf3b04355b43b4b558c3d039b78078f7f801dbe53e53e1b22d2b5125f9ab9b3057eae0ef20bb0fd6d289843f09668082f083a0c6bc9ff635ccef81496501d94670aff5da713c3f75c5da666a69475d75545ce496cd0c7bc2763a9c25f7754d06ad29263ff206dedf4710c1bb739e8f8f4280140424d44c8a2d0e238f4cfcf52b40c81e1b3838f970bd0cf64303686418aae58bbeeb0ff966f578182e1c0b593d3d260999eca79bb24b9ae12978d71ad4c8971253a87ccb4f83a3667294da083f9eb6c3b272688f465b08293154f1f4468a4934af1bf244bd83617e43912b10f067fd420e229f354c9b03a9aa7527c0606857dc892d56e78947f5228c88eef7b01a5e1921675ea7653aebfb76450a22ddce91806a75be83224a30fd9eba7722195527b8e5ae084933e147e0c7e5ab4b6dbdf0f6d61273b23efab126e3328e94df914c8a4d04c6a43c1b35b11c0a8f30a92b39d592474fe039e823cd14eb3776041a9bffd0807d7cbfcb77ae198165c6e4b83babcb78e8be203e3a4b8723ad4244a8d3d6f087014bb60e313eade47a6e4bb6122e0b30c211a6ad2462213e6f12513c005c36b8740e57d0fa3c8bba5503ec09a93d64919e510f6ae6bb142e8d6f410afaa8992b3900f3ec0ec01c9aafa1ec2be82bd147ba8b9114b4c550b10ae2b3bd0a6e92d01001bcd68d4c7e6d1c8e4a3fb058374480570dbba2524bd9d6919c50b0d67ffd5df7c1ffb061b4dda727414638de4196fdc480fdf400535d7baab1aad1417cc1223e231438d239f47fc515db84caf94b246bcdc580f392b741e56726d83a746142eee6392ea4f2e83936722d66b91da8ce73bb4c83af3cfe248730fd21f157a7e7106f6c1c3957f0484436b5cdbd34139583bc4f081777e5b28653b049b77c7cf709cee8da6bfe81a5eae9932a550a32e93a5e452fbe87dab078c4a8fcd275ad44ea2e2d16626ea9c4f199b2cf46b815217838196455711127b490610485b6e36ffa89e77159d66e918e80da71665da1b8c6f004db286a08f633173d23fe69258114568044350dde273d77ea6e34686a8ca71a01b98938fd5266814c44d9175c98caad6ad0ff0afd5e95fa93a9d0353a10544e514ccfe5598c3aa47a0133fa3b6ce37b9d18b18233459d7222cb593734438f7c825d835022f3aaf8ce47eb6c400c59e1b2efd8925d5f916a02014f2fc6b73c8cf1c4f4418489821065c016eb94aaff346b64c75b357b00b1d54013c71b8e2ea2103a816f289e3d2faca719ae042d27d35567451841adf7aff0df9aba0e3892ae688847664b6fb91c8d0d5e3079f041d2f8d087756cc20ccf730af9aecf5bc0f09b05c05c6851506d73f60c8778f8a870acb3f5ce76c0c0bad9bc2a65001556140d5a3a02401bab47fb973d668e909615199bb19d4e4550a61370a191fcbeca1db3298215e4725ae90bdc17c93ccede682af8d1b2bc3b1aa398934d14fdaa3d9d8a2f588daa76a022cb435e0acbd236490fd4f8488c2b15b9c768e26e4ebf7f250088811373e06320f42be70cac26d24d3750cff0ec0ba41439daa78b583c9c2c78ae367557fb38558f11470f62e40a268d0b7d455b9bd3c501776e47be110fa027f5b689920952f7cc0789094768bb016093ce82c1e4627caec9a91b4d9aacc8d6ae88945c241725ff8e8171dbc7b14de0bac5c2034a18368d6433855423dd33d7a7becdac9fbdcfb7b9e73960296129179f7808ef44f84fc1410054664f8ad63ab083f62d495f9677b84d93dc3012a5d69de6ce539732da026fa5050eae601302f51984fca923a852da4519e251b49fd46601d3f9247af6f1a871d6b4f41bee7a6898892ad82b2c41e180c9afdabc8e1cddb4da272adbd58715cf077702794b497ef70fcda1dac8300e0e082f2f54816fee577bec15134d0382c17f00c0f847909c67b4852e45e9f267dcbe02277b6d815f655a4fdde2c53a23c7ed8872376d6ecd391e0c85d4b8c89901d91ad2fd6b42bc43aa73d2cd6a6c864c1a339d199f99f53b8e3be117309181918c752ab2784ead675bb2735e491d6efac3e2045216513566eb6589672e2d907cfdb6350c916e2ee19a385a679c2a49dd4271a098447249df91f603c89d3029160579dfd75ac7e7302020c6040378a8bd073d9a905c2fd147ec1650e835988b5549934cc88898ffb75ac55c465e25248bb1e2974e4bac88b3e0ddfd15908d2a89c9922219f432]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue开发中的几个小tips]]></title>
    <url>%2F2018%2F09%2F05%2FVue%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8Ftips%2F</url>
    <content type="text"><![CDATA[几个小tips帮助更高效地开发Vue 化繁为简的Watchers场景还原： 12345678created()&#123; this.fetchPostList()&#125;,watch: &#123; searchInputValue()&#123; this.fetchPostList() &#125;&#125; 组件创建的时候我们获取一次列表，同时监听input框，每当发生变化的时候重新获取一次筛选后的列表这个场景很常见，有没有办法优化一下呢？ 招式解析：首先，在watchers中，可以直接使用函数的字面量名称；其次，声明immediate:true表示创建组件时立马执行一次。 123456watch: &#123; searchInputValue:&#123; handler: 'fetchPostList', immediate: true &#125;&#125; 一劳永逸的组件注册场景还原： 1234567891011import BaseButton from './baseButton'import BaseIcon from './baseIcon'import BaseInput from './baseInput'export default &#123; components: &#123; BaseButton, BaseIcon, BaseInput &#125;&#125; 1234567&lt;BaseInput v-model="searchText" @keydown.enter="search"/&gt;&lt;BaseButton @click="search"&gt; &lt;BaseIcon name="search"/&gt;&lt;/BaseButton&gt; 我们写了一堆基础UI组件，然后每次我们需要使用这些组件的时候，都得先import，然后声明components，很繁琐！秉持能偷懒就偷懒的原则，我们要想办法优化！ 招式解析：我们需要借助一下神器webpack，使用 require.context() 方法来创建自己的（模块）上下文，从而实现自动动态require组件。这个方法需要3个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。 我们在components文件夹添加一个叫global.js的文件，在这个文件里借助webpack动态将需要的基础组件统统打包进来。 123456789101112131415161718192021import Vue from 'vue'function capitalizeFirstLetter(string) &#123; return string.charAt(0).toUpperCase() + string.slice(1)&#125;const requireComponent = require.context( '.', false, /\.vue$/ //找到components文件夹下以.vue命名的文件)requireComponent.keys().forEach(fileName =&gt; &#123; const componentConfig = requireComponent(fileName) const componentName = capitalizeFirstLetter( fileName.replace(/^\.\//, '').replace(/\.\w+$/, '') //因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名 ) Vue.component(componentName, componentConfig.default || componentConfig)&#125;) 最后我们在main.js中import &#39;components/global.js&#39;，然后我们就可以随时随地使用这些基础组件，无需手动引入了。 无所不能的render函数场景还原: vue要求每一个组件都只能有一个根元素，当你有多个根元素时，vue就会给你报错 123456789101112131415&lt;template&gt; &lt;li v-for="route in routes" :key="route.name" &gt; &lt;router-link :to="route"&gt; &#123;&#123; route.title &#125;&#125; &lt;/router-link&gt; &lt;/li&gt;&lt;/template&gt; ERROR - Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 招式解析:那有没有办法化解呢，答案是有的，只不过这时候我们需要使用render()函数来创建HTML，而不是template。其实用js来生成html的好处就是极度的灵活功能强大，而且你不需要去学习使用vue的那些功能有限的指令API，比如v-for, v-if。（reactjs就完全丢弃了template） 12345678910functional: true,render(h, &#123; props &#125;) &#123; return props.routes.map(route =&gt; &lt;li key=&#123;route.name&#125;&gt; &lt;router-link to=&#123;route&#125;&gt; &#123;route.title&#125; &lt;/router-link&gt; &lt;/li&gt; )&#125; 无招胜有招的高阶组件划重点：这一招威力无穷，请务必掌握当我们写组件的时候，通常我们都需要从父组件传递一系列的props到子组件，同时父组件监听子组件emit过来的一系列事件。举例子： 123456789101112131415161718192021//父组件&lt;BaseInput :value="value" label="密码" placeholder="请填写密码" @input="handleInput" @focus="handleFocus&gt;&lt;/BaseInput&gt;//子组件&lt;template&gt; &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input :value="value" :placeholder="placeholder" @focus=$emit('focus', $event)" @input="$emit('input', $event.target.value)" &gt; &lt;/label&gt;&lt;/template&gt; 有下面几个优化点： 1.每一个从父组件传到子组件的props,我们都得在子组件的Props中显式的声明才能使用。这样一来，我们的子组件每次都需要申明一大堆props, 而类似placeholer这种dom原生的property我们其实完全可以直接从父传到子，无需声明。方法如下： 12345&lt;input :value="value" v-bind="$attrs" @input="$emit('input', $event.target.value)"&gt; $attrs包含了父作用域中不作为prop被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定，并且可以通过v-bind=&quot;$attrs&quot;传入内部组件——在创建更高层次的组件时非常有用。 2.注意到子组件的@focus=$emit(&#39;focus&#39;, $event)&quot;其实什么都没做，只是把event传回给父组件而已，那其实和上面类似，我完全没必要显式地申明： 123456789101112131415&lt;input :value="value" v-bind="$attrs" v-on="listeners"&gt;computed: &#123; listeners() &#123; return &#123; ...this.$listeners, input: event =&gt; this.$emit('input', event.target.value) &#125; &#125;&#125; $listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过v-on=&quot;$listeners&quot;传入内部组件——在创建更高层次的组件时非常有用。 3.需要注意的是，由于我们input并不是BaseInput这个组件的根节点，而默认情况下父作用域的不被认作 props 的特性绑定将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。所以我们需要设置inheritAttrs:false，这些默认行为将会被去掉, 以上两点的优化才能成功。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>watchers</tag>
        <tag>render</tag>
        <tag>高阶组件</tag>
        <tag>组件注册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析JS中的堆内存与栈内存]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%B5%85%E6%9E%90JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8E%E6%A0%88%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[引言最近看到这样一个问题 Q：说说var、let、const的区别A：balabalabalabla…Q：const定义的值能改么？A：你逗我？不能吧 不知道各位看官怎么想？答案是部分能改，部分不能改。const定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。如， 12345678910111213141516&gt;&gt;&gt; const a = 1&gt;&gt;&gt; a&lt;&lt;&lt; 1&gt;&gt;&gt; a = 2&lt;&lt;&lt; VM1750:1 Uncaught TypeError: Assignment to constant variable. at &lt;anonymous&gt;:1:3 (anonymous) @ VM1750:1&gt;&gt;&gt; const b = &#123;&#125;&gt;&gt;&gt; b&lt;&lt;&lt; &#123;&#125;&gt;&gt;&gt; b.name = 1&gt;&gt;&gt; b&lt;&lt;&lt; &#123;name: 1&#125;&gt;&gt;&gt; b = &#123;&#125;&lt;&lt;&lt; VM1785:1 Uncaught TypeError: Assignment to constant variable. at &lt;anonymous&gt;:1:4 const不是定义常量么？为什么还能改？这就是我们今天要说的重点～ JS中的堆内存与栈内存在JS引擎中对变量的存储主要有两种位置，堆内存和栈内存。 和Java中对内存的处理类似，栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null，以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。 而堆内存主要负责像对象Object这种变量类型的存储，如下图 栈内存中的变量一般都是已知大小或者有范围上限的，算作一种简单存储。而堆内存存储的对象类型数据对于大小这方面，一般都是未知的。个人认为，这也是为什么null作为一个object类型的变量却存储在栈内存中的原因。 因此当我们定义一个const对象的时候，我们说的常量其实是指针，就是const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。而对于const定义的基础变量而言，这个值就相当于const对象的指针，是不可变。 既然知道了const在内存中的存储，那么const、let定义的变量不能二次定义的流程也就比较容易猜出来了，每次使用const或者let去初始化一个变量的时候，会首先遍历当前的内存栈，看看有没有重名变量，有的话就返回错误。 说到这里，有一个十分很容易忽略的点，之前也是自己一直没有注意的就是，使用new关键字初始化的之后是不存储在栈内存中的。为什么呢？new大家都知道，根据构造函数生成新实例，这个时候生成的是对象，而不是基本类型。再看一个例子 1234567var a = new String('123')var b = String('123')var c = '123'console.log(a==b, a===b, b==c, b===c, a==c, a===c) &gt;&gt;&gt; true false true true true falseconsole.log(typeof a)&gt;&gt;&gt; 'object' 我们可以看到new一个String，出来的是对象，而直接字面量赋值和工厂模式出来的都是字符串。但是根据我们上面的分析大小相对固定可预期的即便是对象也可以存储在栈内存的，比如null，为啥这个不是呢？再继续看 1234var a = new String('123')var b = new String('123')console.log(a==b, a===b)&gt;&gt;&gt; false false 很明显，如果a，b是存储在栈内存中的话，两者应该是明显相等的，就像null === null是true一样，但结果两者并不相等，说明两者都是存储在堆内存中的，指针指向不一致。 说到这里，再去想一想我们常说的值类型和引用类型其实说的就是栈内存变量和堆内存变量，再想想值传递和引用传递、深拷贝和浅拷贝，都是围绕堆栈内存展开的，一个是处理值，一个是处理指针。 内存分配和垃圾回收一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>let</tag>
        <tag>const</tag>
        <tag>堆内存</tag>
        <tag>栈内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等你下课 周杰伦&&李健]]></title>
    <url>%2F2018%2F07%2F13%2F%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%20Cover%E6%9D%8E%E5%81%A5%2F</url>
    <content type="text"><![CDATA[周杰伦古筝，李健翻唱等你下课 为了方便放到此博客里，自己录制的1080p原版视频： 李健看完词本人os:“高中三年 你为什么 为什么不好好读书 没考上跟我一样的大学？？？ 这两天一直在单曲循环这首歌，杰伦的厉害之处，他现在唱情歌不用再像是最长的电影和退后那样撕心裂肺，而只是坐在台阶上轻松地刷着和弦，随口而出的是直白的歌词，就像当年的简单爱和彩虹，就很能引起听歌者的共鸣。这首《等你下课》虽然前两遍听的时候觉得词也写得太简单了些，但也就像是杰伦说的那样，也算是地方民谣吧，所以讲得也比较生活化，其实也是很贴近现在我们这年轻一代的心路历程了，就有很多的遗憾，以及对过去多多少少的后悔。 而李健也不愧是清华毕业的，虽然是个工科生，但身上自带的那种文人的气息也是十分浓厚，原版高中不好好读书的歌词也确实不适合他，他改完之后的整首歌就有种洒脱的感觉，也算是对过去的潇洒放手。另外，李健的声音真的让人很舒服，非常清新。能够听到喜欢的两位歌手的合作，对于我来说也是十分开心了。 虽然不看这个节目，但听说有好听的歌也还是会去听一下的，而这张图就很好笑了😂 存一下谱子,有时间可以练一下]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>music</tag>
        <tag>guitar</tag>
        <tag>周杰伦</tag>
        <tag>李健</tag>
        <tag>等你下课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PUBG For 104]]></title>
    <url>%2F2018%2F06%2F30%2FPUBG%20For%20104%2F</url>
    <content type="text"><![CDATA[这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与本人联系。This is an encrypted article, the content may be personal emotional catharsis or charging technology. If you really want to see it, please contact me. 📩📩📩a38b0462f26067be6ab4506a842af4178a52cbe4b601a16b50ab0bfaf0fd258c17f92aeaef4ffde5079c1750397eea1315eb7620f9ef0efeda7ad143acadbfb20f2530f581ae855baab5c5d86100c9b322ccf9cb96815bc18f45c5c3ab7c275ce3ac9a035ae6642c05f1b2747133b657a58f75d06db46b14be6770da394eaf7b0b5f8429b71b71fcedb9c6ed5ac86c7b9e594bbc5f40c129dd1489683ffff0a5e0a32a9042fea589fe6106fb43596a75120d67ba92b8b632fb26be4f31ab0800dc1f80f37b2fb4de7ca45ce775b5feffcd1b023b1ea938d167a3d23589509976f654a7e39e750f463848991b7bd4b50977e3e43ca10bab438b42b172198e82337cb9a372a2752f483cce9caafc70b4bad3f9e07131daf57a20020a4cf53d808b060e1a945a3393b0575ab72488adf35af761952fd334ba6cd0be89ddc3adf807e8500f582660b9f6e696de6097dded6ab2b84480812e84a8af6d5accd45bfd99]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>graduation</tag>
        <tag>pubg</tag>
        <tag>104</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各位，江湖再见了！]]></title>
    <url>%2F2018%2F06%2F22%2F%E5%90%84%E4%BD%8D%EF%BC%8C%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与本人联系。This is an encrypted article, the content may be personal emotional catharsis or charging technology. If you really want to see it, please contact me. 📩📩📩a38b0462f26067be6ab4506a842af4178a52cbe4b601a16b50ab0bfaf0fd258c17f92aeaef4ffde5079c1750397eea1315eb7620f9ef0efeda7ad143acadbfb20f2530f581ae855baab5c5d86100c9b322ccf9cb96815bc18f45c5c3ab7c275ce3ac9a035ae6642c05f1b2747133b657a58f75d06db46b14be6770da394eaf7b0b5f8429b71b71fcedb9c6ed5ac86c7b9e594bbc5f40c129dd1489683ffff0a5e0a32a9042fea589fe6106fb43596a75120d67ba92b8b632fb26be4f31ab0800dc1f80f37b2fb4de7ca45ce775b5feffcd1b023b1ea938d167a3d23589509976f654a7e39e750f463848991b7bd4b50977e3e43ca10bab438b42b172198e82337cb9a372a2752f483cce9caafc70b4bad3f9e07131daf57a20020a4cf53d808bf0f7edb3bf7c31d66eb354cf7d28707ea45396cb28ea449d3c11f302a80800b85f16d40a6edc91ea2374e37d71d770de8f8d3c5ffedc1a2df354686922b722b5e1c5df547f1da820b5332c7d485470a22dac35d1b5ac9550e1ffc8d992e56a09]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>graduation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structures and Algorithms For Javascript]]></title>
    <url>%2F2018%2F05%2F24%2FData%20Structures%20and%20Algorithms%20For%20Javascript%2F</url>
    <content type="text"><![CDATA[leetcode刷题 Data StructuresString字符串反转 1234567891011121314151617181920212223242526272829303132export default (str) =&gt; &#123; // 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序 let arr = str.split(' ') // 对数组进行遍历，然后每个元素进行反转 let result = arr.map(item =&gt; &#123; return item.split('').reverse().join('') &#125;) return result.join(' ')&#125;export default (str) =&gt; &#123; // 1. 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序 // 2. 对数组进行遍历，然后每个元素进行反转 return str.split(' ').map(item =&gt; &#123; return item.split('').reverse().join('') &#125;).join(' ')&#125;export default (str) =&gt; &#123; return str.split(/\s/g).map(item =&gt; &#123; return item.split('').reverse().join('') &#125;).join(' ')&#125;/** * 对输入进行了限制（空）单词用空格隔开（没见过单词中有&lt;等特殊字符之前考虑的是空格，单引号）(LeetCode测试用例) */export default (str) =&gt; &#123; return str.length ? str.match(/[\S]+/g).map(item =&gt; &#123; return item.split('').reverse().join('') &#125;).join(' ') : ''&#125; API：String.prototype.splitString.prototype.matchArray.prototype.mapArray.prototype.reverseArray.prototype.join 计数二进制子串 难度稍大的算法题目如何解？ 算法的本质是寻找规律并实现 如何找到规律？ 发现输入和输出之间的关系，寻找突破点 复杂的实现怎么办？ 实现是程序+数据结构的结合体 123456789101112131415161718192021222324// 关于 LeetCode 测试用例字符串过长导致 RegExp too big的问题暂时不予修复export default (str) =&gt; &#123; // 建立数据结构，堆栈，保存数据 let r = [] // 给定任意子输入都返回第一个符合条件的子串 let match = (str) =&gt; &#123; let j = str.match(/^(0+|1+)/)[0] let o = (j[0] ^ 1).toString().repeat(j.length) let reg = new RegExp(`^($&#123;j&#125;$&#123;o&#125;)`) if (reg.test(str)) &#123; return RegExp.$1 &#125; else &#123; return '' &#125; &#125; // 通过for循环控制程序运行的流程 for (let i = 0, len = str.length - 1; i &lt; len; i++) &#123; let sub = match(str.slice(i)) if (sub) &#123; r.push(sub) &#125; &#125; return r&#125; Array电话号码的组合（ 公式运算） 思路： 1234567891011121314151617181920212223242526272829303132333435export default (str) =&gt; &#123; // 对输入做处理，如果小于1返回空（LeetCode测试用例） if (str.length &lt; 1) return [] // 建立电话号码键盘映射 let map = ['', 1, 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'] // 如果只给了一个按键，直接把按键内容取出来并按单个字符分组就可以了（LeetCode测试用例） if (str.length &lt; 2) return map[str].split('') // 把输入字符串按单字符分隔变成数组，234=&gt;[2,3,4] let num = str.split('') // 保存键盘映射后的字母内容，如 23=&gt;['abc','def'] let code = [] num.forEach(item =&gt; &#123; if (map[item]) &#123; code.push(map[item]) &#125; &#125;) let comb = (arr) =&gt; &#123; // 临时变量用来保存前两个组合的结果 let tmp = [] // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素 for (let i = 0, il = arr[0].length; i &lt; il; i++) &#123; for (let j = 0, jl = arr[1].length; j &lt; jl; j++) &#123; tmp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`) &#125; &#125; arr.splice(0, 2, tmp) if (arr.length &gt; 1) &#123; comb(arr) &#125; else &#123; return tmp &#125; return arr[0] &#125; return comb(code)&#125; 卡牌分组（归类运算） 1234567891011121314151617181920212223242526272829303132export default (arr) =&gt; &#123; // 存储每张卡牌的总数 // 修改排序的方式修改为直接统计每个相同字符的数量，思路不变（LeetCode测试用例） let group = [] let tmp = &#123;&#125; arr.forEach(item =&gt; &#123; tmp[item] = tmp[item] ? tmp[item] + 1 : 1 &#125;) for (let v of Object.values(tmp)) &#123; group.push(v) &#125; // 此时group已经存放的是每张牌的总数了（数组只遍历一遍，避免了排序和正则的耗时） // 求两个数的最大公约数 let gcd = (a, b) =&gt; &#123; if (b === 0) &#123; return a &#125; else &#123; return gcd(b, a % b) &#125; &#125; while (group.length &gt; 1) &#123; let a = group.shift() let b = group.shift() let v = gcd(a, b) if (v === 1) &#123; return false &#125; else &#123; group.unshift(v) &#125; &#125; return group.length ? group[0] &gt; 1 : false&#125; let max = Number.MAX_SAFE_INTEGER // 当前浏览器环境下支持的最大整数 dist.push([].concat(tmp)) //tmp数组为引用类型，可以用空数组concat来创建新的内存空间 清空数组最好用tmp.length = 0 而不是 tmp = [] dist.every() &amp;&amp; dist.forEach() 区别在于every()可以break 找到一个不符合就跳出循环，否则将继续执行 种花问题（筛选运算） 123456789101112131415161718export default (arr, n) =&gt; &#123; // 计数器 let max = 0 // 右边界补充[0,0,0],最后一块地能不能种只取决于前面的是不是1，所以默认最后一块地的右侧是0（无须考虑右侧边界有阻碍）（LeetCode测试用例） arr.push(0) for (let i = 0, len = arr.length - 1; i &lt; len; i++) &#123; if (arr[i] === 0) &#123; if (i === 0 &amp;&amp; arr[1] === 0) &#123; max++ i++ &#125; else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123; max++ i++ &#125; &#125; &#125; return max &gt;= n&#125; 抽象问题、数学建模、动态输入 格雷编码（二进制运算） 1234567891011121314151617181920​```javascriptexport default (n) =&gt; &#123; // 递归函数，用来算输入为n的格雷编码序列 let make = (n) =&gt; &#123; if (n === 1) &#123; return ['0', '1'] &#125; else &#123; let prev = make(n - 1) let result = [] let max = Math.pow(2, n) - 1 for (let i = 0, len = prev.length; i &lt; len; i++) &#123; result[i] = `0$&#123;prev[i]&#125;` result[max - i] = `1$&#123;prev[i]&#125;` &#125; return result &#125; &#125; return make(n)&#125;​ 1234567891011121314151617181920212223242526272829303132333435363738## 排序| 排序算法 | 时间复杂度 | 最好情形 | 最坏情形 | 空间复杂度 | 稳定性 | 备注 || :-: | :-: | :-: | :-: | :-: | :-: | :-: || 冒泡排序 | O(n^2) | O(n) | O(n^2) | O(1) | 稳定 | n小时较好 || 快速排序 | O(nlogn) | O(nlogn) | O(n^2) | O(nlogn) | 不稳定 | n大时较好 || 选择排序 | O(n^2) | O(n) | O(n^2) | O(1) | 不稳定 | n小时较好 || 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 | n大时较好 || 插入排序 | O(n^2) | O(n) | O(n^2) | O(1) | 稳定 | 大部分已排序时较好 || 希尔排序 | O(nlogn) | O(n) | O(ns) 1&lt;s&lt;2 | O(1) | 不稳定 | s是所选分组 || 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 | n大时较好 || 基数排序 | O(logRB) | O(logRB) | O(logRB) | O(n) | 稳定 | B是真数(0-9)，R是基数(个十百) |&gt; 稳定的含义是：稳定的排序算法会让原本相等的元素维持相对次序.### 冒泡排序**冒泡排序就是从最开始的位置或结尾的位置反方向对比，如果比它大&#x2F;小,就交换然后继续走，第一遍走完,最后一个位置是最大值或者最小值。（将最大值&#x2F;最小值一步一步不断地冒泡到最后一个位置）**&#96;&#96;&#96;javascriptexport default (arr) &#x3D;&gt; &#123; &#x2F;&#x2F; 冒泡排序 for (let i &#x3D; arr.length - 1, tmp; i &gt; 0; i--) &#123; for (let j &#x3D; 0; j &lt; i; j++) &#123; tmp &#x3D; arr[j] if (tmp &gt; arr[j + 1]) &#123; arr[j] &#x3D; arr[j + 1] arr[j + 1] &#x3D; tmp &#125; &#125; &#125; return arr&#125; 快速排序快排就是一开始找个中介，然后把比它小的放左边，比它大的放右边，然后重新对中介两边的数据各自重新找个中介,如此循环。 123456789101112131415161718192021// 快速排序function quickSort(arr) &#123; if (arr.length &lt;= 1) return arr console.log("原数组是:" + arr); let pivotIndex = Math.floor(arr.length / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; console.log("将中介提取出来后数组是:" + arr); for (let i = 0; i &lt; arr.length; i++) &#123; console.log("此刻中介是:" + pivot + "当前元素是:" + arr[i]); if (arr[i] &lt; pivot) &#123; left.push(arr[i]); console.log("移动" + arr[i] + "到左边"); &#125; else &#123; right.push(arr[i]); console.log("移动" + arr[i] + "到右边"); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125; 选择排序找到数组中最小的那个元素，将它和数组的第一个元素交换位置，如果第一个元素就是最小的那么就和自己交换，然后，在剩下的数组中找到最小的元素，将它和数组的第二个元素交换，循环直到排序完成。 内循环只比较大小，交换代码在内循环之外。每次交换都排定一个元素，交换的总次数为N 123456789101112131415export default (arr) =&gt; &#123; // 选择排序 for (let i = 0, len = arr.length, min; i &lt; len; i++) &#123; min = arr[i] for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; min) &#123; let c = min min = arr[j] arr[j] = c &#125; &#125; arr[i] = min &#125; return arr&#125; 插入排序插入排序它将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。 1234567891011121314151617function insertSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; let temp = arr[i]; let j = i; for (; j &gt; 0; j--) &#123; if (temp &gt;= arr[j - 1]) &#123; break; // 当前考察的数大于前一个数，证明有序，退出循环 &#125; arr[j] = arr[j - 1]; // 将前一个数复制到后一个数上 &#125; arr[j] = temp; // 找到考察的数应处于的位置 &#125; return arr;&#125;// examplelet arr = [2, 5, 10, 7, 1, 0, 10];console.log(insertSort(arr)); 归并排序归并算法的原理是将所有元素拆成相邻的一对一对的,然后两两排序,再将相邻的一对元素再合并排序,四个四个排序,如此循环最后只剩两组大的已经排好序的数组再合并一起排序。 归并排序采用的是分治的思想，首先是“分”，将一个数组反复二分为两个小数组，直到每个数组只有一个元素；其次是“治”，从最小数组开始，两两按大小顺序合并，直到并为原始数组大小，下面是图解： 观察下“治”的过程，可以看出，“治”实际上是将已经有序的数组合并为更大的有序数组。那么怎样将已经有序的数组合并为更大的有序数组？很简单，创建一个临时数组C，比较A[0]，B[0]，将较小值放到C[0]，再比较A[1]与B[0]（或者A[0]，B[1]），将较小值放到C[1]，直到对A，B都遍历一遍。可以看出数组A，B都只需遍历一遍，所以对两个有序数组的排序的时间复杂度为O(n)。 而“分”就是将原始数组逐次二分，直到每个数组只剩一个元素，一个元素的数组自然是有序的，所以就可以开始“治”的过程了。 时间复杂度分析：分的过程需要三步：log8 = 3，而每一步都需要遍历一次8个元素，所以8个元素共需要运行 8log8)次指令，那么对于 n 个元素，时间复杂度为 O(nlogn)。 1234567891011121314151617181920212223242526272829303132333435363738394041// 融合两个有序数组，这里实际上是将数组 arr 分为两个数组function mergeArray(arr, first, mid, last, temp) &#123; let i = first; let m = mid; let j = mid + 1; let n = last; let k = 0; while (i &lt;= m &amp;&amp; j &lt;= n) &#123; if (arr[i] &lt; arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; while (i &lt;= m) &#123; temp[k++] = arr[i++]; &#125; while (j &lt;= n) &#123; temp[k++] = arr[j++]; &#125; for (let l = 0; l &lt; k; l++) &#123; arr[first + l] = temp[l]; &#125; return arr;&#125;// 递归实现归并排序function mergeSort(arr, first, last, temp) &#123; if (first &lt; last) &#123; let mid = Math.floor((first + last) / 2); mergeSort(arr, first, mid, temp); // 左子数组有序 mergeSort(arr, mid + 1, last, temp); // 右子数组有序 arr = mergeArray(arr, first, mid, last, temp); &#125; return arr;&#125;// examplelet arr = [10, 3, 1, 5, 11, 2, 0, 6, 3];let temp = new Array();let SortedArr = mergeSort(arr, 0, arr.length - 1, temp);console.log(SortedArr); 递归复原IP地址 1234567891011121314151617181920212223242526export default (str) =&gt; &#123; // 保存所有符合条件的IP地址 let r = [] // 分四步递归处理ip分段 let search = (cur, sub) =&gt; &#123; // 非法输入过滤，LeetCode测试用例(111111111111111111111111111111111111111111111111111111111111) if (sub.length &gt; 12) &#123; return &#125; // 边界条件 if (cur.length === 4 &amp;&amp; cur.join('') === str) &#123; r.push(cur.join('.')) &#125; else &#123; // 正常的处理过程 for (let i = 0, len = Math.min(3, sub.length), tmp; i &lt; len; i++) &#123; tmp = sub.substr(0, i + 1) if (tmp - 256 &lt; 0) &#123; // 转换下数据类型，如 01为1（LeetCode测试用例） search(cur.concat([tmp * 1]), sub.substr(i + 1)) &#125; &#125; &#125; &#125; search([], str) return r&#125; 与所有单词相关联的字符串 123456789101112131415161718192021222324// exp1.jsexport default (str, words) =&gt; &#123; // 保存结果 let result = [] // 记录数组的长度，做边界条件计算 let num = words.length // 递归函数体 let range = (r, _arr) =&gt; &#123; if (r.length === num) &#123; result.push(r) &#125; else &#123; _arr.forEach((item, idx) =&gt; &#123; let tmp = [].concat(_arr) tmp.splice(idx, 1) range(r.concat(item), tmp) &#125;) &#125; &#125; range([], words) // [0, 9, -1] filter 之后[0,9] return result.map(item =&gt; &#123; return str.indexOf(item.join('')) &#125;).filter(item =&gt; item !== -1).sort()&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* exp1.js 的算法是根据利用组合思想解决这个问题的，这个思想简单易于学习。缺点是当数据量大的时候组合数太多导致效率变低。 exp2.js 的算法是利用查找每个单词在字符串的位置，然后通过计算这些位置是不是连续的。 比如 abforbarcd,[for,bar]，那么for的起始位置是2,bar的起始位置是5;说明这两个单词是连续的2+3(for的长度)=5 for:[&#123;start:2,end:5&#125;] bar:[&#123;start:5,end:8&#125;] 判断上一个单词的end和下一个单词的start是不是相同来计算两个单词是不是挨着 */export default (str, words) =&gt; &#123; // 计算字符串的总长度 let strLen = str.length // 计算所有的单词数量 let wordsLen = words.length // 计算所有单词出现的起始位置和截止位置 let pos = &#123;&#125; // 如果字符串的长度小于所有单词的总长度直接返回 if (strLen &lt; words.join('').length) &#123; return [] &#125; // 遍历所有单词查找在字符串中的起始位置和截止位置 words.every(word =&gt; &#123; if (pos[word]) &#123; return true &#125; let wl = word.length let tmp = [] for (let i = 0, len = strLen - wl, idx; i &lt;= len; i++) &#123; idx = str.slice(i).indexOf(word) if (idx &gt; -1) &#123; if (idx === 0) &#123; tmp.push(&#123; start: i, end: i + wl &#125;) &#125; else if (str[i + 1] !== word[0]) &#123; i += idx - 1 &#125; &#125; else &#123; break &#125; &#125; // 如果没有匹配到单词终止遍历 if (tmp[0] === undefined) &#123; return false &#125; else &#123; // 保存当前单词的位置，遍历下一个单词 pos[word] = tmp.sort((a, b) =&gt; a.start - b.start) return true &#125; &#125;) // 只要有一个单词没找到说明不能匹配到连续的字符串 if (words.find(item =&gt; !pos[item])) &#123; return [] &#125; let result = [] // 计算所有单词的位置 let match = (poses) =&gt; &#123; // 记录是不是所有单词都被匹配到了，每一次都应该把所有单词都包括进来并且是相邻的 let record = [] let len = Object.keys(poses).length // 如果没有单词的位置说明处理结束了 if (len &lt; 1) &#123; return -1 &#125; while (1) &#123; // 每次循环应该把记录清空 record.length = 0 // 按照起始位置进行升序排序 let minV = Number.MAX_SAFE_INTEGER let minK = '' // 优先找到所有单词其实位置最小的单词开始匹配 for (let [k, v] of Object.entries(poses)) &#123; if (!v.length) &#123; return false &#125; else &#123; if (v[0].start &lt; minV) &#123; minK = k minV = v[0].start &#125; &#125; &#125; if (!minK) &#123; return false &#125; // 起始位置最小的单词 let first = poses[minK].shift() if (!first) &#123; return false &#125; // 记录下这个起始位置 let start = first.start // 记录words列表中的单词 record.push(words.findIndex(item =&gt; item === minK)) // 每次循环要匹配到所有单词 for (let i = 1; i &lt; wordsLen; i++) &#123; for (let j = 0, next; j &lt; wordsLen; j++) &#123; if (record.includes(j)) &#123; continue &#125; if (poses[words[j]][0] === undefined) &#123; return false &#125; next = poses[words[j]].find(item =&gt; item.start === first.end) if (next) &#123; record.push(j) first = next break &#125; &#125; &#125; // 如果所有单词的顺序是挨着的，记录下当前的起始位置 if (record.length === wordsLen &amp;&amp; !record.find(item =&gt; item === undefined)) &#123; result.push(start) &#125; &#125; &#125; match(pos) // 对 result 去重，如 result=[1,1,2,3] [...new Set(result)]===[1,2,3] return [...new Set(result)]&#125; 数据结构栈堆队列链表矩阵二叉树进阶算法贪心算法​ 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。） 所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。 买卖股票的最佳时机 II 策略1：从最低点买入，在最高点卖出（追求单次利益） 策略2：从低点买入，只要可以赚钱就卖出，不断买卖（追求多次利益，但单次利益不够） 策略3：从低点买入，到下一个价格的高点卖出，不断买卖（在保证单次利益的基础上，实现多次交易） 12345678910111213141516export default (prices) =&gt; &#123; // 用来保存利润 let count = 0 for (let i = 0, len = prices.length; i &lt; len; i++) &#123; for (let j = i; j &lt; len - 1; j++) &#123; if (prices[j + 1] &gt; prices[j]) &#123; count += prices[j + 1] - prices[j] i = j &#125; else &#123; i = j break &#125; &#125; &#125; return count&#125; 柠檬水找零 策略1：给钱找零，不区分金额知道找到足够的零钱（追求单词找零） 策略2：给钱找零，优先找给金额大的零钱，尽量把零钱放在手里 12345678910111213141516171819202122232425262728293031323334353637export default (input) =&gt; &#123; // 表示自己的钱箱（用于存储零钱） let hand = [] // 判断是否有顾客还在 while (input.length) &#123; // 取出当前排在最前面顾客的钱 let money = input.shift() // 这种情况不需要找零 if (money === 5) &#123; hand.push(money) &#125; else &#123; // 手里的零钱要降序排列也就说最大的面值的钱放在最前面 hand.sort((a, b) =&gt; b - a) // 顾客的钱减去饮料的钱就是需要找给顾客的零钱 let change = money - 5 for (let i = 0, len = hand.length; i &lt; len; i++) &#123; if (hand[i] &lt;= change) &#123; change -= hand[i] hand.splice(i, 1) // 删除了元素，数组的长度发生了变化，要维持刚才的i不变 i-- &#125; if (change === 0) &#123; break &#125; &#125; // 没有足够的零钱找给顾客 if (change !== 0) &#123; return false &#125; else &#123; // 顾客的钱存起来 hand.push(money) &#125; &#125; &#125; return true&#125; 动态规划 ​ 动态规划包括三个重要概念：状态转移方程、最优子结构、边界 不同路径 II ​ 解析：由于最后一步肯定是在终点的上面或者是左边，所以由此可推断出状态转移方程： 12345678910111213141516171819202122232425export default (arr, m, n) =&gt; &#123; let dp = (m, n) =&gt; &#123; // 检查起始或者目标元素是不是1（被占用了），如果起始或者最后那个格就是1，说明怎么都怎么不到那，直接返回0 if (arr[m - 1][n - 1] === 1 || arr[0][0] === 1) &#123; return 0 &#125; if (m === 2 &amp;&amp; n === 2) &#123; return (arr[1][1] === 1 || arr[1][0] + arr[0][1] === 2) ? 0 : (arr[1][0] === 1 || arr[0][1] === 1) ? 1 : 2 &#125; else if (m &lt; 2 || n &lt; 2) &#123; // 单行或者单列 if (m &lt; 2) &#123; //单行 return arr[m - 1].includes(1) ? 0 : 1 &#125; else &#123; // 单列 for (let i = 0; i &lt; m; i++) &#123; if (arr[i][0] === 1) &#123; return 0 &#125; &#125; return 1 &#125; &#125; else &#123; return dp(m - 1, n) + dp(m, n - 1) &#125; &#125; return dp(m, n)&#125; K站中转内最便宜的航班（最短路径） 12345678910111213141516171819export default (fights, src, dst, k) =&gt; &#123; // 将fights作为参数和LeetCode一致 let cheap = (fights, src, dst, k) =&gt; &#123; let prev = fights.filter(item =&gt; item[1] === dst) let min = Math.min.apply(null, prev.map(item =&gt; &#123; if (item[0] === src &amp;&amp; k &gt; -1) &#123; return item[2] &#125; else if (k === 0 &amp;&amp; item[0] !== src) &#123; return Number.MAX_SAFE_INTEGER &#125; else &#123; return item[2] + cheap(fights, src, item[0], k - 1) &#125; &#125;)) return min &#125; // 增加返回值是不是Number.MAX_SAFE_INTEGER，如果是返回-1 let min = cheap(fights, src, dst, k) return min &gt;= Number.MAX_SAFE_INTEGER ? -1 : min&#125;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>leetcode</tag>
        <tag>coding</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0搭建旅游网站开发笔记]]></title>
    <url>%2F2018%2F03%2F14%2FVue2.0%E6%90%AD%E5%BB%BA%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Info: Vue开发旅游网站笔记整理 前言这是最近使用Vue写的仿去哪儿网旅游网站，大致实现了网站首页Header制作、首页轮播、图标区块、热销推荐、使用axios获取接口数据、首页父子组件间的传递、城市选择页面路由配置、搜索框布局、better-scroll的使用及字母表布局、搜索的逻辑实现、Vuex实现数据共享、LocalStorage实现页面数据持久存储、使用keep-alive优化路由页面性能、动态路由配置及banner布局、公用画廊组件的拆分、渐隐渐显的header效果实现、递归组件实现详情列表、画廊动画效果封装等实用性网站功能。 在此要十分感谢Vue框架的作者Evan You，这种渐进式的开发方式的确十分的友好，也让人深刻地领会到组件化开发所带来的便捷之处。 而本篇文章是作为整个项目开发时的一些记录，以便日后完善或者重构代码时能够更加清晰。 项目源码：https://github.com/1996szw/TravelWeb 使用方式： 1234567891011# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report 项目代码初始化配置移动端的&lt;meta&gt;标签12&lt;!-- 设置移动端屏幕比例不可缩放 --&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; 引入reset.css在不同的移动设备上，浏览器的初始样式表是不统一的。所以需要引入reset.css来进行统一化，之后在项目入口文件main.js中引用该样式表：import &#39;styles/reset.css&#39; 1234567891011121314151617181920212223242526/* 重置样式表reset.css */@charset "utf-8";html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,"Hiragino Sans GB",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,"Hiragino Sans GB","微软雅黑",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:"\0020"&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, "Microsoft Yahei", "Helvetica Neue", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125; 解决移动设备中的一像素边框问题有的移动设备分辨率比较高是一个二倍屏或是三倍屏，所以在写1像素边框的时候，写的是1px但实际渲染出来却是2px或是3px。所以需要引入一个1像素边框的解决方案:import &#39;styles/border.css&#39; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/* 1像素边框的解决方案border.css *//* 该代码解决方式是css中的scale */@charset "utf-8";.border,.border-top,.border-right,.border-bottom,.border-left,.border-topbottom,.border-rightleft,.border-topleft,.border-rightbottom,.border-topright,.border-bottomleft &#123; position: relative;&#125;.border::before,.border-top::before,.border-right::before,.border-bottom::before,.border-left::before,.border-topbottom::before,.border-topbottom::after,.border-rightleft::before,.border-rightleft::after,.border-topleft::before,.border-topleft::after,.border-rightbottom::before,.border-rightbottom::after,.border-topright::before,.border-topright::after,.border-bottomleft::before,.border-bottomleft::after &#123; content: "\0020"; overflow: hidden; position: absolute;&#125;/* border * 因，边框是由伪元素区域遮盖在父级 * 故，子级若有交互，需要对子级设置 * 定位 及 z轴 */.border::before &#123; box-sizing: border-box; top: 0; left: 0; height: 100%; width: 100%; border: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-top::before,.border-bottom::before,.border-topbottom::before,.border-topbottom::after,.border-topleft::before,.border-rightbottom::after,.border-topright::before,.border-bottomleft::before &#123; left: 0; width: 100%; height: 1px;&#125;.border-right::before,.border-left::before,.border-rightleft::before,.border-rightleft::after,.border-topleft::after,.border-rightbottom::before,.border-topright::after,.border-bottomleft::after &#123; top: 0; width: 1px; height: 100%;&#125;.border-top::before,.border-topbottom::before,.border-topleft::before,.border-topright::before &#123; border-top: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-right::before,.border-rightbottom::before,.border-rightleft::before,.border-topright::after &#123; border-right: 1px solid #eaeaea; transform-origin: 100% 0;&#125;.border-bottom::before,.border-topbottom::after,.border-rightbottom::after,.border-bottomleft::before &#123; border-bottom: 1px solid #eaeaea; transform-origin: 0 100%;&#125;.border-left::before,.border-topleft::after,.border-rightleft::after,.border-bottomleft::after &#123; border-left: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-top::before,.border-topbottom::before,.border-topleft::before,.border-topright::before &#123; top: 0;&#125;.border-right::before,.border-rightleft::after,.border-rightbottom::before,.border-topright::after &#123; right: 0;&#125;.border-bottom::before,.border-topbottom::after,.border-rightbottom::after,.border-bottomleft::after &#123; bottom: 0;&#125;.border-left::before,.border-rightleft::before,.border-topleft::after,.border-bottomleft::before &#123; left: 0;&#125;@media (max--moz-device-pixel-ratio: 1.49), (-webkit-max-device-pixel-ratio: 1.49), (max-device-pixel-ratio: 1.49), (max-resolution: 143dpi), (max-resolution: 1.49dppx) &#123; /* 默认值，无需重置 */&#125;@media (min--moz-device-pixel-ratio: 1.5) and (max--moz-device-pixel-ratio: 2.49), (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49), (min-device-pixel-ratio: 1.5) and (max-device-pixel-ratio: 2.49), (min-resolution: 144dpi) and (max-resolution: 239dpi), (min-resolution: 1.5dppx) and (max-resolution: 2.49dppx) &#123; .border::before &#123; width: 200%; height: 200%; transform: scale(.5); &#125; .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before &#123; transform: scaleY(.5); &#125; .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after &#123; transform: scaleX(.5); &#125;&#125;@media (min--moz-device-pixel-ratio: 2.5), (-webkit-min-device-pixel-ratio: 2.5), (min-device-pixel-ratio: 2.5), (min-resolution: 240dpi), (min-resolution: 2.5dppx) &#123; .border::before &#123; width: 300%; height: 300%; transform: scale(.33333); &#125; .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before &#123; transform: scaleY(.33333); &#125; .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after &#123; transform: scaleX(.33333); &#125;&#125; 解决移动端的点击300ms延时的问题在项目中，尤其是移动项目中在某些机型、某些浏览器上使用click事件的时候，这些click事件会延迟300ms才会执行，导致用户体验不佳，所以需要引入fastclick第三方库:npm install fastclick --save，然后在main.js中引用并使用这个库: 123import fastClick from 'fastclick'fastClick.attach(document.body) 网站首页的开发移动项目的开发中使用rem如果设计师给的是二倍屏中的86像素，对应就是一倍屏中的43像素，而reset.css中将html{font-size: 50px}，那么就有：1rem = html font size = 50px。所以43px = .86rem 使用css预处理器stylus中的贯穿式变量如果在样式中某一个颜色代码或者尺寸数字会被经常使用到，那么可以在styles文件夹下写一个varibles.styl文件专门用来存放这些个变量，然后在对应的css中引用：@import &#39;../../../assets/styles/varilbes.styl&#39;。这样写引用太复杂了，所以可以在webpack.base.conf.js中将styles目录设置一个别名: 123456789resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), 'styles': resolve('src/assets/styles'), 'common': resolve('src/common') &#125; &#125;, 使用占位来解决图片还未加载时候高度为0之后会有一个抖动的问题给该图片区域包裹一层&lt;div&gt;标签，然后设置该区块的宽度为100%，而它的高度会根据宽度自动地撑开31.25%: 12345.wrapper overflow hidden width 100% height 0 padding-bottom 31.25% css中的样式穿透当需要设置scoped外其它组件中的元素样式时，需要使用&gt;&gt;&gt;来进行一个样式穿透: 12.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background #fff 使用vue-awesome-swiper来显示icon轮播效果时翻页的算法1234567891011121314// 借助computed计算属性computed: &#123; pages () &#123; const pages = [] this.iconList.forEach((item, index) =&gt; &#123; const page = Math.floor(index / 8) if (!pages[page]) &#123; pages[page] = [] &#125; pages[page].push(item) &#125;) return pages &#125; &#125; 使用css预处理器stylus中的混合书写Mixins提供…占位符来表示由于空间不够而被隐藏的内容，可以使用stylus中将该方法封装成mixins.styl，然后在需要的地方调用：ellipsis() 1234ellipsis() overflow hidden white-space nowrap text-overflow ellipsis 在vue中使用axios1234567891011121314151617181920212223242526import axios from 'axios'methods: &#123; getHomeInfo () &#123; axios.get('/api/index.json?city=' + this.city) .then(this.getHomeInfoSucc) // axios返回的是一个promise对象，所以可以调用.then方法 &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data) &#123; const data = res.data this.swiperList = data.swiperList this.iconList = data.iconList this.recommendList = data.recommendList this.weekendList = data.weekendList &#125; &#125;&#125;mounted () &#123; this.getHomeInfo()&#125;activated () &#123; this.getHomeInfo()&#125; 城市选择页面开发better-scroll的使用better-scroll是iscroll的一个封装，使用起来要更为友好。若要使用这个包，先要用npm安装:npm install better-scroll --save。然后html代码需要符合如下结构： 12345678&lt;div class="wrapper"&gt; &lt;ul class="content"&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- you can put some other DOMs here, it won't affect the scrolling --&gt;&lt;/div&gt; 在上面的代码中，better-scroll应用于外部wrapper容器，滚动部分是content元素。注意，better-scroll只处理容器（wrapper）的第一个子元素（内容）的滚动，这意味着将忽略其他元素。最简单的初始化代码如下： 1234import BScroll from 'beetter-scroll'const wrapper = document.querySelector('wrapper')const scroll = new BScorll(wrapper) better-scroll提供了一个类，其实例化时其第一个参数是普通DOM对象。当然，better-scroll内部会尝试使用querySelector来获取DOM对象，因此initiazation代码也可以如下所示： 123import BScroll from 'better-scroll'const scroll = new BScroll('.wrapper') 获取拖拽动作最后得到的内容并做一个函数节流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class="list"&gt; &lt;ul&gt; &lt;li class="item" v-for="item of letters" :key="item" :ref="item" @click="handleLetterClick" @touchstart.prevent="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd" &gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'CityAlphabet', props: &#123; cities: Object &#125;, data () &#123; return &#123; touchStatus: false, startY: 0, timer: null &#125; &#125;, updated () &#123; this.startY = this.$refs['A'][0].offsetTop &#125;, computed: &#123; letters () &#123; const letters = [] for (let i in this.cities) &#123; letters.push(i) &#125; return letters &#125; &#125;, methods: &#123; handleLetterClick (e) &#123; this.$emit('change', e.target.innerText) &#125;, handleTouchStart () &#123; this.touchStatus = true &#125;, handleTouchMove (e) &#123; if (this.touchStatus) &#123; if (this.timer) &#123; // 函数节流 clearTimeout(this.timer) &#125; this.timer = setTimeout(() =&gt; &#123; const touchY = e.touches[0].clientY - 75 const index = Math.floor((touchY - this.startY) / 18) if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]) &#125; &#125;, 16) &#125; &#125;, handleTouchEnd () &#123; this.touchStatus = false &#125; &#125;&#125;&lt;/script&gt; 详情页面的开发动态路由&lt;router-link&gt;标签的to前面可以跟一个:来作一个动态路由，这样就可以传递出一个参数给router。调用这个参数可以通过this.$router.params.id 12345678910111213141516&lt;ul&gt; &lt;router-link tag="li" class="item border-bottom" v-for="item of recommendList" :key="item.id" :to="'/detail/' + item.id" &gt; &lt;img class="item-img" :src="item.imgUrl" /&gt; &lt;div class="item-info"&gt; &lt;p class="item-title"&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;p class="item-desc"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt; &lt;button class="item-btn"&gt;查看详情&lt;/button&gt; &lt;/div&gt; &lt;/router-link&gt;&lt;/ul&gt; 给DOM元素添加一个渐变的边框12.banner-info background-image linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, .5)) 实现顶部Header区域拖动渐隐渐现效果如果通过给window对象绑定一个全局事件的方式来实现某个功能，那么要记得及时地对这个全局事件进行一个解绑，否则就会影响外部组件。 12345678910111213141516171819202122232425262728name: 'DetailHeader',data () &#123; return &#123; showAbs: true, opacityStyle: &#123; opacity: 0 &#125; &#125;&#125;,methods: &#123; handleScroll () &#123; const top = document.documentElement.scrollTop if (top &gt; 60) &#123; let countOpacity = top / 140 countOpacity = countOpacity &gt; 1 ? 1 : countOpacity this.opacityStyle.opacity = countOpacity this.showAbs = false &#125; else &#123; this.showAbs = true &#125; &#125;&#125;,activated () &#123; window.addEventListener('scroll', this.handleScroll)&#125;,deactivated () &#123; // 使用deactivated来对全局事件进行解绑，当退出这个页面时，此函数会被执行 window.removeEventListener('scroll', this.handleScroll)&#125; 递归组件在组件模板中调用组件的自身就叫做递归组件。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;div class="item" v-for="(item, index) of list" :key="index"&gt; &lt;div class="item-title border-bottom"&gt; &lt;span class="item-title-icon"&gt;&lt;/span&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;div v-if="item.children" class="item-children"&gt; &lt;detail-list :list="item.children"&gt;&lt;/detail-list&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'DetailList', data: &#123; list: [ &#123; title: '我是一级标题', children: [&#123; title: '我是二级标题', children: [&#123; title: '我是三级标题' &#125;] &#125;] &#125;, &#123; title: '我是一级标题', children: [ &#123; title: '我是二级标题' &#125; ] &#125;, &#123; title: '我是一级标题' &#125; ]&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>travelweb</tag>
        <tag>vue-awesome-swiper</tag>
        <tag>axios</tag>
        <tag>better-scroll</tag>
        <tag>vuex</tag>
        <tag>localstorge</tag>
        <tag>keep-alive</tag>
        <tag>vue-router</tag>
        <tag>动态路由</tag>
        <tag>父子组件间传递数据</tag>
        <tag>递归组建</tag>
        <tag>移动开发</tag>
        <tag>reset.css</tag>
        <tag>1像素边框</tag>
        <tag>300ms点击延时</tag>
        <tag>rem</tag>
        <tag>stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【毕设】数据挖掘算法之Apriori关联规则挖掘]]></title>
    <url>%2F2018%2F01%2F12%2F%E3%80%90%E6%AF%95%E8%AE%BE%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95%E4%B9%8BApriori%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[Info: Apriori关联规则算法学习 关联分析关联分析是一种在大规模数据集中寻找有趣关系的任务。这些关系可以有两种形式: 频繁项集（frequent item sets）: 经常出现在一块的物品的集合。 关联规则（associational rules）: 暗示两种物品之间可能存在很强的关系。 相关术语 关联分析（关联规则学习): 从大规模数据集中寻找物品间的隐含关系被称作 关联分析(associati analysis) 或者 关联规则学习（association rule learning） 。 下面是用一个 杂货店 例子来说明这两个概念，如下图所示: 频繁项集: {葡萄酒, 尿布, 豆奶} 就是一个频繁项集的例子。 关联规则: 尿布 -&gt; 葡萄酒 就是一个关联规则。这意味着如果顾客买了尿布，那么他很可能会买葡萄酒。 那么 频繁 的定义是什么呢？怎么样才算频繁呢？度量它们的方法有很多种，这里我们来简单的介绍下支持度和置信度。 支持度: 数据集中包含该项集的记录所占的比例。例如上图中，{豆奶} 的支持度为 4/5。{豆奶, 尿布} 的支持度为 3/5。 置信度: 针对一条诸如 {尿布} -&gt; {葡萄酒} 这样具体的关联规则来定义的。这条规则的 置信度 被定义为 支持度({尿布, 葡萄酒})/支持度({尿布})，从图中可以看出 支持度({尿布, 葡萄酒}) = 3/5，支持度({尿布}) = 4/5，所以 {尿布} -&gt; {葡萄酒} 的置信度 = 3/5 / 4/5 = 3/4 = 0.75。 支持度 和 置信度 是用来量化 关联分析 是否成功的一个方法。假设想找到支持度大于 0.8 的所有项集，应该如何去做呢？一个办法是生成一个物品所有可能组合的清单，然后对每一种组合统计它出现的频繁程度，但是当物品成千上万时，上述做法就非常非常慢了。我们需要详细分析下这种情况并讨论下 Apriori 原理，该原理会减少关联规则学习时所需的计算量。 Apriori 原理假设我们一共有 4 个商品: 商品0, 商品1, 商品2, 商品3。所有可能的情况如下:如果我们计算所有组合的支持度，也需要计算 15 次。即 2^N - 1 = 2^4 - 1 = 15。随着物品的增加，计算的次数呈指数的形式增长 … 为了降低计算次数和时间，研究人员发现了一种所谓的 Apriori 原理，即某个项集是频繁的，那么它的所有子集也是频繁的。例如，如果 {0, 1} 是频繁的，那么 {0}, {1} 也是频繁的。 该原理直观上没有什么帮助，但是如果反过来看就有用了，也就是说如果一个项集是 非频繁项集，那么它的所有超集也是非频繁项集，如下图所示: 在图中我们可以看到，已知灰色部分 {2,3} 是 非频繁项集，那么利用上面的知识，我们就可以知道 {0,2,3} {1,2,3} {0,1,2,3} 都是 非频繁的。也就是说，计算出 {2,3} 的支持度，知道它是 非频繁 的之后，就不需要再计算 {0,2,3} {1,2,3} {0,1,2,3} 的支持度，因为我们知道这些集合不会满足我们的要求。使用该原理就可以避免项集数目的指数增长，从而在合理的时间内计算出频繁项集。 Apriori 算法优缺点 123* 优点：易编码实现* 缺点：在大数据集上可能较慢* 适用数据类型：数值型 或者标准型数据。 Apriori 算法流程步骤： 123456* 收集数据：使用任意方法。* 准备数据：任何数据类型都可以，因为我们只保存集合。* 分析数据：使用任意方法。* 训练数据：使用Apiori算法来找到频繁项集。* 测试算法：不需要测试过程。* 使用算法：用于发现频繁项集以及物品之间的关联规则。 Apriori 算法的使用前面提到，关联分析的目标包括两项: 发现 频繁项集 和发现 关联规则。首先需要找到 频繁项集，然后才能发现 关联规则。Apriori 算法是发现 频繁项集 的一种方法。Apriori 算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个物品的项集列表。接着扫描交易记录来查看哪些项集满足最小支持度要求，那些不满足最小支持度要求的集合会被去掉。然后对生下来的集合进行组合以生成包含两个元素的项集。接下来再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集被去掉。 生成候选项集下面会创建一个用于构建初始集合的函数，也会创建一个通过扫描数据集以寻找交易记录子集的函数，数据扫描的伪代码如下: 对数据集中的每条交易记录 tran 对每个候选项集 can 检查一下 can 是否是 tran 的子集: 如果是则增加 can 的计数值 对每个候选项集 can 如果其支持度不低于最小值，则保留该项集 返回所有频繁项集列表 以下是一些辅助函数。 加载数据集123# 加载数据集def loadDataSet(): return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]] 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset1234567891011121314151617181920212223# 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozensetdef createC1(dataSet): """createC1（创建集合 C1） Args: dataSet 原始数据集 Returns: frozenset 返回一个 frozenset 格式的 list """ C1 = [] for transaction in dataSet: for item in transaction: if not [item] in C1: # 遍历所有的元素，如果不在 C1 出现过，那么就 append C1.append([item]) # 对数组进行 `从小到大` 的排序 print 'sort 前=', C1 C1.sort() # frozenset 表示冻结的 set 集合，元素无改变；可以把它当字典的 key 来使用 print 'sort 后=', C1 print 'frozenset=', map(frozenset, C1) return map(frozenset, C1) 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据1234567891011121314151617181920212223242526272829303132333435# 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据def scanD(D, Ck, minSupport): """scanD（计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度 minSupport 的数据） Args: D 数据集 Ck 候选项集列表 minSupport 最小支持度 Returns: retList 支持度大于 minSupport 的集合 supportData 候选项集支持度数据 """ # ssCnt 临时存放选数据集 Ck 的频率. 例如: a-&gt;10, b-&gt;5, c-&gt;8 ssCnt = &#123;&#125; for tid in D: for can in Ck: # s.issubset(t) 测试是否 s 中的每一个元素都在 t 中 if can.issubset(tid): if not ssCnt.has_key(can): ssCnt[can] = 1 else: ssCnt[can] += 1 numItems = float(len(D)) # 数据集 D 的数量 retList = [] supportData = &#123;&#125; for key in ssCnt: # 支持度 = 候选项（key）出现的次数 / 所有数据集的数量 support = ssCnt[key]/numItems if support &gt;= minSupport: # 在 retList 的首位插入元素，只存储支持度满足频繁项集的值 retList.insert(0, key) # 存储所有的候选项（key）和对应的支持度（support） supportData[key] = support return retList, supportData 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 组织完整的 Apriori 算法输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ck12345678910111213141516171819202122232425262728293031# 输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ckdef aprioriGen(Lk, k): """aprioriGen（输入频繁项集列表 Lk 与返回的元素个数 k，然后输出候选项集 Ck。 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; 仅需要计算一次，不需要将所有的结果计算出来，然后进行去重操作 这是一个更高效的算法） Args: Lk 频繁项集列表 k 返回的项集元素个数（若元素的前 k-2 相同，就进行合并） Returns: retList 元素两两合并的数据集 """ retList = [] lenLk = len(Lk) for i in range(lenLk): for j in range(i+1, lenLk): L1 = list(Lk[i])[: k-2] L2 = list(Lk[j])[: k-2] # print '-----i=', i, k-2, Lk, Lk[i], list(Lk[i])[: k-2] # print '-----j=', j, k-2, Lk, Lk[j], list(Lk[j])[: k-2] L1.sort() L2.sort() # 第一次 L1,L2 为空，元素直接进行合并，返回元素两两合并的数据集 # if first k-2 elements are equal if L1 == L2: # set union # print 'union=', Lk[i] | Lk[j], Lk[i], Lk[j] retList.append(Lk[i] | Lk[j]) return retList 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。1234567891011121314151617181920212223242526272829303132333435363738394041# 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。def apriori(dataSet, minSupport=0.5): """apriori（首先构建集合 C1，然后扫描数据集来判断这些只有一个元素的项集是否满足最小支持度的要求。那么满足最小支持度要求的项集构成集合 L1。然后 L1 中的元素相互组合成 C2，C2 再进一步过滤变成 L2，然后以此类推，知道 CN 的长度为 0 时结束，即可找出所有频繁项集的支持度。） Args: dataSet 原始数据集 minSupport 支持度的阈值 Returns: L 频繁项集的全集 supportData 所有元素和支持度的全集 """ # C1 即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset C1 = createC1(dataSet) # 对每一行进行 set 转换，然后存放到集合中 D = map(set, dataSet) print 'D=', D # 计算候选数据集 C1 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 L1, supportData = scanD(D, C1, minSupport) # print "L1=", L1, "\n", "outcome: ", supportData # L 加了一层 list, L 一共 2 层 list L = [L1] k = 2 # 判断 L 的第 k-2 项的数据长度是否 &gt; 0。第一次执行时 L 为 [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]]。L[k-2]=L[0]=[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]，最后面 k += 1 while (len(L[k-2]) &gt; 0): print 'k=', k, L, L[k-2] Ck = aprioriGen(L[k-2], k) # 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; print 'Ck', Ck Lk, supK = scanD(D, Ck, minSupport) # 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 # 保存所有候选项集的支持度，如果字典没有，就追加元素，如果有，就更新元素 supportData.update(supK) if len(Lk) == 0: break # Lk 表示满足频繁子项的集合，L 元素在增加，例如: # l=[[set(1), set(2), set(3)]] # l=[[set(1), set(2), set(3)], [set(1, 2), set(2, 3)]] L.append(Lk) k += 1 # print 'k=', k, len(L[k-2]) return L, supportData 到这一步，我们就找出我们所需要的 频繁项集 和他们的 支持度 了，接下来再找出关联规则即可！ 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 从频繁项集中挖掘关联规则前面我们介绍了用于发现 频繁项集 的 Apriori 算法，现在要解决的问题是如何找出 关联规则。 要找到 关联规则，我们首先从一个 频繁项集 开始。我们知道集合中的元素是不重复的，但我们想知道基于这些元素能否获得其它内容。某个元素或某个元素集合可能会推导出另一个元素。从先前 杂货店 的例子可以得到，如果有一个频繁项集 {豆奶,莴苣}，那么就可能有一条关联规则 “豆奶 -&gt; 莴苣”。这意味着如果有人买了豆奶，那么在统计上他会购买莴苣的概率比较大。但是，这一条件反过来并不总是成立。也就是说 “豆奶 -&gt; 莴苣” 统计上显著，那么 “莴苣 -&gt; 豆奶” 也不一定成立。 前面我们给出了 频繁项集 的量化定义，即它满足最小支持度要求。对于 关联规则，我们也有类似的量化方法，这种量化指标称之为 置信度。一条规则 A -&gt; B 的置信度定义为 support(A | B) / support(A)。（注意: 在 python 中 | 表示集合的并操作，而数学书集合并的符号是 U）。A | B 是指所有出现在集合 A 或者集合 B 中的元素。由于我们先前已经计算出所有 频繁项集 的支持度了，现在我们要做的只不过是提取这些数据做一次除法运算即可。 一个频繁项集可以产生多少条关联规则呢？如下图所示，给出的是项集 {0,1,2,3} 产生的所有关联规则: 与我们前面的 频繁项集 生成一样，我们可以为每个频繁项集产生许多关联规则。如果能减少规则的数目来确保问题的可解析，那么计算起来就会好很多。通过观察，我们可以知道，如果某条规则并不满足 最小置信度 要求，那么该规则的所有子集也不会满足 最小置信度 的要求。如上图所示，假设 123 -&gt; 3 并不满足最小置信度要求，那么就知道任何左部为 {0,1,2} 子集的规则也不会满足 最小置信度 的要求。即 12 -&gt; 03 , 02 -&gt; 13 , 01 -&gt; 23 , 2 -&gt; 013, 1 -&gt; 023, 0 -&gt; 123 都不满足 最小置信度 要求。 可以利用关联规则的上述性质属性来减少需要测试的规则数目，跟先前 Apriori 算法的套路一样。以下是一些辅助函数: 计算置信度1234567891011121314151617181920212223242526# 计算置信度（confidence）def calcConf(freqSet, H, supportData, brl, minConf=0.7): """calcConf（对两个元素的频繁项，计算置信度，例如： &#123;1,2&#125;/&#123;1&#125; 或者 &#123;1,2&#125;/&#123;2&#125; 看是否满足条件） Args: freqSet 频繁项集中的元素，例如: frozenset([1, 3]) H 频繁项集中的元素的集合，例如: [frozenset([1]), frozenset([3])] supportData 所有元素的支持度的字典 brl 关联规则列表的空数组 minConf 最小置信度 Returns: prunedH 记录 置信度大于阈值的集合 """ # 记录置信度大于最小置信度（minConf）的集合 prunedH = [] for conseq in H: # 假设 freqSet = frozenset([1, 3]), H = [frozenset([1]), frozenset([3])]，那么现在需要求出 frozenset([1]) -&gt; frozenset([3]) 的置信度和 frozenset([3]) -&gt; frozenset([1]) 的置信度 # print 'confData=', freqSet, H, conseq, freqSet-conseq conf = supportData[freqSet]/supportData[freqSet-conseq] # 支持度定义: a -&gt; b = support(a | b) / support(a). 假设 freqSet = frozenset([1, 3]), conseq = [frozenset([1])]，那么 frozenset([1]) 至 frozenset([3]) 的置信度为 = support(a | b) / support(a) = supportData[freqSet]/supportData[freqSet-conseq] = supportData[frozenset([1, 3])] / supportData[frozenset([1])] if conf &gt;= minConf: # 只要买了 freqSet-conseq 集合，一定会买 conseq 集合（freqSet-conseq 集合和 conseq 集合是全集） print freqSet-conseq, '--&gt;', conseq, 'conf:', conf brl.append((freqSet-conseq, conseq, conf)) prunedH.append(conseq) return prunedH 递归计算频繁项集的规则1234567891011121314151617181920212223242526272829303132# 递归计算频繁项集的规则def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7): """rulesFromConseq Args: freqSet 频繁项集中的元素，例如: frozenset([2, 3, 5]) H 频繁项集中的元素的集合，例如: [frozenset([2]), frozenset([3]), frozenset([5])] supportData 所有元素的支持度的字典 brl 关联规则列表的数组 minConf 最小置信度 """ # H[0] 是 freqSet 的元素组合的第一个元素，并且 H 中所有元素的长度都一样，长度由 aprioriGen(H, m+1) 这里的 m + 1 来控制 # 该函数递归时，H[0] 的长度从 1 开始增长 1 2 3 ... # 假设 freqSet = frozenset([2, 3, 5]), H = [frozenset([2]), frozenset([3]), frozenset([5])] # 那么 m = len(H[0]) 的递归的值依次为 1 2 # 在 m = 2 时, 跳出该递归。假设再递归一次，那么 H[0] = frozenset([2, 3, 5])，freqSet = frozenset([2, 3, 5]) ，没必要再计算 freqSet 与 H[0] 的关联规则了。 m = len(H[0]) if (len(freqSet) &gt; (m + 1)): print 'freqSet******************', len(freqSet), m + 1, freqSet, H, H[0] # 生成 m+1 个长度的所有可能的 H 中的组合，假设 H = [frozenset([2]), frozenset([3]), frozenset([5])] # 第一次递归调用时生成 [frozenset([2, 3]), frozenset([2, 5]), frozenset([3, 5])] # 第二次 。。。没有第二次，递归条件判断时已经退出了 Hmp1 = aprioriGen(H, m+1) # 返回置信度大于最小置信度的集合 Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf) print 'Hmp1=', Hmp1 print 'len(Hmp1)=', len(Hmp1), 'len(freqSet)=', len(freqSet) # 计算置信度后，还有数据大于最小置信度的话，那么继续递归调用，否则跳出递归 if (len(Hmp1) &gt; 1): print '----------------------', Hmp1 # print len(freqSet), len(Hmp1[0]) + 1 rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf) 生成关联规则12345678910111213141516171819202122232425# 生成关联规则def generateRules(L, supportData, minConf=0.7): """generateRules Args: L 频繁项集列表 supportData 频繁项集支持度的字典 minConf 最小置信度 Returns: bigRuleList 置信度规则列表（关于 (A-&gt;B+置信度) 3个字段的组合） """ bigRuleList = [] # 假设 L = [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])], [frozenset([1, 3]), frozenset([2, 5]), frozenset([2, 3]), frozenset([3, 5])], [frozenset([2, 3, 5])]] for i in range(1, len(L)): # 获取频繁项集中每个组合的所有元素 for freqSet in L[i]: # 假设：freqSet= frozenset([1, 3]), H1=[frozenset([1]), frozenset([3])] # 组合总的元素并遍历子元素，并转化为 frozenset 集合，再存放到 list 列表中 H1 = [frozenset([item]) for item in freqSet] # 2 个的组合，走 else, 2 个以上的组合，走 if if (i &gt; 1): rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) else: calcConf(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList 到这里为止，通过调用 generateRules 函数即可得出我们所需的 关联规则。 分级法： 频繁项集-&gt;关联规则 1.首先从一个频繁项集开始，接着创建一个规则列表，其中规则右部分只包含一个元素，然后对这个规则进行测试。 2.接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。 如下图： 最后： 每次增加频繁项集的大小，Apriori 算法都会重新扫描整个数据集，是否有优化空间呢？ 信息参考于 ApacheCN]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>graduation</tag>
        <tag>数据挖掘</tag>
        <tag>关联规则算法</tag>
        <tag>apriori</tag>
        <tag>毕业设计</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【毕设】Hadoop完全分布式平台搭建]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%90%E6%AF%95%E8%AE%BE%E3%80%91Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Info: 毕业设计课题基础Hadoop环境搭建 步入大四，毕设也是今年的重中之重，学校给我分配的课题是《基于大数据平台的关联规则算法的研究与实现》。之前没有接触过大数据的我也是要从头开始相关的学习，比如Hadoop环境的配置、关联规则算法的python实现、还有如何将Apriori算法在MapReduce上面并行化等等等等。本文就是Hadoop完全分布式平台的搭建记录。 另外也要感谢我校嵌入式研究中心的主任李超老师，给我提供了性能可靠的物理服务器来进行该课题的研究。 搭建Hadoop全分布式集群前提虚拟机软件的安装网上随便找的Vmware workstation，然后在centOS官网找个镜像装一下就OK了。但由于自己是学校给的服务器，所以略过这一步。 虚拟机的网络如果是在一台虚拟机中安装多个Linux操作系统的话，可以使用NAT或桥接模式都是可以的。 步骤： 在要使用的虚拟机的标签上右键单击，选择设置，选择网络适配器，选择桥接模式，确定。 设置完成之后，重启一下虚拟机。 再设置桥接之前将固定的IP取消： 桌面版：通过图形化界面设置的。 服务器版：在/etc/network/interfacesiface ens33 inet dhcp #address ... ifconfig获取IP。 最后试一试能不能ping通。 文件读写权限在linux下，软件安装到/opt下，当前正在使用的用户，对于opt目录需要有读写权限： 1）将opt的权限给为777（漏洞文件），不推荐在生产环境中使用。但是可以在学习和调试环境中使用。 2）sudo 在启动Hadoop的各个守护进程的时候，需要使用sudo。 在管理Hadoop的时候，实际上由不同的用户启动不同集群的守护进程。 统一使用当前的用户管理所有集群。 3）该目录的所有者设置为当前用户 安装JDK，配置Java环境1）将jdk安装包放在家目录下 2）解压到opt目录下 sudo tar zxvf jdk-8u131-linux-x64.tar.gz -C /opt 此时在/opt目录下：会有一个jdk1.8.0_1313）创建软链接 sudo ln -snf /opt/jdk1.8.0_131 /opt/jdk 注意：创建软连接的目的是为了，我们在做项目的时候，可能会用到不同的jdk版本，这是要换软件的话，只需要修改软链接就可以了。而不用修改配置文件。 4）配置环境变量 局部环境变量：~/.bashrc 全局环境变量：/etc/profile export JAVA_HOME=/opt/jdk export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib export PATH=$PATH:$JAVA_HOME/bin source 相关文件（更新配置文件）5）查看是否安装成功 java、javac、java -version搭建伪分布式集群安装Hadoop1）解压hadoop安装包到opt目录下 sudo tar zxvf hadoop-2.8.1.tar.gz -C /opt2）创建软链接 ln -snf /opt/hadoop-2.8.1 /opt/hadoop 3）配置环境变量 在/etc/profile文件中加入以下内容： export HADOOP_HOME=/opt/hadoop export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin source /etc/profile4）使用hadoop version命令测试是否配置成功 配置Hadoop配置文件存放在/opt/hadoop/etc/hadoop中有很多个文件，暂时只需要修改的只有几个 1）hadoop-env.sh export JAVA_HOME=${JAVA_HOME}改成export JAVA_HOME=/opt/jdk 注意：在配置文件中有提示我们怎么设置，我们一般不删除，二回选择注释它的提示。 2）core-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt; &lt;value&gt;hdfs:&#x2F;&#x2F;1.0.0.5:9000&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 分析：1.0.0.5是你主节点所在主机的ip，而9000为端口 3）hdfs-site.xml 1234567891011121314151617181920212223&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.nameservices&lt;&#x2F;name&gt; &lt;value&gt;hadoop-cluster&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;nn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.ch eckpoint.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;snn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.edits.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;snn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;dn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 4）mapred-site.xml 在hadoop的相关目录中没有此文件，但是有一个mapred-site.xml.template文件，将该文件复制一份为mapred-site.xml cp mapred-site.xml.template mapred-site.xml123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt; &lt;value&gt;yarn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 5）yarn-site.xml 12345678910111213141516&lt;configuration&gt; &lt;!-- 指定ResourceManager的地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt; &lt;value&gt;1.0.0.5&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;!-- 指定reducer获取数据的方式--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt; &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.local-dirs&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;yarn&#x2F;nm&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; Hadoop目录权限问题注意： 如果使用sudo启动hadoop的相关进程，这几个目录的权限可以不用管。如果是使用当前的用户启动相关进程，对于opt目录，当前用户得有读写权限，对于/data目录也需要读写权限。 sudo mkdir -p /data/hadoop/hdfs/nn sudo mkdir -p /data/hadoop/hdfs/dn sudo mkdir -p /data/hadoop/hdfs/snn sudo mkdir -p /data/hadoop/yarn/nm启动Hadoop启动HDFS集群 hadoop-daemon.sh start namenode 启动主节点 hadoop-daemon.sh start datanode 启动从节点 启动YARN集群yarn-daemon.sh start resourcemanager yarn-daemon.sh start nodemanager 启动作业历史服务器mr-jobhistory-daemon.sh start historyserver jps命令查看是否启动成功 HDFS和YARN集群都有相对应的WEB监控页面HDFS：http://ip:50070 YARN：http://ip:8088 YARN集群的操作—-测试Hadoop是否配置成功计算PI值的作业： yarn jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.1.jar pi 4 100 配置免密码登录1）在所有的主从节点中执行 如果以前配置过免密登录的话，建议删除重新建立过，因为我们需要配置的是多台服务器： rm -r ~/.ssh 执行ssh-keygen为了在主节点中生成公钥和私钥，在从从节点生成.ssh目录 2）在主节点中执行 scp /.ssh/id_rsa.pub 从节点的用户名@从节点ip: 注意：第一次远程连接的话，首先输入yes，然后是从节点密码 3）在所有的从节点中执行 我们把主节点的公钥已经拿到了所有的从节点中，接下来就是： cat id_rsa.pub&gt;&gt;.ssh/authorized_keys当中]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>graduation</tag>
        <tag>毕业设计</tag>
        <tag>hadoop</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习【二】]]></title>
    <url>%2F2018%2F01%2F06%2FES6%E5%AD%A6%E4%B9%A0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:es6的学习笔记，包括函数默认参数Parameter、对象代理Proxy、解构赋值以及多行字符串/模版变量 默认参数 (parameter)通过es6很方便地给函数设置一个默认参数1234567891011121314151617181920212223242526272829/** * es5中函数默认参数 * 如果需要这个函数的参数可填可不填，不填的话就给一个默认值 * 那么在函数体内要写一个判断或者采用或表达式（||） */function fn(a,b,c)&#123; if(b == null)&#123; b = 2 &#125; c = c || 3 return a+b+c&#125;fn(1) // 6fn(1,3) // 7fn(1,3,4) // 8/** * es6中函数默认参数 */function fn(a,b = 2,c = 3)&#123; return a+b+c&#125;//该函数使用babel编译过来的结果得到：// function fn(a) &#123;// var b = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;// var c = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 1;// return a+b+c;// &#125; 利用es6中的默认参数来进行对函数必选参数的检查:123456789101112131415function cheakParameter()&#123; throw new Error('can\'t be empty!')&#125;function fn(a=cheakParameter(),b=2,c=3)&#123; return a+b+c&#125;try&#123; fn()&#125;catch(e)&#123; console.log(e)&#125;finally&#123; &#125; es6中可变参数的写法1234567891011121314151617181920212223242526/** * es5中可变参数的写法 */function fn()&#123; var a = Array.prototype.slice.call(arguments) //arguments是一个伪数组，所以用数组的方式来写需要对数组的原型对象call()一下 var sum = 0 a.forEach(function(item)&#123; sum+=item*1 &#125;) return sum&#125;console.log(fn(1,2,3))/** * es6中可变参数的写法 */function fn(...a)&#123; // ... 是扩展运算符 ...a 就是可变参数 var sum = 0 a.forEach(item =&gt; &#123; sum += item*1 &#125;) return sum&#125;console.log(fn(1,2,3)) 对象代理 (Proxy) 如果有要求需要封装一份数据，这个数据只让内部的方法访问到，而外部的API无法访问高级程序语言(比如JAVA、C#等)有一个私有属性，就可以直接达到这样的效果在Javascript中，es3、es5只能通过模拟私有变量的方法达到这样的效果，但写法复杂而在es6中,它提供了一个对象代理(Proxy)的方法来解决私有变量的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * es3中采用构造函数来对数据进行保护 */var Person = function()&#123; var data = &#123; name: 'es3', age: 23, sex: 'male', &#125; this.get = function(key)&#123; return data[key] &#125; this.set = function(key,value)&#123; if(key !== 'sex')&#123; //这里就设置了sex值不可改，即达到了保护的效果 data[key] = value &#125; &#125;&#125;//声明一个实例var person = new Person()//读取console.table(&#123;name:person.get('name'),age:person.get('age'),sex:person.get('sex')&#125;)//修改person.set('name','es3-cname') // 修改成功person.set('sex','female') // 不会报错，但不会被执行成功/** * es5中采用defineProperty来对数据进行保护 */var person = &#123; name: 'es5', age: 25&#125;Object.defineProperty(person,'sex',&#123; writable: false, value: 'male'&#125;)// 读取console.table(&#123;name:person.name,age:person.age,sex:person.sex&#125;)// 修改try&#123; person.sex = 'female' // 报错&#125;catch(e)&#123; console.log(e)&#125;/** * es6中采用对象代理来对数据进行保护 */let Person = &#123; name: 'es6', age: 26, sex: 'male'&#125;let person = new Proxy(Person,&#123; get(target,key)&#123; return target[key] &#125;, set(target,key,value)&#123; if(key !== 'sex')&#123; //和es3中很相似，也是声明两个方法来获取和改变数据的值 target[key] = value &#125; &#125;&#125;)// 读取console.table(&#123;name:person.name,age:person.age,sex:person.sex&#125;)// 修改try&#123; person.sex = 'female' // 报错&#125;catch(e)&#123; console.log(e)&#125; 解构赋值12345678910111213141516171819202122/** * es5中取得对象属性的值或者数组的值 */var obj = &#123;a:100,b:200,c:300&#125;var arr = ['xxx','yyy','zzz']var a = obj.avar b = obj.bvar x = arr[0]var y = arr[1]var z = arr[2]/** * es6中的解构赋值 */const obj = &#123;a:100,b:200,c:300&#125;const arr = ['xxx','yyy','zzz']const &#123;a,c&#125; = objconst [x,y,z] = arr 多行字符串/模板变量 (`$`)1234567891011121314151617181920212223242526/** * es5中的多行字符串/模板变量 */var name = 'zhangsan'var age = 20var html = ''html += '&lt;div&gt;'html += ' &lt;p&gt;' + name + '&lt;/p&gt;'html += ' &lt;p&gt;' + age + '&lt;/p&gt;'html =+ '&lt;/div&gt;'/** * es6中的多行字符串/模板变量 */const name = 'zhangsan'const age = 20const html = ` &lt;div&gt; &lt;p&gt;$&#123;name&#125;&lt;/p&gt; &lt;p&gt;$&#123;age&#125;&lt;/p&gt; &lt;/div&gt;`//使用反引号能写多行字符串，还可以用$符号进行引入变量]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>parameter</tag>
        <tag>proxy</tag>
        <tag>解构赋值</tag>
        <tag>模版字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习【一】]]></title>
    <url>%2F2018%2F01%2F06%2FES6%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:es6的学习笔记，包括变量定义关键字let&amp;const、块级作用域Scope、箭头函数Arrow Function、类Class以及异步解决方案Promise 变量定义关键字 (let &amp; const)es5中定义常量 JS中全局对象是window，对于常量来说就可以将它绑定到window上 所用到的就是Object的defineProperty方法，它的第三个参数是一个描述符 123456789/** * es5中定义一个常量的写法 */Object.defineProperty(window,"a",&#123; value: 100, writable: false,&#125;)a = 200 //不会报错，但是没有执行成功console.log(a) //100 es6中定义常量1234567891011&#x2F;** * es6中定义一个常量的写法 * 直接使用const修饰符 *&#x2F;let b &#x3D; 100b &#x3D; 200 &#x2F;&#x2F;正确console.log(b) &#x2F;&#x2F; 200const c &#x3D; 100c &#x3D; 200 &#x2F;&#x2F;报错console.log(c) &#x2F;&#x2F; 100 块级作用域 (Scope)解决es5中for循环使用var来声明i时候的变量提升问题12345678910111213141516171819202122232425262728293031/** * es5中for循环使用var关键字来声明i */var array = []for(var i=0;i&lt;3;i++)&#123; //这里有一个变量提升的问题 array[i] = function()&#123; //这里的i分别为 1、2、3 return i*2 //而这里返回的是一个函数表达式，此时是对i这个对象的引用，而不是对i的值的引用，所以i不会取到值，直到执行的时候i才能取到值。这个地方也是一个闭包。 &#125;&#125;console.table([ //此时函数表达式被执行，取到了i的值，但i已经变成了3 array[0](), array[1](), array[2]()])/** * es6中for循环使用let关键字来声明i */var array = []for(let i=0;i&lt;3;i++)&#123; array[i] = function()&#123; //使用let会有一个块级作用域，把当前i的值存下来使用 return i*2 //循环到下一步的时候会生成一个新的作用域，这样就不会出现变量提升的问题 &#125;&#125;console.table([ array[0](), array[1](), array[2]()]) es6中有块级作用域 由于es5中没有块级作用域，所以需要使用立即执行函数来指定（隔离）一个块作用域而在es6中只需要使用一对大括号就能直接指定一个块作用域 1234567891011121314151617181920212223242526272829303132/** * es5无块级作用域 * 在for循环外面还是可以取到item的值 */var obj = &#123;a:100,b:200&#125;for(var item in obj)&#123; console.log(item)&#125;console.log(item) // b (这里也有一个变量提升的问题)/** * 由于es5中没有块级作用域 * 所以为了程序的可读性，es5中推荐这么写 */var obj = &#123;a:100,b:200&#125;var itemfor(item in obj)&#123; console.log(item)&#125;console.log(item) // b/** * es6中有块级作用域 * 在for循环外面取不到item的值 */const obj = &#123;a:100,b:200&#125;for(let item in obj)&#123; console.log(item)&#125;console.log(item) // 报错: item is not defined 箭头函数 (Arrow Function)箭头函数语法形式123() =&gt; &#123;&#125; 小括号里面接收参数,若参数只有一个那么可以省略小括号大括号里面是函数体，若函数体只有一行那么可以省略大括号 map()方法中的箭头函数12345678910111213141516171819/** * es5中function函数 */var arr = [1,2,3]arr.map(function(item)&#123; return item+1&#125;)/** * es6中的箭头函数 */const arr = [1,2,3]arr.map(item =&gt; item + 1) //只传入一个参数，且函数体只有一行arr.map((item,index) =&gt; &#123; //传入多个参数，且函数体有多行 console.log(index) return item + 1&#125;) call()方法改变this的指向1234567891011121314151617181920212223242526/** * es5中使用call()方法来改变function函数中this的指向 */function fn()&#123; console.log('真正的this:',this) // 真正的this: &#123;a: 100&#125; var arr = [1] arr.map(function(item)&#123; console.log('此时的this:',this) // 此时的this: Window &#125;)&#125;fn.call(&#123;a:100&#125;)/** * es6中使用call()方法来改变箭头函数中this的指向 */function fn()&#123; console.log('真正的this:',this) // 真正的this: &#123;a: 100&#125; var arr = [1] arr.map(item =&gt; &#123; console.log('此时的this:',this) // 此时的this: &#123;a: 100&#125; &#125;)&#125;fn.call(&#123;a:100&#125;) function函数与箭头函数中this的指向对比 在es5的function函数中，this的指向是函数被调用时的对象，也就是说该函数在被执行的时候，哪个对象调用了该函数，这个this指向的就是那个对象 在es6中的箭头函数中，箭头函数没有自己的this。箭头函数的this是继承而来，默认指向在定义该箭头函数时所处的对象(宿主对象) 12345678910111213141516171819202122232425262728293031323334/** * es5中的function函数中的this指向 */var Foo = function()&#123; this.a = 'a' this.b = 'b' this.c = &#123; a: 'a+', b: function()&#123; return this.a &#125; &#125;&#125;var foo = new Foo()console.log(foo.c.b()) // a+/** * es6中的箭头函数中的this指向 */let Foo = function()&#123; this.a = 'a' this.b = 'b' this.c = &#123; a: 'a+', b: ()=&gt;&#123; return this.a &#125; &#125;&#125;let foo = new Foo()console.log(foo.c.b()) // a 类 (class)构造函数123456789101112131415161718192021222324252627282930313233343536/** * es5中构造函数的写法 */function MathHandle (x,y)&#123; this.x = x this.y = y&#125;MathHandle.prototype.add = function() &#123; return this.x + this.y&#125;var m = new MathHandle(1,2)console.log(m.add())/* * es6中构造函数的写法 */class MathHandle&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; add()&#123; return this.x + this.y; &#125;&#125; const m = new MathHandle(1,2);console.log(m.add()); // 3console.log(typeof MathHandle); // function//构造函数的显式原型的constructor属性值为构造函数本身console.log(MathHandle.prototype.constructor); // class MathHandle&#123;&#125; 类的继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * es5中继承的写法 *///动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125; // 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat()/** es6中继承的写法*/class Animal&#123; // 构造函数 constructor(name)&#123; this.name = name &#125; // 成员方法 eat()&#123; console.log(this.name + ' eat') &#125;&#125;// 继承class Dog extends Animal&#123; constructor(name)&#123; super(name) // 只要出现继承extends，就必须写super,而且需要把super放在constructor里面的第一行 this.name = name &#125; bark()&#123; console.log(this.name + ' bark') &#125;&#125;const dog = new Dog('hashiqi')dog.bark()dog.eat() 类的setter和setter ES6在类的内部可以使用get和set关键字来对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819202122232425/** * es6中的setter、getter */class Parent&#123; constructor(name = "es6")&#123; this.name = name &#125; get getName()&#123; //这里的get形似方法，但它实际上是一个属性 return this.name &#125; set setName(value)&#123; this.name = value &#125;&#125;let par = new Parent()console.log('getter: ',par.getName)console.log('setter: ', par.setName = 'es6-cname')console.log(par.name,par.getName)//因为setter是一个属性，所以不能写成par.setName(es6-cname)//而是要写成赋值表达式的形式 类的静态方法和静态变量12345678910111213141516171819/** * es6中的静态方法和静态属性 */class Parent&#123; constructor(name = "es6")&#123; this.name = name &#125; static tell()&#123; //定义类的静态方法使用关键字static console.log('es6-static') &#125;&#125;Parent.type = 'es6-class' //静态属性没有关键字去声明//定义类的静态属性是在类定义完成后直接在类的外面进行赋值表达式定义Parent.tell() // 静态方法是通过类去调用，而不是通过类的实例去调用console.log(Parent.type) // 打印静态对象 异步 (Promise)Promise的介绍Promise是异步编程的一种解决方案，比传统的解决方案–回调函数和事件更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise。 所谓Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作）的结果。*从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 * 也之所以它是一个对象，所以它可以用来保存状态，从而解决了普通回调函数中的“回调地狱”以及“不能return”这两个问题。 三种状态:Promise对象的状态不受外界影响: pending: 进行中 fulfilled: 已经成功 rejected: 已经失败 状态改变:Promise对象的状态改变,只有两种可能: 从pending变为fulfilled 从pending变为rejected 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型） 使用Promise加载图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * es5中的回调函数 */function loadimg(src,callback,failed)&#123; var img = document.createElement('img') img.onload = function()&#123; callback(img) &#125; img.onerror = function()&#123; failed() &#125; img.src = src&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'loadimg(src,function(img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)/** * es6中的promise * 1.new Promise实例，而且要在后面return这个实例 * 2.new Promise时候要传入一个函数，该函数有resolve、reject两个参数 * 3.成功时候执行resolve()，失败时候执行reject() * 4.then()方法监听结果，并可以多次执行，达到分批处理的效果 */function loadimg(src)&#123; const promise = new Promise(function(resolve ,reject)&#123; const img = document.createElement('img') img.onload = function ()&#123; resolve(img) &#125; img.onerror = function()&#123; reject() &#125; img.src = src &#125;) return promise&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'var result = loadimg(src)//传两个函数作为参数，分别是成功和失败的回调result.then(function (img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)// 可以集成可以扩展可以分批处理,变得更加灵活result.then(function(img)&#123; console.log(img.height)&#125;) 多步调用:事件A–&gt;事件B–&gt;事件C123456789101112131415161718192021222324let ajax = function()&#123; console.log('start') return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-A') &#125;, 500); reslove() &#125;)&#125;ajax().then(function()&#123; //then()方法继续返回new Promise实例，就可以达到串联的效果 return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-B') &#125;, 1000); reslove() &#125;)&#125;).then(function()&#123; return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-C') &#125;, 1500); &#125;)&#125;) 异步过程中使用catch捕获错误1234567891011121314151617let ajax = function (num) &#123; return new Promise(function(reslove,reject)&#123; if(num&lt;4)&#123; reslove() &#125;else&#123; throw new Error('It Should under five!!!') &#125; &#125;)&#125;for (let i = 1;i &lt; 5;i++) &#123; ajax(i).then(function()&#123; console.log('i =',i) &#125;).catch(function(err)&#123; console.log('catch',err) &#125;)&#125; 异步加载图片的两个示例 所有图片都加载完之后再添加到页面 Promise.all()表示把多个Promise实例当作一个新的Promise实例，可以传入一个数组作为参数，当数组中所有Promise实例的状态都发生改变，这个新的实例对象才会改变。 123456789101112131415161718192021222324252627//加载图片的方法function loadImg (src) &#123; return new Promise((resolve,reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = function()&#123; resolve(img) &#125; img.onerror = function()&#123; reject(err) &#125; &#125;)&#125;//加载完之后将图片添加到页面上的方法function showImgs(imgs)&#123; imgs.forEach(function(img)&#123; document.body.appendChild(img) &#125;)&#125;//高级用法Promise.all([ loadImg('https://www.imooc.com/static/img/index/logo.png'), loadImg('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png'), loadImg('https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg')]).then(showImgs) 只要有一张图片加载完就添加到页面 Promise.race()表示把多个Promise实例当作一个新的Promise实例，可以传入一个数组作为参数，当数组中这多个Promise实例的状态只要有一个发生改变，这个新的实例对象就会改变。 123456789101112131415161718192021222324//加载图片的方法function loadImg (src) &#123; return new Promise((resolve,reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = function()&#123; resolve(img) &#125; img.onerror = function()&#123; reject(err) &#125; &#125;)&#125;//加载完之后将图片添加到页面上的方法function showImgs(img)&#123; document.body.appendChild(img)&#125;Promise.race([ loadImg('https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg'), loadImg('https://www.imooc.com/static/img/index/logo.png'), loadImg('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png'),]).then(showImgs)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>scope</tag>
        <tag>arrow function</tag>
        <tag>箭头函数</tag>
        <tag>class</tag>
        <tag>类</tag>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue:构建数据驱动的web界面的渐进式框架]]></title>
    <url>%2F2017%2F12%2F14%2FVue%3A%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84web%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Info: Vue官网内容深入了解 Vue起步实例方法/实例属性vm.$data.content可以访问vm实例data里的content内容。这个$表示的是Vue的实例方法或者实例属性。 全局组件123//Vue中使用这样的语法来定义一个全局组件Vue.component("组件名",&#123;&#125;) 给某个元素标签加一个key值Vue在重新渲染页面时，它会尽量复用页面上的dom，但此时该dom上内容并不会被清空。要解决这个问题，可以给该元素标签加一个key值，此时Vue就能知道这是页面上一个唯一的元素，如果两个元素的key值不一样，Vue就不会复用以前的dom元素。这是Vue中虚拟DOM的diff算法中的内容。 给Vue组件绑定原生事件 原生事件是指绑定在子组件内部的template模板标签中的事件。 而绑定在父组件里面的子组件标签上的事件叫做自定义事件，它的触发可以通过父子组件间通信的方式。 自定义事件可以通过加一个native修饰符来变成原生事件。形如：@click.native=&quot;handleClick&quot;。 父子组件间通信 Vue中父组件向子组件传值是通过属性的形式，具体作法是在父组件里面的子组件标签类上绑定一个content属性作为需要传递的值，然后在子组件内部通过props参数来接受这个content值。 Vue中有一个叫”单向数据流”的概念。父组件可以给子组件任意传递参数，但是子组件只能使用这个参数而不能反过来去修改这个参数。原因是通过父组件:content=&quot;item&quot;这种形式向子组件传值，这个item其实是一个js表达式{}，里面的js对象等等都是引用类型。(如果是content=&quot;item&quot;这种形式，那么这个item是一个String字符串)如果其他子组件也用到了这个数据，那会就会造成混乱。解决这个问题的方法是在子组件内部使用data函数形式返回一个对象来存储这个传过来的数据再对其进行修改使用。 Vue中子组件向父组件传值是通过在子组件内部调用this.$emit()方法来向外触发一个事件以及传递一个参数，而在父组件模板中通过v-on(简写”@”)监听这个事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;todoList&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;id id="app"&gt; &lt;div&gt; &lt;input type="text" v-model="inputValue"&gt; &lt;button @click="handleBtnClick"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;todo-item v-for="(item,index) in list" :index="index" :content="item" @delete = "handleItemDelete"&gt; &lt;/todo-item&gt; &lt;/ul&gt; &lt;/id&gt; &lt;script&gt; var TodoItem = &#123; props:['content','index'], template: "&lt;li @click='handleBtnItem'&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;", methods: &#123; handleBtnItem: function(index)&#123; this.$emit("delete",this.index) &#125; &#125; &#125; var app = new Vue(&#123; el: '#app', components: &#123; TodoItem: TodoItem, &#125;, data: &#123; list: [], inputValue: '', &#125;, methods:&#123; handleBtnClick:function()&#123; if(this.inputValue != "")&#123; this.list.push(this.inputValue) this.inputValue = '' &#125; &#125;, handleItemDelete:function(index)&#123; this.list.splice(index,1) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue实例生命周期函数Vue生命周期简介 生命周期函数就是Vue实例在某一个时间点会自动执行的函数这些生命周期函数直接定义在Vue实例中而不放在methods对象中。 除了图片中的这8个生命周期函数，Vue还有另外三个生命周期函数，分别是deactivated()、activated()以及errorCaptured() Vue生命周期探究123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue实例生命周期函数&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;生命周期函数就是Vue实例在某一个时间点会自动执行的函数&lt;/h2&gt; &lt;div id="root"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', template: '&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', data: &#123; msg: 'hello Vue!' &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); console.log("%c%s", "color:red" , "el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //undefined console.log("%c%s", "color:red","message: " + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); console.log("%c%s", "color:red","el : " + (this.$el)); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, destroyed: function () &#123; console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue生命周期总结 beforecreate: 举个栗子：可以在这加个loading事件 created: 在这结束loading，还做一些初始化，实现函数自执行 mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestroy: 解绑自定义事件(event.$off)、清除定时器、解绑自定义的 DOM 事件，如 window scroll 等等 destroyed: 当前组件已被删除，清空相关内容 errorCaptured: 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。(err: Error, vm: Component, info: string) =&gt; ?boolean Vue的模板语法123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue模板语法&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div&gt;&#123;&#123;greetting&#125;&#125;&lt;/div&gt; &lt;div v-text="greetting"&gt;&lt;/div&gt; &lt;div v-html="greetting"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; greetting: '&lt;h1&gt;hello Vue!&lt;/h1&gt;' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模指令v-text=””、v-html=””，双引号内指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for是例外情况)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 计算属性、方法、侦听器计算属性1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性、方法、侦听器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', age: 23 &#125;, //计算属性 computed: &#123; fullName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed计算属性有一个缓存机制，也就是只要计算属性所依赖的值没有发生改变时，就不会重新计算。这样就可以使性能得到优化。 方法1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性、方法、侦听器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName()&#125;&#125; &lt;!--此处因为fullName()是一个方法，所以要加上()来进行调用--&gt; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', age: 23 &#125;, //方法 methods: &#123; fullName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 只要页面数据发生改变，methods方法都会执行。所以同样的情况下优先选用computed计算属性。 侦听器123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性、方法、侦听器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', age: 23, fullName: 'chris su' &#125;, //侦听器 watch: &#123; //监听firstName的变化 firstName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125;, //监听lastName的变化 lastName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 只要监听的值不发生变化，watch侦听器就不会被执行。 Vue计算属性中的getter和setter123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性的setter和getter&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', &#125;, computed: &#123; //fullName写成对象的形式 fullName: &#123; get: function()&#123; return this.firstName + ' ' + this.lastName &#125;, set: function(value)&#123; var arr = value.split(" "); this.firstName = arr[0]; this.lastName = arr[1]; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的样式绑定通过class进行绑定class的对象绑定 将div节点绑定一个activated类，这个类显示与否取决于一个叫isActivated对象的值，初始值为false，即不显示这个类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .activated&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div @click='handleClick' :class="&#123;activated:isActivated&#125;" &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; isActivated: false &#125;, methods: &#123; handleClick: function()&#123; this.isActivated = !this.isActivated &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; class的数组绑定 将div节点绑定一个数组，数组中的每个变量的值都可以添加到这个节点的class类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .activated&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div @click='handleClick' :class="[activated]" &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; activated: "" &#125;, methods: &#123; handleClick: function()&#123; this.activated = this.activated === "activated" ? "" : "activated" &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过style进行绑定style的对象绑定 将div节点绑定一个内联的style样式，这个样式的值由一个叫styleObj的值来决定 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div :style="styleObj" @click='handleClick' &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; styleObj: &#123; color: "black" &#125; &#125;, methods: &#123; handleClick: function()&#123; this.styleObj.color = this.styleObj.color==="black" ? "red" : "black" &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; style的数组绑定 将div节点绑定一个内联的style样式，这个样式的值由一个叫styleObj的数组来决定，数组中每个对象的值都可以添加到样式的值里 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div :style="styleObj" @click='handleClick' &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; styleObj: &#123; color: "black" &#125; &#125;, methods: &#123; handleClick: function()&#123; this.styleObj.color = this.styleObj.color==="black" ? "red" : "black" &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的条件渲染v-if与v-show v-if=”false”是将该标签所对应的dom节点从页面上移除掉，而v-show=”false”是指该标签所对应的dom节点依然存在，只是加了个标签style=”display:none”。所以同样控制dom元素显示与否的场景下，更推荐v-show指令，这样使得页面性能更好。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的条件渲染&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div v-if="show"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div v-show="show"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, msg: 'hello Vue' &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-else-if与v-else v-else只能与v-if成对出现，且必须要连在一起使用，否则Vue会报错。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的条件渲染&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div v-if="show === 'a'"&gt;this is a&lt;/div&gt; &lt;div v-else-if="show === 'b'"&gt;this is b&lt;/div&gt; &lt;div v-else&gt;this is others&lt;/div&gt; &lt;button @click="handleClickB"&gt;change to b&lt;/button&gt; &lt;button @click="handleClickOthers"&gt;change to others&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: 'a', &#125;, methods: &#123; handleClickB: function()&#123; this.show = 'b' &#125;, handleClickOthers: function()&#123; this.show = 'others' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的set方法12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的set方法&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div v-for="(item,key,index) of userInfo"&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;key&#125;&#125; : &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; userInfo: &#123; name: 'su', age: 23, gender: 'male', &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在使用v-for遍历一个数组时，如果想要往userInfo中添加一项数据，不能通过userInfo[3]=””这种下标的形式来进行赋值，因为这样的话数据虽然得到了更改，但是页面并不会发生响应式的变化。在Vue中想要改变数组，要通过数组的几种变异方法，或者给这个对象一个新的引用，除了这两种方法，Vue还提供了一个叫做set的方法向对象中注入数据或者更改数据。 123Vue.set(vm.userInfo,"address","hangzhou") // Vue全局set方法给数组增加数据vm.$set(vm.userInfo,"address","hangzhou") // vm实例set方法给数组增加数据 123Vue.set(vm.userInfo,"age", 24) // Vue全局set方法改变数组中的数据vm.$set(vm.userInfo,"age", 24) // vm实例set方法改变数组中的数据 使用Vue组件的几个细节点is标签 根据h5规范，&lt;tbody&gt;标签内部只能写&lt;tr&gt;标签，所以不能在&lt;tbody&gt;标签里直接写Vue组件。而是通过is属性来实现正确的效果。同理，&lt;ul&gt;、&lt;ol&gt;标签内部只能写&lt;li&gt;标签，&lt;select&gt;标签内部只能写&lt;option&gt;标签，都可以通过is属性来解决模板标签渲染时出现bug的情况。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;is标签&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;table&gt; &lt;tbody&gt; &lt;!-- 错误写法 --&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;!-- 推荐写法(使用is标签) --&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; Vue.component('row',&#123; template:'&lt;tr&gt;&lt;td&gt;this is a row&lt;/td&gt;&lt;/tr&gt;' &#125;) var vm = new Vue(&#123; el: '#root' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 非根组件中的data里只能定义为函数 原因是根组件只会被调用一次，而非根组件（子组件）可能会被调用很多次。一个子组件在不同的地方调用时，里面的data可能会产生冲突。通过函数来返回一个对象的目的就是让每一个子组件都拥有一个独立的数据存储。 12345678Vue.component('row',&#123; data: function()&#123; return &#123; content: 'this is a row' &#125; &#125;, template: '&lt;tr&gt;&lt;td&gt;&#123;&#123; content &#125;&#125;&lt;/td&gt;&lt;/tr&gt;'&#125;) $refs在html标签内使用ref 在html标签内使用ref，得到的是该标签对应的dom节点。vue就可以通过这种方式来操作dom节点。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$ref&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div @click="handleClick" ref = 'hello' &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function()&#123; alert(this.$refs.hello.innerHTML) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue组件内使用ref 在Vue组件内使用ref，得到的是该组件数据的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;累加器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;counter ref="num1" @change="add"&gt;&lt;/counter&gt; &lt;counter ref="num2" @change="add"&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component('counter',&#123; template:'&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', data: function()&#123; return &#123; number: 0 &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number ++, this.$emit('change') &#125; &#125; &#125;) var vm = new Vue(&#123; el: "#app", data: &#123; total: 0, &#125;, methods: &#123; add: function()&#123; this.total = this.$refs.num1.number + this.$refs.num2.number; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件参数校验与非props特性组件参数校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;div id="root"&gt; * &lt;child :content="&#123;&#125;"&gt;&lt;/child&gt; // 带冒号则""里面是一个js表达式 * &lt;/div&gt; */// 传递的参数只能是StringVue.component('child',&#123; props: &#123; content: String &#125;&#125;)// 传递的参数可以是字符串也可以是数字类型Vue.component('child',&#123; props: &#123; content: [Number, String] &#125;&#125;)// 传递的参数只能是String，而且必须要传Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: true &#125; &#125;&#125;)// 传递的参数只能是String，而且可传可不传，如果不传那么给它一个默认值Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: false, default: 'default value' &#125; &#125;&#125;)// 传递的参数只能是String，而且必须要传，并且该字符串的长度必须大于5Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: true, // 自定义校验器 (参数value为一个形参，代表传递的参数)) validator: function(value) &#123; return (value.length &gt; 5) &#125; &#125; &#125;&#125;) 非props特性 子组件内部并没有通过props参数来接收在父组件里面的子组件模板中绑定的属性被称为非props属性。 非props特性不能在子组件内部通过插值表达式的形式来使用。 非props特性会被作为一个class类渲染到页面的dom元素中。 Vue中的插槽slot单个插槽除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。 (这点很类似于input里面的placeholder占位属性) 最初在 &lt;slot&gt;标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 12345678910111213141516&lt;!-- my-component 子组件有如下模板： --&gt;&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 默认内容（只有在没有要分发的内容时才会显示） &lt;/slot&gt;&lt;/div&gt;&lt;!-- 父组件的模板 --&gt;&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些要分发内容&lt;/p&gt; &lt;p&gt;这是更多要分发的内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 123456789&lt;!-- 渲染结果 --&gt;&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名插槽使用场景：设计组合使用的组件时，内容分发 API 是非常有用的机制。 &lt;slot&gt;元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。 仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。 12345678910111213141516171819202122&lt;!-- app-layout子组件模板 --&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;&lt;!-- 父组件模板 --&gt;&lt;app-layout&gt; &lt;h1 slot="header"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot="footer"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 12345678910111213&lt;!-- 渲染结果 --&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 单个插槽和具名插槽示例1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的插槽slot&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;child&gt; &lt;h1&gt;Vue&lt;/h1&gt; &lt;div class="footer" slot="footer"&gt;footer&lt;/div&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child',&#123; template: `&lt;div&gt; &lt;slot name="header"&gt;I'm a slot header&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div&gt;Body&lt;/div&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域插槽使用场景：当子组件作循环或者某一部分，它的dom结构不是本身自己定义，而是由父组件来传递一个展示的模板。 作用域插槽必须使用&lt;template&gt;标签进行包裹，同时这个插槽使用v-slot=&quot;slotProps&quot;来声明父组件接收到的子组件数据都存放在哪。&lt;template&gt;标签（在父组件中）内部就是子组件模板的信息，来指明子组件展示(渲染)的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的作用域插槽&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;child&gt; &lt;!-- 想要接收子组件传递过来的数据，需要使用template标签进行包裹并使用slot-scope属性来声明接收的数据存放在哪 --&gt; &lt;template v-slot="slotProps"&gt; &lt;!-- 使用子组件传递过来的数据 --&gt; &lt;h1&gt;&#123;&#123;props.item&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child',&#123; data:function ()&#123; return &#123; list: [1,2,3,4,5] &#125; &#125;, template: `&lt;div&gt; &lt;ul&gt; &lt;slot v-for="item of list" :item="item" // 子组件可以向父组件的插槽传递数据 &gt;&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue动态组件 &lt;component :is=&quot;xxx&quot;&gt;&lt;/component&gt;来调用子组件。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue动态组件&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;!-- 写法一:使用v-if来实现两个组件之间的切换显示 --&gt; &lt;child-one v-if="type === 'child-one'"&gt;&lt;/child-one&gt; &lt;child-two v-if="type === 'child-two'"&gt;&lt;/child-two&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;!-- 写法二:使用Vue自带的component标签来实现动态组件的效果 --&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child-one',&#123; template: '&lt;div&gt;child-one&lt;/div&gt;' &#125;) Vue.component('child-two',&#123; template: '&lt;div&gt;child-two&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type: 'child-one' &#125;, methods: &#123; handleClick: function()&#123; this.type = this.type === 'child-one' ? 'child-two' : 'child-one' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由（Vue Router）网页 URL 组成部分12345678// http://127.0.0.1:8881/01-hash.html?a=100&amp;b=20#/aaa/bbblocation.protocol // 'http:'location.hostname // '127.0.0.1'location.host // '127.0.0.1:8881'location.port // '8881'location.pathname // '/01-hash.html:'location.search // '?a=100&amp;b=20'location.hash // '#/aaa/bbb' hash模式 hash 变化会触发网页跳转，即浏览器的前进、后退 hash 变化不会刷新页面，SPA 必需的特点 hash 永远不会提交到 server 端（前端自生自灭，无需后端支持） hash - window.onhashchange 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;hash test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hash test&lt;/p&gt; &lt;button id="btn1"&gt;修改 hash&lt;/button&gt; &lt;script&gt; // 🌟🌟🌟 监听 hash 变化，包括： // a. JS 修改 url // b. 手动修改 url 的 hash（在浏览器地址栏直接改 // c. 浏览器前进、后退 window.onhashchange = (event) =&gt; &#123; console.log('old url', event.oldURL) console.log('new url', event.newURL) console.log('hash:', location.hash) &#125; // 页面初次加载，获取 hash document.addEventListener('DOMContentLoaded', () =&gt; &#123; console.log('hash:', location.hash) &#125;) // JS 修改 url document.getElementById('btn1').addEventListener('click', () =&gt; &#123; location.href = '#/user' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; H5 history模式 用 url 规范的路由，但跳转时不刷新页面 需要后端支持（无论访问什么路由，始终保证只返回一个index.html这个界面） 然后再通过pushState的方式进行前端路由的切换 H5 history - history.pushState 和 window.onPopstate 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;history API test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;history API test&lt;/p&gt; &lt;button id="btn1"&gt;修改 url&lt;/button&gt; &lt;script&gt; // 页面初次加载，获取 path document.addEventListener('DOMContentLoaded', () =&gt; &#123; console.log('load', location.pathname) &#125;) // 打开一个新的路由 // 【注意】用 pushState 方式，浏览器不会刷新页面 document.getElementById('btn1').addEventListener('click', () =&gt; &#123; const state = &#123; name: 'page1' &#125; console.log('切换路由到', 'page1') history.pushState(state, '', 'page1') // 重要！！ &#125;) // 监听浏览器前进、后退 window.onpopstate = (event) =&gt; &#123; // 重要！！ console.log('onpopstate', event.state, location.pathname) &#125; // 需要 server 端配合，可参考 // https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 两种模式的选择 to B 的系统推荐用hash，简单易用，对 url 规范不敏感 to C 的系统，可以考虑选择H5 history，但需要服务端支持 能选择简单的，就别用复杂的，要考虑成本和收益 Vuex使用Vuex来实现数据共享Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。在Vue的大型项目开发之中，Vue.js只能承担视图层的主要内容，而当涉及到大量数据间的传递，往往都要通过vuex这个数据框架来完成。虽然bus总线的作法有时候也可以完成效果，但写起来还是比较麻烦。 Vuex其实就是一个单向数据的改变流程。使用vuex需要先安装vuex：npm install vuex --save，之后要在项目的入口文件main.js中引入这个包并在创建根实例的时候把store传递进去来使用： 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; city: '杭州' &#125;, actions: &#123; changeCity (ctx, city) &#123; // ctx是一个上下文，可以通过它来执行commit方法 ctx.commit('changeCity', city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city &#125; &#125;,&#125;) vuex中的map映射api在每次调用vuex公用数据中的city的时候，都要写this.$store.state.city这样的一串，而vuex就提供了一个map映射api来简化这样的代码，先要引入需要映射的数据，然后通过...扩展运算符将state里面的city映射到HomeHeader这个组件的computed计算属性中，然后就可以直接通过this.city来调用这个数据了(如果是mutations则可以映射到组件的methods方法中) 12345678import &#123; mapState &#125; from 'vuex'export default &#123; name: 'HomeHeader', computed: &#123; ...mapState(['city']) &#125;&#125; vuex中的getter和modulevuex中的getter很类似于组件中的computed计算属性，如果需要根据vuex的state里的数据来计算出一个新的数据的时候，就可以通过getter来进行实现，从而避免数据的冗余。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA &#x3D; &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB &#x3D; &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store &#x3D; new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态 vue中的内置组件&lt;keep-alive&gt;&lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和&lt;transition&gt;相似，&lt;keep-alive&gt;是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中。 &lt;keep-alive&gt;可以接受可选参数： include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 当组件在&lt;keep-alive&gt;内被切换，它的activated和deactivated这两个生命周期钩子函数将会被对应执行。 123456789101112131415methods: &#123; getDetailInfo () &#123; axios.get('/api/detail.json', &#123; params: &#123; id: this.$route.params.id &#125; &#125;).then(this.handleGetDataSucc) &#125;&#125; mounted () &#123; this.getDetailInfo() &#125;, activated () &#123; this.getDetailInfo() // 每次页面被加载的时候，都重新发送一个ajax请求 &#125; Vue中的动画特效Vue中css动画原理使用&lt;transition&gt;标签来实现一个显示隐藏的过渡动画效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- &lt;link rel="stylesheet" href="./animate.css"&gt; --&gt; &lt;title&gt;vue中css动画原理&lt;/title&gt; &lt;style&gt; .fade-enter &#123; opacity: 0 &#125; .fade-enter-active &#123; transition: opacity 3s &#125; .fade-leave-to &#123; opacity: 0; &#125; .fade-leave-active &#123; transition: opacity 1s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade"&gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中使用animate.css库 animate.css提供的动画类型其实是css3中@keyframe的动画效果。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./animate.css"&gt; &lt;title&gt;在Vue中使用animate.css库&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition enter-active-class = "animated tada" leave-active-class = "animated zoomOutLeft" &gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中同时使用过渡和动画使用appear类和appear-active-class类来给元素在第一次载入的时候也添加一个animated动画。 12345678&lt;transition appear enter-active-class = "animated tada" leave-active-class = "animated zoomOutLeft" appear-active-class = "animated swing"&gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt;&lt;/transition&gt; 在Vue中同时使用过渡和动画。在同时使用两种效果时它们的动画时间可能不一样，所以要再添加上type=&quot;transition&quot;这个属性来解决这个问题使得整体动画时间以transition为准。还可以使用:duration=&quot;{enter: 3000, leave: 5000}&quot;来自定义入场和出场的动画时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./animate.css"&gt; &lt;!-- 引入animate.css动画库 --&gt; &lt;title&gt;在Vue中同时使用过渡和动画&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: opacity 3s; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name = "fade" appear enter-active-class = "animated tada fade-enter-active" leave-active-class = "animated zoomOutLeft fade-leave-active" appear-active-class = "animated swing" &gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的JS动画和Velocity.js动画库Vue中提供了很多js动画的钩子。@before-enter、@enter、@after-enter等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="./velocity.js"&gt;&lt;/script&gt; &lt;!-- 引入velocity.js动画库 --&gt; &lt;title&gt;Vue中的JS动画和Velocity.js动画库&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade" @before-enter="handleBeforeEnter" @enter="handleEnter" @after-enter="handleAfterEnter" &gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125;, handleBeforeEnter: function(el)&#123; el.style.opacity = 0 &#125;, handleEnter: function(el, done)&#123; //这个done为回调函数，执行这个函数After-enter才会执行 Velocity(el,&#123;opacity:1&#125;,&#123;duration: 1000, complete: done&#125;) &#125;, handleAfterEnter: function(el)&#123; alert('动画结束') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中多个元素或组件的过渡使用v-if和v-else来写两个元素的toggle显示。&lt;transition&gt;标签内可以添加一个mode=&quot;in-out&quot;属性来确定元素显示隐藏的先后方式。由于Vue有一个会复用dom的机制，为了防止动画过渡不成功，要给元素标签上加一个key值。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Vue中多个元素的过渡&lt;/title&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0 &#125; .v-enter-active, .v-leave-active &#123; transition: opacity 1s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition mode="in-out"&gt; &lt;div v-if="show" key="hello"&gt;hello Vue&lt;/div&gt; &lt;div v-else key="bye"&gt;bye Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中多个组件的过渡动画。可以用v-if、v-else的方式，也可以用动态组件的方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中多个组件的过渡&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0 &#125; .v-enter-active, .v-leave-active &#123; transition: opacity 1s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition mode="out-in"&gt; &lt;!-- 写法一:使用v-if来实现两个组件之间的切换显示 --&gt; &lt;child-one v-if="type === 'child-one'"&gt;&lt;/child-one&gt; &lt;child-two v-if="type === 'child-two'"&gt;&lt;/child-two&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;transition mode="in-out"&gt; &lt;!-- 写法二:使用Vue自带的component标签来实现动态组件的效果 --&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child-one',&#123; template: '&lt;div&gt;child-one&lt;/div&gt;' &#125;) Vue.component('child-two',&#123; template: '&lt;div&gt;child-two&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type: 'child-one' &#125;, methods: &#123; handleClick: function()&#123; this.type = this.type === 'child-one' ? 'child-two' : 'child-one' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>refs</tag>
        <tag>vue父子间通信</tag>
        <tag>vue生命周期函数</tag>
        <tag>vue模版语法</tag>
        <tag>vue样式绑定</tag>
        <tag>vue条件渲染</tag>
        <tag>vue动态组件</tag>
        <tag>vue组件原生事件</tag>
        <tag>is</tag>
        <tag>props</tag>
        <tag>slot</tag>
        <tag>animate</tag>
        <tag>velocity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Vue+Webpack打造todoApp应用]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%9F%BA%E4%BA%8EVue%2BWebpack%E6%89%93%E9%80%A0todoApp%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 此源码基于vue和webpack编写。前置知识有JavaScript、Css、Html、ES6、Stylus、Vue、Webpack、Webpack-cli、Bable等。 源码地址此Demo源码托管在本人Github，点击此链接直达。 使用步骤安装依赖 需要安装npm包管理工具 需要安装的npm依赖包详见pakage.json 开发环境 启动项目：npm run dev 浏览器调试：localhost:8000 生产环境 项目打包：npm run build 过程记录笔记前端的价值 搭建前端工程 网络优化（HTTP的理解） API定制 Node.js层 初始化一个项目 npm init 需要安装的依赖 npm install webpack -g(全局安装webpack)npm install webpack –save-dev(局部安装webpack，并且默认是安装最新版本)npm install css-loadernpm install vue-template-compilernpm install vuenpm install vue-loader vue中的render函数 render方法的实质就是生成template模板，通过调用一个方法来生成，而这个方法是通过render方法的参数传递给他的。 Vue中$mount() Vue 的$mount()为手动挂载，在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等），之后要手动挂载上,new Vue时，el和$mount并没有本质上的区别。 “webpack –config webpack.config.js”配置的含义 “build”: “webpack –config webpack.config.js”以上配置的意义是强制终端在执行npm run build的时候调用的是本地安装的webpak，而不是全局的webpack，并且在执行npm run build命令的时候，会执行webpack.config.js文件 css-loader、style-loader说明 loader: ‘css-loader’，这个只是帮我们处理CSS文件。以下写法能帮我们把CSS样式插到HTML结构中: 1234use: [ 'style-loader', 'css-loader'] (在此之前需要安装依赖：npm install style-loader) webpack处理图片文件代码解析 代码： 123456789&#123; test: /\\.(gif|jpg|jpeg|svg)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 1024 , name: '[name]-aa.[ext]' &#125;&#125; 该代码的作用就是使用url-loader来处理后缀名为.gif、.jpg、.jpeg、.svg的文件，将其转化为base64代码，直接写在js文件里面，而不用生成一个新的文件。 使用对象的写法是为了配置url-loader的一些选项。limit:1024的含义就是当图片小于1024kb的时候，转化为base64代码，减少了HTTP请求。name配置的含义是定义输出文件的名字】(配置里面的name是原来图片的名字，ext是转化后的后缀名)可以使用下面两段代码来进行测试 12345678910111213141516body &#123; color: blue; background-image: url(../images/bg.jpg);&#125;//vue组件不能直接挂载到HTML文件中的解决方案import Vue from 'vue'import App from './app.vue'import './assets/styles/test.css'import './assets/images/bg.jpg'const root = document.createElement('div')document.body.appendChild(root)new Vue(&#123; // 将app.vue组件挂载到HTML文件中 render: (h) =&gt; h(App)&#125;).$mount(root) 使用命令：npm run build，将可以在dist目录下看到一张转化后的图片(bg-aa.jpg) webpack强大的地方之一就是能够处理任何的依赖文件，比如在CSS文件中定义的图片，webpack也会使用配置好的url-loader将其进行处理。 CSS预处理器(使用stylus)安装： npm install stylus stylus-loader 配置： 1234&#123; test: /\.styl/, use: ['style-loader', 'css-loader', 'stylus-loader']&#125;, 使用npm安装依赖包的细节 1、npm install webapck –save-dev：表示安装的webpack只在开发环境(dev)中使用，项目发布之后就不会用到，简写方式为npm i webapck -D。2、npm install vue –save：表示安装的vue在开发环境和正式环境中都会被用到，简写方式为npm i vue -S webpack-dev-server的配置和使用 安装：npm i webpack-dev-server配置：”dev”: “webpack-dev-server –config webpack.config.js” 通过以上的配置，那么使用命令npm run dev也能够实现打包项目，并且它是开发模式打包项目 如何分辨是在开发环境还是正式环境 步骤一： npm i cross-env步骤二：为了能够在不同的平台都运行webpack.config.js文件，我们需要在package.json中这样来配置：“build”: “cross-env NODE_ENV=production webpack –config webpack.config.js”,“dev”: “cross-env NODE_ENV=development webpack-dev-server –config webpack.config.js”步骤三：配置webpack.config.js文件 如何让打包好的js文件自动包含到HTML文件中 步骤一：npm install html-webpack-plugin]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>es6</tag>
        <tag>stylus</tag>
        <tag>webpack</tag>
        <tag>npm</tag>
        <tag>todo</tag>
        <tag>bable</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目中的数据可视化]]></title>
    <url>%2F2017%2F11%2F21%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[近几年随着大数据逐渐火热，数据可视化也就显得格外重要。。 最近几年随着大数据的兴起，以及浏览器性能的提升，数据可视化成为了一个热点，前端也冒出来了很多数据可视化的岗位。本人也做过一些数据可视化相关的产品，下面聊聊对数据可视化的一些思考。本文的数据可视化一般专指互联网公司web前端接触的数据可视化。 数据可视化，是关于数据视觉表现形式的科学技术研究。其中，这种数据的视觉表现形式被定义为，一种以某种概要形式抽提出来的信息，包括相应信息单位的各种属性和变量。它是一个处于不断演变之中的概念，其边界在不断地扩大。主要指的是技术上较为高级的技术方法，而这些技术方法允许利用图形、图像处理、计算机视觉以及用户界面，通过表达、建模以及对立体、表面、属性以及动画的显示，对数据加以可视化解释。与立体建模之类的特殊技术方法相比，数据可视化所涵盖的技术方法要广泛得多. ———————-百度百科 而前端常说的视觉可视化大部分是指借助曲线图表等展示形式把一些相关数据更直接、形象、生动、具体的展示在web页面上。要做一个好的数据产品是需要 产品经理-&gt;设计师-&gt;前端-&gt;后端-&gt;用户整个链路紧密配合密切合作并且协调的。 产品需要懂数据可视化的理论基础，哪些数据可以可视化，哪些数据是用户最想要的。 设计师包括视觉和交互，需要理清楚数据怎么展示最合理，曲线，柱状图，饼状图，都有哪些优缺点，不能仅仅为了美观设计了一个好看的图形，而不顾实际数据情况，展示出来就很奇怪。 前端其实在里面是最紧密的一环，数据怎么获取，什么格式对前后端最友好，采用什么技术方案，是svg的库，还是canvas的库，是自己撸还是用现成的库。实现成本有多高，性能、扩展性怎么样都是需要考虑的问题 后端需要考虑的就是数据的拉取，需要考虑数据格式以及能获取哪些数据。 以上分工只是一个粗略的说明。这里看了一篇文章小心，这饼有毒！论饼图的正确打开方式里面讲的一些经历可能大家都遇到过，我也深有同感。 我的这些数据，好像柱状图、折线图、饼图都能表示啊，到底应该选哪个？ 饼图和环形图也差不多，取决于我要不要在中间显示其他内容吗？ 我可不可以将数据映射到饼图的半径维度上 数据可视化最重要的不是好看，而是让人一目了然的明白这个图表传达出来的意思。 其实这方面是有相关的信息图表学的相关知识储备的话就不会犯这些错误了。支付宝有个G2 里面有两个相关的图表学基础知识介绍，我个人认为这是G2 比echart更近一步，更规范化的点之一。 详见这里 可视化基础-图表使用建议 https://antv.alipay.com/vis/doc/chart/classify/compare.html 可视化基础-图表设计指引规范 https://antv.alipay.com/vis/doc/design/index.html 以及经典文献： 在数据可视化的研究和实现中，《数据可视化》、《The Grammarof Graphics》、《深入浅出统计学》、《计算机图形学几何工具算法详解》、《Visualization Analysis and Design》 、《ggplot2：数据分析与图形艺术》 。 叨叨了这么多基础，下面说说前端在可视化里的一些相关的发展和技术选型 首先需要明白一个观点：技术选型没有一劳永逸的，永远是根据你的项目实际情况以及你的个人偏好和技术基础来做的选择。 下面说说常见的一些图表库和相关技术： 1. echartsecharts算是国产的图表库里最好的了。EFE团队也是国内技术实力最雄厚的可视化团队.采用canvas作为渲染容器。底层一些实现比如鼠标事件啥的用的自己开发的zrender框架。 echart2.0对应不同的组件比如坐标轴图例是用不同的canvas来渲染的，echart3之后都合并到一个canvas里面了，猜测应该是底层的框架升级了 博客： http://efe.baidu.com/， 这个博客更的很慢了。 http://echarts.baidu.com/blog/posts/ 这个更得多点。 2.highcharts这个框架用的人也不少，主打就是IE6也支持。。。。。。。。。然并卵微软都不支持IE6了。淘宝连ie8都不支持了。。。。收费的库，底层用的SVG。私以为他的API使用起来没有Echart友好。 3.G2-支付宝蚂蚁金服的产品，图标容器为canvas，玉伯的团队开发的。怎么说呢。。这个东西看着还不错，不过实际使用的时候大部分人还是会不由自主的去选择前面两个，大阿里的开源东西就是这么个鬼情况。东西是不错，就怕搞着搞着团队没了。。 4.d3.jsd3也算是资历比较老的一个产品了，采用svg作为图标容器。刚开始出来的时候各种动画比较惊艳，图标类型也比较丰富，感觉echarts一开始也参照它的图表类型新增了好几个图表示例。 d3的优点是各种示例demo比较完善适合拿来就用，缺点就是demo不适合二次开发，熟悉api的话也可以直接自己画，他的api是对svg的dom的一种整理和兼容，类比于jquery对应html的dom。 其他： 一两年前阿里妈妈貌似出过一个图表库，我当初还给他们留言说：为啥不先出一个移动端的图表库说不定更有市场。貌似最后沦为KPI的牺牲品 以上就是最常见的一些图表库，那么我们需要根据实际项目需要来做一些技术选型。 移动端图表库，echarts和G2应该都可以。pc端就看个人喜好了。报表类型的项目看设计师画的效果稿吧，echarts可定制性最高，G2没用过，highcharts文档不健全。 监控类型的项目需要频繁更新数据的优选选择canvas的性能应该更好。 下面说说数据可视化的一般应用场景： 报表类 报表类使用场景最多，使用的图表也最简单一般echarts里面的示例图表就能满足了。 监控类 监控类稍微复杂点，一般涉及到实时性和稳健性，开发的时候需要考虑后端的接口性能，以及页面图表渲染的性能问题，数据量大了之后对前后端都很有挑战性。做起来也比较有意思，和业务场景结合起来能做一整套的数据可视化的产品系统。 动效PR稿类 这种类型的项目一般都有一个特点：急，炫，累。项目周期很急，动画效果要很炫，干起活来很累。偶尔做做还行，一直搞，就感觉路走的有点偏，而且一般很少能找到现成的库和框架，前期需要大量的技术调研和技术储备。相关的库一般需要canvas的效果库，webGL的库，比如:http://www.pixijs.com/ ，threejs，要求更高的可能需要一些游戏库来帮忙了比如：https://www.egret.com/ ，http://www.createjs.com/等等。 地图类 这类的数据可视化单独拿出来是因为现在越来越多的数据可视化场景里需要用到地图。这也是数据可视化最麻烦的一直，一般我们借助echart的地图，或者百度地图，高德地图等来开发，其实百度地图也出了个地图可视化的库 http://mapv.baidu.com/ ，展示效果没有echart好。。。。需要定制开发的同学其实可以直接拿百度地图之类的然后在地图上蒙一层覆盖类，然后在这个覆盖类里填充一个canvas做一些自己的扩展参见百度地图的demo；背后的地图。。可以用css隐藏掉。。。。。 数据可视化系统 这个范畴比较大，还是需要看业务场景，某些业务场景就特别适合做一堆相关联的数据可视化系统。做好了成就感还是满满的。 ================================================ 参考于：https://www.56way.com/p/102.html]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>前端</tag>
        <tag>数据可视化</tag>
        <tag>数据</tag>
        <tag>echarts</tag>
        <tag>highcharts</tag>
        <tag>G2</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的基础知识]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vue的三个特点： 易用 123&lt;div id='app'&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el:'#app', data:&#123; message:'hello vue!' &#125;&#125;) 灵活（渐进式） 无论是单页面程序还是多页面程序，我们首先都需要通过声明式渲染来渲染页面上的每一个字段；因为我们的界面需要去展现一些功能，展现一些信息，就需要渲染来实现； 把一些公共的头部和公共的尾部抽出来去做成一个组件； 做单页面程序用到路由,需要把vue-resource、vue-router等等插件拉进来去做一个路由的功能； 如果实现的业务足够复杂，需要用到大量的组件，而且难以管理这些组件的状态，此时就需要引进vuex，用来集中管理组件的状态； 整个项目做完之后，需要通过构建工具来build系统，提升效率，最后形成一个完整的项目。 高效 vue的min+gzip的运行大小：16kb； 超快虚拟DOM； 最省心的优化。 Vue组件的重要选项： data（数据源） methods（方法） watch（监听） Vue模版指令（html和vue对象的粘合剂）： 数据渲染：v-text 、v-html 、&#123;&#123; &#125;&#125; 控制模块隐藏：v-if 、v-show 渲染循环列表：v-for 事件绑定：v-bind 表单渲染：v-model: 用于文本框、下拉框、单选复选、textarea等等，具有一个双向绑定的特性。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几道Codewars上面的编程题]]></title>
    <url>%2F2017%2F07%2F24%2F%E8%AE%B0%E5%87%A0%E9%81%93Codewars%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每次做完看到别人的答案：wtf ??? NO.1题目描述： 解法: 12345678function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); Math.min()方法: 可以得到数组中最小的数,Math.min.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 splice()方法: arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 NO.2题目描述： 我的解法： 123456function isTriangle(a,b,c)&#123; var p = (a + b + c)/2; var S = Math.sqrt(p*(p-a)*(p-b)*(p-c)); return S &gt; 0;&#125; 得票最高的解法： orz。。 NO.3题目描述： 我的解法： 123456789101112function sumArray(array) &#123; if(!array || array == null)&#123;return 0&#125;; var max = Math.max.apply(null,array); var min = Math.min.apply(null,array); array.splice(array.indexOf(max),1); array.splice(array.indexOf(min),1); console.log(array); for(var sum = 0,i = 0;i &lt; array.length;i++)&#123; sum += array[i]; &#125; return sum;&#125; 得票最高的解法： 1sumArray = a =&gt; a ? a.sort((x, y) =&gt; x - y).slice(1, -1).reduce((s, e) =&gt; s + e, 0) : 0 ??? (黑人问号脸。。 NO.4题目描述： 我的解法： 1234567var gimme = function(inputArray) &#123; let min = inputArray.indexOf(Math.min(...inputArray)), max = inputArray.indexOf(Math.max(...inputArray)); if (min === 0 &amp;&amp; max === 2 || max === 0 &amp;&amp; min === 2) return 1; if (min === 1 &amp;&amp; max === 2 || max === 1 &amp;&amp; min === 2) return 0; if (min === 0 &amp;&amp; max === 1 || max === 0 &amp;&amp; min === 1) return 2;&#125;; 得票最高的解法： 溜了溜了。。 PS。虽然这些高票答案精简得不行，但至少我写的代码块可读性强啊。。（微笑]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>coding</tag>
        <tag>算法</tag>
        <tag>codewars</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【二】]]></title>
    <url>%2F2017%2F07%2F20%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO : 前端面试。 基础部分 1.prototype和proto的关系是什么2.meta viewport原理3.域名收敛是什么4.float和display：inline-block；的区别5.前端优化策略列举6.首屏、白屏时间如何计算7.闭包8.作用域链9.ajax如何实现、readyState五种状态的含义10.jsonp如何实现11.怎么处理跨域12.restful的method解释13.get和post的区别14.事件模型解释15.编写一个元素拖拽的插件16.编写一个contextmenu的插件17.编写web端cookie的设置和获取方法18.兼容ie６的水平垂直居中19.兼容ie的事件封装20.h5和原生android的优缺点21.编写h5需要注意什么22.xss和crsf的原理以及怎么预防23.css优先级24.如何实现点击radio的文字描述控制radio的状态（通过label实现）25.delegate如何实现 框架原理angularjs 1.angular的directive怎么写2.angular的脏检查（双向绑定）是如何实现的3.依赖注入如何实现4.scope如何实现5.$parse模块如何实现（主要自己写了一个类似的库） react 1.react在setState后发生了什么（直接说了setState源码）2.flux解释3.对react有什么了解（直接说了react中虚拟dom内部表示，mount过程源码和同步过程源码） jsBridge 如何说服对方使用jsBridge requirejs 1.amd和cmd区别，怎么了解到这些区别的，是否是去看了规范2.requirejs那些经常用的方法，然后对其进行解释 weex weex实现大致原理（只写过demo，面试管很好没有难为我，只问了这一个问题） http协议 1.accept是什么，怎么用2.http协议状态码，302和303的区别3.前端缓存如何实现、etag如何实现、etag和cache-control的max-age的优先级哪个比较高以及为什么、cache-control和expire优先级哪个比较高以及为什么 node 1.Buffer模块是干什么的2.Stream是什么，使用的两种模式3.http模块如何将异步处理方式实现成同步处理方式，具体解析请参考http模块如何将异步处理转成同步处理http://blog.csdn.net/wanglei20116527/article/details/62892070 其他问题 1.utf8和gbk的区别2.知道页面上某个点的坐标，如何获取该坐标上的所有元素3.angular、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）4.7点15分小于180度的夹角是多少5.大数相加6.给５升和６升的水杯如何倒出３升的水7.一班喜欢足球的人60%，喜欢排球的70%，喜欢篮球的80%，求喜欢足球和排球的占多少8.前端异常监测如何实现9.直播点赞按钮的冒泡功能如何实现10.js的uglify如何实现11.项目架构、如何带人（自己带过一个小团队）12.前端工程化方面做了哪些东西 面试中的收获 最开始面试时只阅读过angular源码，一面完后面试官对我说react用的不熟悉没关系，弄懂原理也可以，之后三天疯狂阅读react源码，对于react中虚拟dom内在表示、mount过程、setState的同步过程有了清晰的认识。面试官建议去阅读node的http模块和Stream模块源码，其中node-v0.1.100的http模块源码已经阅读完，并且写了一个基于net模块的http模块。node-v6.9.1的Stream模块源码现在还在阅读中。初步了解了前端异常监测，并且了解了百姓网、腾讯和阿里在前端异常监测的一些方案和框架。阅读了大量前端工程化方面的博文，对前端工程化有了进一步的理解。了解了angular和react产生背景。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>http</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html/css</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【一】]]></title>
    <url>%2F2017%2F07%2F18%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO ：这段时间遇到的面试题。 前端页面由哪三层构成及各层的作用 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本语言负责。解决了页面上“内容应该如何对事件作出反应”的问题。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea; 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote; 空元素：br、meta、hr、link、input、img。 html5有哪些新特性、移除了那些元素？ 新特性： 语义化更好的内容元素，比如 article、footer、header、nav、section，表单控件，calendar、date、time、email、url、search; 一些功能标签，如绘画 canvas，用于媒介播放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除； 新的技术，如webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； meta标签 charset属性：单独使用，设置文档字符及编码格式。写法：&lt;meta charset=”UTF-8”&gt;常见的中文编码格式： B-2312: 国标码，简体中文 GBK：扩展的国标编码，简体中文 UTF-8: 万国码 Unicode码，基本兼容各国语言 name属性：需配合content属性使用，主要用于给搜索引擎提供必要信息。写法：&lt;meta name=”属性值” content=”属性值详细内容”重要属性值： author 作者，声明网站作者，常用公司网址表示 keywords 网站关键字，多个关键字，用英文逗号分隔 description 网页描述，搜索引擎显示在title下的描述内容 http-equiv属性: 也需要与content属性配合使用，前者是用于声明即将修改哪些属性值，而实际的属性值内容，在content中描述。而这个属性的用途是把 content 属性关联到 HTTP 头部。常用属性值： Content-Type HTML4.01之前的文档内容编码声明。 refresh 网页刷新 set-Cookie 设置浏览器cookie缓存 http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 当服务器向浏览器发送文档时，会先发送许多名称/值对。虽然有些服务器会发送许多这种名称/值对，但是所有服务器都至少要发送一个：content-type:text/html。这将告诉浏览器准备接受一个 HTML 文档。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv="charset" content="iso-8859-1"&gt;&lt;meta http-equiv="expires" content="31 Dec 2008"&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text&#x2F;htmlcharset:iso-8859-1expires:31 Dec 2008 对标签语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 以前端角度出发做好SEO需要考虑什么 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 HTML与XHTML二者有什么区别 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 DOCTYPE作用是什么以及标准模式与兼容模式的区别 声明位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 问：如果我不放入 ，HTML5还会工作么？答：不会，浏览器将不能识别他是HTML文档，同时HTML5的标签将不能正常工作。 iframe有哪些缺点 iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO； iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么以及它该如何使用 作用：label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 用法： 1234&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type=“text“name="Name" id="Name"/&gt;&lt;label&gt;Date:&lt;input type="text" name="B"/&gt;&lt;/label&gt; canvas和svg图形的区别是什么 简述盒模型 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。CSS3中有个box-sizing属性可以控制盒子的计算方式: W3C盒子模型：content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。 IE6盒子模型：border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。 position的几个取值以及它们定位的原点 absolute：生成绝对定位的元素，相对于值不为static的第一个父元素进行定位，absolute元素脱离了文档流 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位，relative元素偏移的时候不会改变它占据的空间 static：默认值。没有定位，元素出现在正常的流中忽略 top, bottom, left, right z-index 声明） fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）fixed元素也脱离了文档流 inherit：规定从父元素继承 position 属性的值。 position的absolute与fixed的异同点 相同： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上 区别： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 display的取值以及它们的作用 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。象行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 像块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值。 CSS3的Flexbox（弹性盒布局模型）以及适用场景 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做居中，能对不同屏幕大小自适应。 在布局上有了比以前更加灵活的空间。 CSS中的文档流普通流就是正常的文档流，在HTML里面的写法就是从上到下，从左到右的排版布局。其中涉及到了块状元素和内联元素。脱离文档流的几个属性：绝对定位(absolute)、固定定位(fixed)、浮动(float)。 请列举几种可以清除浮动的方法 浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部不存在其他普通流元素了，从而表现出高度为0，也就是高度塌陷的问题。 添加额外标签，例如&lt;div style=”clear:both”/div&gt; 使用br标签和其自身的html属性，例如&lt;br clear=”all” /&gt; 父元素设置 overflow：hidden；在IE6中还需要触发hasLayout，例如zoom:1； 父元素设置 overflow：auto；同样IE6需要触发hasLayout； 父元素也设置浮动； 父元素设置display: table； 使用 :after 伪元素；由于IE6-7不支持 :after，使用 zoom: 1 触发hasLayout。 在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称BFC。 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。 IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。 对BFC规范的理解 BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动、防止与浮动元素重叠、以及多栏布局的一种方式。 请列举几种隐藏元素的方法 visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。 opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 display: none；元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。 HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态 height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。 filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。 CSS选择器 元素选择器 a{} 伪元素选择器 ::before{} 类选择器 .myClass{} 属性选择器 [type=radio]{} 伪类选择器 :hover{} li:nth-child ID选择器 #myId{} 组合选择器 [type=checkbox]+label{} 否定选择器 :not(.link){} 通用选择器 * CSS伪类与CSS伪对象的区别 CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西，根本区别在于：它们是否创造了新的元素（抽象） 伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类。 伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 CSS3新增伪类有那些 p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个&lt;p&gt;元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt;元素的每个&lt;p&gt;元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt;元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt;元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :checked 单选框或复选框被选中。 :disabled 控制表单控件的禁用状态。 CSS的权重规则(计算时候不进位) 行内样式：+1000 ID选择器：+100 属性选择器/类选择器/伪类选择器：+10 一个元素名/伪对象选择器：+1 其它选择器： +0 #可以继承的CSS属性 可继承的样式： font-size font-family color, UL LI DL DD DT 不可继承的样式：border padding margin width height 外边距重叠 外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 em和rem的区别 em是相对长度单位，相对于当前对象内文本的字体尺寸； em是CSS3新增的一个相对单位（root em，根em），这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 用纯CSS创建一个三角形的原理把上、左、右三条边框隐藏掉（颜色设为 transparent） 1234567div &#123; height: 0; width: 0; display: block; border: transparent solid 20px; border-left: #005AA0 solid 20px;&#125; li与li之间有看不见的空白间隔是什么原因引起的以及它的解决办法行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul &#123; list-style: none; /*解决空格问题*/ font-size: 0; &#125; li &#123; display: inline-block; height: 70px; width: 150px; line-height: 70px; text-align: center; border: #005AA0 solid 2px; /*解决空格问题*/ font-size: 16px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;li标签&lt;/li&gt; &lt;li&gt;li标签&lt;/li&gt; &lt;li&gt;li标签&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 如何解决图片与文字的不对齐 vertical-align：最有效的一种方式； margin： 需要不断调试图片的高度，精确度难以保证； position：同样是需要不断调试图片的高度，精确度难以保证。 png、jpg、gif 这些图片格式解释一下，分别什么时候用，有没有了解过webp？ GIF是一种索引颜色格式，在颜色数很少的情况下，产生的文件极小。GIF格式支持背景透明；GIF格式支持动画；GIF格式支持图形渐进；GIF格式支持无损压缩。 JPG最主要的优点是能支持上百万种颜色，从而可以用来表现照片。此外，由于JPG图片使用更有效的有损压缩算法，从而使文件长度更小，下载时间更短。JPG较GIF更适合于照片，因为在照片中损失一些细节不像对艺术线条那么明显。另外，JPG对照片的压缩比例更大，而最后的质量也更好。 PNG 是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。png是一种无损耗的图像格式。 Webp格式：Google开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。当然其也是一种有损压缩，其主要目的就是加快网络图片的传输效率，让图片能更快的显示在用户的眼前。目前所知道的只有高版本的W3C浏览器才支持这种格式，比如chorme39+，safari7+等等。 什么是CSS 预处理器/后处理器 预处理器：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器：Postcss，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 什么是CSS Hack针对不同的浏览器写不同的CSS,就是 CSS Hack。IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如： 123456789101112131415 // 1、条件Hack&lt;!--[if IE]&gt; &lt;style&gt; .test&#123;color:red;&#125; &lt;/style&gt;&lt;![endif]--&gt;// 2、属性Hack .test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */ &#125;// 3、选择符Hack * html .test&#123;color:#090;&#125; /* For IE6 and earlier */ * + html .test&#123;color:#ff0;&#125; /* For IE7 */ 什么叫优雅降级和渐进增强及其区别 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 什么是JavaScript闭包 当函数可以记住并访问所在的作用域时，就产生了闭包，即使函数是在当前作用域之外执行。闭包有如下特性： JavaScript允许你使用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量 闭包可以更新外部变量的值 用闭包模拟私有方法 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ JS如何实现面向对象和继承机制 创建对象方法： 利用json创建对象 使用JavaScript中的Object类型 通过创建函数来生成对象 继承机制： 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上 prototype模式，继承new函数的模式 直接继承函数的prototype属性，对2的一种改进 利用空对象作为中介 在ECMAScript5中定义了一个新方法Object.create()，用于创建一个新方法 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《JavaScript中的对象克隆》 对this指针的理解 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this指的是：调用函数的那个对象。 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 作为对象方法的调用，这时this就指这个上级对象。 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 简述同步和异步JavaScript是单线程，一个时间段内，JavaScript只能干一件事情。任务队列分为同步任务和异步任务。 同步是阻塞模式：同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步是非阻塞模式：异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 JS常用的绑定事件的方法有哪些 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，查看事件列表。 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。 绑定事件监听函数，标准浏览器使用 addEventListener() ，IE11以下版本attachEvent() 来绑定事件监听函数，通称为DOM2事件系统。 Event对象的常见应用 event.preventDefault()：阻止事件的默认行为 event.stopPropagation()：阻止事件的进一步传播，也就是阻止冒泡 event.stopImmediatePropagation()：阻止剩余的事件处理函数的执行，并防止当前事件在DOM树上冒泡。 event.currentTarget：返回绑定事件的元素 event.target：返回触发事件的元素 解释下javascript的冒泡和捕获12345&lt;div id="click1"&gt; &lt;div id="click2"&gt; &lt;div id="click3"&gt;事件&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型。 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型。 W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段。 事件监听函数addEventListener()的第三个参数就是控制方法是捕获还是冒泡 js延迟加载的方式有哪些 将script节点放置在最后&lt;/body&gt;之前 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 通过监听onload事件，动态添加script节点创建DOM元素（用得最多） 通过ajax下载js脚本，动态添加script节点 window.onload和DOMContentLoaded的区别123456window.addEventListener('load',function()&#123; //页面的全部资源加载完才会执行，包括图片、视频等&#125;)document.addEventListener('DOMContentLoaded',function()&#123; //DOM渲染完即可执行，此时图片、视频还可能没有加载完&#125;) 如何解决跨域问题 JSONP（JSON with Padding），填充式JSON iframe跨域 HTML5的window.postMessage方法跨域 通过设置img的src属性，进行跨域请求 跨域资源共享（CORS），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 哪些操作会造成内存泄漏 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。 闭包可以维持函数内局部变量，使其得不到释放。 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。 JavaScript中的变量声明提升 函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。 function优先声明于var。 函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。 123456789101112131415function foo() &#123; bar(); var x = 1;&#125;function foo() &#123;//等同于 var x; bar(); x = 1;&#125;function test() &#123; foo(); // TypeError "foo is not a function" bar(); // "this will run!" var foo = function () &#123; &#125;// 函数表达式被赋值给变量'foo' function bar() &#123; &#125;// 名为'bar'的函数声明&#125; JavaScript原型和原型链 原型： 原型是一个对象，其他对象可以通过它实现属性继承。 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器proto。 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。 原型链： 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系称为原型链。 这条链的末端一般总是默认的对象原型。 JavaScript中的作用域和作用域链 变量的作用域（scope）：程序源代码中定义这个变量的区域。 作用域链：是一个对象列表或链表，这组对象定义了这段代码“作用域中”的变量。查找变量会从第一个对象开始查找，有则用，无则查找链上的下一个对象。 jQuery源码以及jQuery的实现原理 jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件), 一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想 jQuery的特点 一款轻量级的js库 丰富快速的DOM选择器 链式表达式 事件、样式、动画等特效支持 Ajax操作封装，支持跨域 跨浏览器兼容 插件扩展开发 浏览器的内核分别是什么 IE: trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同，解决方案是加一个全局的*{margin:0;padding:0;}来统一 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 WEB应用从服务器主动推送Data到客户端有那些方式 Html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe &lt;script&gt;标签的长时间连接(可跨域) 如何实现浏览器内多个标签页之间的通信 WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； webSocket如何兼容低浏览器？ Adobe Flash Socket ； ActiveX HTMLFile (IE) ； 基于 multipart 编码发送 XHR； 基于长轮询的 XHR。 输入完网址按下回车到看到网页这个过程中发生了什么 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 关于前端性能优化 请求优化：合并JS和CSS，减少DNS查找次数，避免重定向，使用GET完成AJAX请求，减小请求中的Cookie，缓存资源，使用CDN，开启GZip，压缩HTML页面，开启长连接，避免行内脚本阻塞并行下载，少用iframe（阻塞onload事件，影响并行下载）。 CSS优化：样式表置于页面顶部，避免使用CSS表达式，使用外部JS和CSS，压缩JS和CSS，避免滤镜。 JavaScript优化：脚本置于页面底部，减少DOM访问，减少重绘和重排，尽量使用局部变量，使用定时器分割大型任务，用合适的正则操作字符串，惰性模式减少分支，事件委托，第三方代码异步加载，节流与去抖动，使用localStorage替代cookie。 图片优化：内联图使用Data:URL，压缩图片或使用WebP格式，固定图片尺寸，图片预加载，图片延迟加载，使用字体矢量图标，Sprites图片。 减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 浏览器本地存储 sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别 Cookie的大小是受限的； 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽； cookie还需要指定作用域，不可以跨域调用； Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie； Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生； IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage； 请求服务器时的状态码。 >1xx：请求收到，继续处理 2xx：操作成功收到，分析、接受 3xx：完成此请求必须进一步处理 4xx：请求包含一个错误语法或不能完成 5xx：服务器执行一个完全有效请求失败 常见的有： 200 OK 客户端请求成功表示成功访问,为网站可正常访问时的状态。 301 Moved Permanently 永久重定向对搜索引擎相对友好的跳转方式，当网站更换域名时可将原域名作301永久重定向到新域名，原域名权重可传递到新域名，也常有将不含www的域名301跳转到含www的，如xxx.com通过301跳转到www.xxx.com 302 Moved Temporarily 临时重定向易被搜索引擎判为作弊,比如asp程序的response.Redirect()跳转、js跳转或静态http跳转。 400 Bad Request 请求错误由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 未授权请求未经授权，无法访问。 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。你的IP被列入黑名单，连接的用户过多，可以过后再试，网站域名解析到了空间，但空间未绑定此域名等情况。 404 Not Found 文件或目录不存在表示请求文件、目录不存在或删除，设置404错误页时需确保返回值为404。常有因为404错误页设置不当导致不存在的网页返回的不是404而导致搜索引擎降权。 500 Internal Server Error 程序或服务器错误表示服务器内部程序错误，出现这样的提示一般是程序页面中出现错误，如小的语法错误，数据连接故障等。 503 Service Unavailable 服务器当前不能够处理客户端的请求在一段时间之后，服务器可能会恢复正常。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>javascript</tag>
        <tag>http</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>jquery</tag>
        <tag>面试</tag>
        <tag>盒模型</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则表达学习]]></title>
    <url>%2F2017%2F05%2F24%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是正则表达式 正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，搜索模式可用于文本搜索和文本替换。 正则表达式的语法 /主体/修饰符(可选) 其中，第一个“/“是这个正则表达式的头部,主体是我们想要匹配的模式,第二个“/“是这个正则表达式的尾部，修饰符有三个： i（intensity）：大小写不敏感； g（global）：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行； m（multiple）：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用。 正则表达式的常用方法 test( ) : 在字符串中查找符合正则的内容，若查找到返回true,反之返回false。用法：正则.test(字符串) 123456789// 测试是否是数字：var str = '374829348791';var re = /\D/; // \D代表非数字if( re.test(str) )&#123; // 返回true,代表在字符串中找到了非数字。 console.log('不全是数字');&#125;else&#123; console.log('全是数字');&#125; search( ) ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回-1。用法：字符串.search(正则) 123456// 在字符串中找字母b，且不区分大小写：var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i'); 也可以这样写console.log( str.search(re) ); // 1 match( ) : 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。用法： 字符串.match(正则)量词：+ 至少出现一次 匹配不确定的次数（匹配就是搜索查找的意思）。 12345//找出指定格式的所有数字，如下找到 123，54，33，879var str = 'haj123sdk54hask33dkhalsd879';var re = /\d+/g; // 每次匹配至少一个数字 且全局匹配 如果不是全局匹配，当找到数字123，它就会停止了。就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，8，7，9并不是我们想要的，有了加号，每次匹配的数字就是至少一个了。console.log( str.match(re) ); // [123，54，33，879] match方法也会返回自己的子项，如下： 12345// 当match不加g的时候才可以获取到子项的集合:var str = 'abc';var re = /(a)(b)(c)/;console.log( str.match(re) ); //[abc,a,b,c](返回的是匹配结果,以及每个子项) replace() :查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。用法： 字符串.replace(正则,新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符） 12345678910111213141516171819202122//敏感词过滤，比如 我爱北京天安门，天安门上太阳升。------我爱*****，****上太阳升。即北京和天安门变成*号。~~//一开始我们可能会想到这样的方法：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,'*'); console.log(str2) //我爱**，*上太阳升 //这种只是把找到的变成了一个*，并不能几个字就对应几个*。~~//要想实现几个字对应几个*，我们可以用回调函数实现：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,function(str)&#123; console.log(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门 var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; //所以搜索到了几个字就返回几个* &#125;);console.log(str2) //我爱*****，***上太阳升 //整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。 正则表达式中的字符 ^ : 正则的最开始位置，就代表起始的意思。注意：/[ ^ a] / 和 / ^ [a]/ 是不一样的，前者是排除的意思，后者是代表首位。 eg:”^ The”–表示所有以”The”开始的字符串（”There”，”The cat”等）; 1234567// 判断是不是QQ号:// 首先想QQ号的规则：1.首位不能是0 ；2.必须是 5-12位的数字。 var str = '1445427773';var re = /^[1-9]\d&#123;4,11&#125;$/;console.log( re.match(str) ); $ : 正则的最后位置，就代表结束的意思。eg:”of despair$”–表示所以以”of despair”结尾的字符串; 12345678910// 去掉前后空格（面试题经常出现）:function trim(str)&#123; var re = /^\s+|\s+$/g; // |代表或者 \s代表空格 +至少一个 前面有至少一个空格 或者后面有至少一个空格 且全局匹配 return str.replace(re,''); //把空格替换成空&#125;var str = ' hello ';console.log('('+str+')');console.log( '('+trim(str)+')' ); //为了看出区别所以加的括号。 ( ) : 小括号，叫做分组符。就相当于数学里面的括号。如下： 12345678var str = '2013-6-7';var re1 = /\d-+/g; // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为： 3- 6-var re2 = /(\d-)+/g; // 全局匹配数字，横杠，数字和横杠整体数量至少为1 3-6-var re3 = /(\d+)(-)/g; // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-console.log(str.match(re1));console.log(str.match(re2));console.log(str.match(re3)); 同时，正则中的每一个带小括号的项，都叫做这个正则的子项。子项在某些时候非常的有用，比如下面这个例子： 123456789101112131415// 让2013-6-7 变成 2013.6.7：var str = '2013-6-7';var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; // replace()中如果有子项， // 第一个参数：$0（匹配成功后的整体结果 2013- 6-）, // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d 2013, 6) // 第三个参数 : $1(匹配成功的第二个分组，这里指的是- - - ) return $1 + '.'; // 分别返回2013. 6. &#125;);console.log( str ); // 整个过程就是利用子项把2013- 6- 分别替换成了2013. 6. 最终弹出2013.6.7 转义字符: \s : 匹配一个空白字符，包括空格、制表符、换页符和换行符。 \S : 匹配一个非空白字符。 \d : 匹配一个数字。等价于[0-9]。 \D : 匹配一个非数字字符。等价于[^0-9]。 \w : 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。 \W : 匹配一个非单字字符。等价于 [^A-Za-z0-9_]。 .（点）: 匹配除换行符之外的任何单个字符。 \. : 匹配真正的点 \b : 独立的部分 （ 起始，结束，空格 ） \B : 非独立的部分 1234567var str1 = 'onetwo';var str2 ="one two";var re = /one\b/; // e后面必须是独立的 可以是起始，空格，或结束console.log( re.test(str1) ); // falseconsole.log( re.test(str2) ); // true 量词：代表出现的次数。 {n,m} : 至少出现n次，最多m次;“ab{3,5}”：表示一个字符串有一个a跟着3到5个b;“ab{2,}”：表示一个字符串有一个a跟着至少2个b; {n,} : 至少n次; * : 任意次,相当于{0,};“ab*”：表示一个字符串有一个a后面跟着零个或若干个b。（”a”, “ab”, “abbb”,……）； ？：零次或一次,相当于{0,1};“ab?”：表示一个字符串有一个a后面跟着零个或者一个b; + ：一次或任意次,相当于 {1,};“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多; {n} ：正好n次;“ab{2}”：表示一个字符串有一个a跟着2个b（”abb”). [ ]： 表示某个集合中的任意一个。方括号表示某些字符允许在一个字符串中的某一特定位置出现。“[ab]”：表示一个字符串有一个”a”或”b”（相当于”a¦b”);“[a-d]”：表示一个字符串包含小写的’a’到’d’中的一个（相当于”a¦b¦c¦d”或者”[abcd]”);“ ^ [a-zA-Z]”：表示一个以字母开头的字符串;“[0-9]%”：表示一个百分号前有一位的数字;“, [a-zA-Z0-9] $ “ ：表示一个字符串以一个逗号后面跟着一个字母或数字结束。你也可以在方括号里用’ ^ ‘表示不希望出现的字符，’ ^ ‘应在方括号里的第一位。（如：”%[ ^ a-zA-Z]%”表示两个百分号中不应该出现字母)。为了逐字表达，你必须在” ^ .$ ( ) ¦ * + ? { \ “这些字符前加上转移字符’ \ ‘。请注意在方括号中，不需要转义字符。 12345// 匹配HTML标签 比如&lt;div class="b"&gt;hahahah &lt;/div&gt; 找出标签&lt;div class="b"&gt;&lt;/div&gt;var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号 中间至少一个非右括号的内容(因为标签里面还有属性等一些东西)，然后匹配右括号var re = /&lt;[\w\W]+&gt;/g; //匹配左括号 中间至少一个字符或者非字符的内容，然后匹配右括号// 其实就是找到左括号，然后中间可以有至少一个内容，一直到找到右括号就代表是一个标签。 \a ：表示重复的某个子项。比如： \1 : 重复的第一个子项; \2 : 重复的第二个子项; 12/ (a) (b) (c) \1/ // 匹配 abca/ (a) (b) (c) \2/ // 匹配 abcb 12345678910111213141516171819202122// 找重复项最多的字符个数(面试题中经常问到）:var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split(''); // 把字符串转换为数组str = arr.sort().join(''); // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串console.log(str); // aaddjjkklsssssssssssssssssvar value = '';var index = 0; var re = /(\w)\1+/g; // 匹配字符，且重复这个字符，重复次数至少一次。str.replace(re,function($0,$1)&#123; // alert($0); 代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss // alert($1); 代表每次匹配成功的第一个子项，也就是\w: a d j k l S if(index&lt;$0.length)&#123; // 如果index保存的值小于$0的长度就进行下面的操作 index = $0.length; // 这样index一直保存的就在最大的长度 value = $1; // value保存的是出现最多的这个字符 &#125;&#125;); console.log('最多的字符:'+value+',重复的次数:'+index); // s 17 split( ):字符串中的方法，把字符串转成数组。sort( ):数组中的排序方法，按照ACALL码进行排序。join( ):数组中的方法，把数组转换为字符串 常用的一些正则表达式 1. 校验是否全由数字组成（[0-9]中的字符出现次数的范围是1到20次): > /\^[0-9]{1,20}$ / 校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串: /^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$ / 校验用户姓名：只能输入1-30个以字母开头的字串: /^[a-zA-Z]{1,30}$/ 校验密码：只能输入6-20个字母、数字、下划线: /^(\w){6,20}$/ 校验普通电话、传真号码：可以“+”或数字开头，可含有”-“ 和 “ “ /^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/ 校验URL: /^http[s]{0,1}://.+$/ 校验身份证： /[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x/ 校验Email(起始至少为一个字符(\w字母，数字或者下划线)，然后匹配@,接着为任意个字母或者数字，\.代表真正的点，.后面为至少一个的字符（a-z）,同时这个(比如.com)整体为一个子项作为结束，可以出现1-3次。因为有的邮箱是这样的.cn.net。)： /^\w+@[a-z0-9]+(.[a-z]+){1,3}$ / JavaScript正则表达式大全（过滤Emoji的最佳实践）一、校验数字的表达式 1 数字：^[0-9]$ 2 n位的数字：^\d{n}$ 3 至少n位的数字：^\d{n,}$ 4 m-n位的数字：^\d{m,n}$ 5 零和非零开头的数字：^(0|[1-9][0-9])$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9])+(.[0-9]{1,2})?$ 7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$ 8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$11 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$13 非负整数：^\d+$ 或 ^[1-9]\d|0$14 非正整数：^-[1-9]\d|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$17 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9]*.[0-9]+)|([0-9][1-9][0-9]))$18 负浮点数：^-([1-9]\d*.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9]*.[0-9]+)|([0-9][1-9][0-9])))$19 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d|0.\d[1-9]\d|0?.0+|0)$ 二、校验字符的表达式 1 汉字：^[\u4e00-\u9fa5]{0,}$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3 长度为3-20的所有字符：^.{3,20}$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$11 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+12 禁止输入含有的字符：[^\x22]+ 三、特殊需求表达式 1 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+)*.\w+([-.]\w+)$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 7 身份证号：15或18位身份证：^\d{15}|\d{18}$15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$ 8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.[a-z])(?=.[A-Z]).{8,10}$12 日期格式：^\d{4}-\d{1,2}-\d{1,2}13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9])$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9])$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})(.[0-9]{1,2})?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?&lt;/\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用) 详见此文章]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>regex</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个测试颜色辨识度的小游戏]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A2%9C%E8%89%B2%E8%BE%A8%E8%AF%86%E5%BA%A6%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[testColorResolution > A small game that can test your eyes for color recognition 简介之前有段时间网上有一个挺流行的小游戏叫做“看你有多色”。然后我看了网上的教程用createJS仿写了一个，具体实现后效果如下： 游戏开始 点击与其它方块颜色不一样的方块 一定步数之后，方块数量达到9*9后不再增加 以下是部分关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243var stage = new createjs.Stage("gameView");createjs.Ticker.setFPS(30);createjs.Ticker.addEventListener("tick",stage);var gameView = new createjs.Container();stage.addChild(gameView);var n = 2;function addRect()&#123; var cl = parseInt(Math.random()*1000000); var color = "#" + cl; var cl1 = cl+90000; var RectColor = "#" + cl1; var x = parseInt(Math.random()*n); var y = parseInt(Math.random()*n); for(var indexX = 0;indexX &lt; n ;indexX++)&#123; for(var indexY = 0;indexY &lt; n;indexY++)&#123; var r = new Rect(n,color,RectColor); gameView.addChild(r); r.x = indexX; r.y = indexY; if(r.x == x &amp;&amp; r.y == y)&#123; r.setRectType(2); &#125; r.x = indexX*(400/n); r.y = indexY*(400/n); if(r.getRectType() == 2)&#123; r.addEventListener("click",function()&#123; var audio = document.getElementById("clickSound"); audio.play(); if(n&lt;9)&#123; ++n; &#125; gameView.removeAllChildren(); addRect(); &#125;) &#125; &#125; &#125;&#125;addRect(); 表示颜色的时候用的十六进制而不是RGB，然后随机颜色用的是random函数。而唯一一个不同于其他方块的方块颜色是要比其他颜色浅一些的。点击其他方块没有任何特效，点击唯一正确的方块会进入下一关并且伴随有音效提示，同时整个游戏会有BGM。 源码地址：https://github.com/1996szw/testColorRecognition]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的回流与重绘]]></title>
    <url>%2F2017%2F04%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[Info: 一句话概括就是，回流必将引起重绘，重绘不一定会引起回流。 写在前面在讨论回流与重绘之前，我们需要知道： 浏览器使用流式布局模型 (Flow Based Layout)。 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 回流 (Reflow)当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘 (Repaint)当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 性能代价回流比重绘的代价要更高。 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。 现代浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft width、height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免CSS 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 Javascript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>回流</tag>
        <tag>重绘</tag>
        <tag>render tree</tag>
        <tag>reflow</tag>
        <tag>repaint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手和四次挥手]]></title>
    <url>%2F2017%2F04%2F02%2FTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[1.TCP报文格式 几个重点字段： （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 需要注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。 2.三次握手 TCP(Transmission Control Protocol)即传输控制协议，TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 位码即tcp标志位,有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码)Acknowledge number(确认号码)establish 建立，创建 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。SYN攻击： 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： netstat -nap | grep SYN_RECV 3.四次挥手所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：流程和状态在上图中，可以参考前面的四次挥手解析步骤。 4.问答1.为什么建立连接是三次握手，而关闭连接却是四次挥手呢？答：这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>tcp</tag>
        <tag>ip</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现垂直水平居中]]></title>
    <url>%2F2017%2F03%2F18%2FCSS%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[CSS实现垂直水平居中 第一种方法（position:absolute，负margin法） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的左外边距、上外边距为宽高的负1/2--&gt;margin-left:-100px;margin-top:-200px;&#125; 优点：兼容性好；缺点：必须固定元素的宽高 第二种方法（使用css3的新属性transform:translate(x,y)） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的相对于自身的偏移度为负50%(也就是元素自身尺寸的一半)--&gt;transform:translate(-50%,-50%);&#125; 这是css3里的样式，在移动端用得较多；缺点：兼容性不好，只支持IE9+的浏览器。 第三种方法（设置margin为auto） 1234567891011121314151617div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、下、左、右都为0--&gt;left:0;right:0;top:0;bottom:0;&lt;!--设置元素的margin样式值为 auto--&gt;margin:auto;&#125; 优点：兼容性较好；缺点：不支持IE7以下的浏览器。 第四种方法（inline-block方法） 场景： 一个块状元素A内 有若干个块状元素B，要达到的效果是 ，所有块状元素B 在 元素A 内水平居中显示。 12345&lt;div class="A"&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt;&lt;/div&gt; 首先，我们要设置元素A的大小为500px，设置背景色为green方便查看。 1234.A｛ width:500px; backgrond-color:green;｝ 然后， 设置所有元素B 的宽度为100px，高度为100px，外边据都为5px，背景色为#000方便查看。 123456.B｛ width:100px; height:100px; magin:5px; backgrond-color:green;｝ 此时的效果： 我们要做的是，先把所有的元素B都设置为行内块级元素，让他们都排成一行，即使用：display:inline-block； 最后就是让所有的元素B居中了， 到这里，相信很多人就猜到下一步要做什么了，我锦上添花，解释一下。 先想一想，如果是行内元素， 我们一般让它怎么居中呢？答：当然是给它的父容器加一个text-align:center的样式。 这里我们已经把所有的元素B变成了行内块， 也就有了行内元素的特性，所以，我们下一步要做的就是给元素A加text-align:center， 这样我们的目的就达到了，请看效果： 优点：兼容性较好；缺点：父元素和子元素的宽度都要已知。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>html</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局语法教程]]></title>
    <url>%2F2017%2F03%2F14%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Info: Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。 网页布局（layout）是CSS的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局: 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局: 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀: 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end`。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）: 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行: 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 nowrap（默认）：不换行: wrap：换行，第一行在上方: wrap-reverse：换行，第一行在下方: flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap: 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式: 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右: 12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用: 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值: 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 123456orderflex-growflex-shrinkflex-basisflexalign-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0: 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大: 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小: 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小: 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选: 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS经典布局问题整理]]></title>
    <url>%2F2017%2F03%2F14%2FCSS%20%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Info: CSS布局相关。 CSS基础知识 MDN-CSS入门教程： MDN的官方文档 学习CSS布局： 排版不错，简短精悍 CSS定位问题主要就是经典的绝对定位、相对定位问题 10个文档学布局： 通过十个例子讲解布局，主要涉及相对布局，绝对布局，浮动。 百度前端学院笔记 - 理解绝对定位： 文章本身一般，几篇参考文献比较详细 HTML和CSS高级指南之二——定位详解： 介绍浮动的使用，详细介绍定位的技巧，包括如何准确的给元素在 X 轴、Y 轴和 Z 轴定位 三栏式布局涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局圣杯：父盒子包含三个子盒子（左，中，右） 中间盒子的宽度设置为 width: 100%; 独占一行 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行 .left {margin-left:-100%;} 把左边的盒子拉上去 .right {margin-left：-右边盒子宽度px;} 把右边的盒子拉上去 父盒子设置左右的 padding 来为左右盒子留位置 对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖 1234567&lt;!-- 圣杯的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class="middle"&gt;中间弹性区&lt;/div&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 双飞翼布局双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。 中间盒子的宽度设置为 width: 100%; 独占一行 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行 在中间盒子里面再添加一个 div，然后对这个 div 设置 margin-left 和 margin-right来为左右盒子留位置 123456789&lt;!-- 双飞翼的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class="middle"&gt; &lt;div class="middle-inner"&gt;中间弹性区&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 圣杯和双飞翼异同圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 两种方法基本思路都相同：三栏全部 float 浮动。首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。 主要区别在于 如何使中间盒子的内容不被左右盒子遮挡： 圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位 双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子 简单说起来就是双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性。 利用浮动实现我自己使用浮动也实现了三栏式布局：左边盒子左浮动，右边盒子右浮动，中间盒子利用 margin-left 和 margin-right 来为左右盒子留位置，同时父盒子设置 overflow: auto; 来避免子盒子溢出。 1234567&lt;!-- 浮动实现的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt; &lt;!-- 中间的 div 必须写在最后面 --&gt; &lt;div class="middle"&gt;中间弹性区&lt;/div&gt;&lt;/div&gt; 三栏式布局参考下面几个链接: CSS三栏布局——中间固定两边自适应宽度： w3cplus 的文章，使用了双飞翼和浮动实现两侧定宽、中间自适应，也实现了两侧自适应、中间定宽 简书 - 圣杯布局和双飞翼布局(前端面试必看)：只讲了圣杯，不过特别详细 In Search of the Holy Grail：圣杯布局的来源 百度前端学院笔记 - 三栏式布局之双飞翼与圣杯：百度前端学院学员的前端学习笔记 三栏式布局涉及到负 magin 和 清除浮动的问题。 负magin 负margin用法权威指南：The Definitive Guide to Using Negative Margins 的译文,介绍了负 magin 的一些性质和很多实用技巧 简书 - margin为负值产生的影响和常见布局应用：包括对自身的影响，对文档流的影响，以及一些在布局中的应用技巧(比如去除列表右边框，负边距+定位实现水平垂直居中，去除列表最后一个 li 元素的 border-bottom，多列等高) 博客园 - CSS布局奇淫巧计之-强大的负边距：和上文内容差不多 简单总结几点： 不使用 float 的话，负 margin 元素是不会破坏页面的文档流。所以如果你使用负 margin 上移一个元素，所有跟随的元素都会被上移(而 relative 定位的元素则不同，会保留原位置，影响文档流) 当 static 元素的 margin-top/margin-left 被赋予负值时，元素将被拉进指定的方向 如果你设置 margin-bottom/right 为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素 当元素不存在 width 属性或者 width: auto 的时候，负 margin 会增加元素的宽度 margin-top 为负值不会增加高度，只会产生向上位移;margin-bottom 为负值不会产生位移，会减少自身的供 CSS 读取的高度，影响下方的元素位置；上下相邻的元素两者均为负时，效果不叠加，取负值更多的那个效果 清除浮动清除浮动主要是为了解决高度塌陷问题。而简单的 clear: both 并不能解决这个问题，所以引出了许多解决方案。 StackOverflow - What methods of ‘clearfix’ can I use?：清除浮动黑科技完整解读 那些年我们一起清除过的浮动：神文，把“清除浮动”定义为“闭合浮动”，把问题由来和解决方案都讲清楚了，并且分析了各种解决方案的优劣。 各种解决方案在上面的链接里有很详细的说明了，这里就不赘述了。大体分为两类： 其一，通过在浮动元素的末尾添加一个空元素，设置 clear: both 属性，after 伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素 其二，通过设置父元素 overflow 或者 display: table 属性来闭合浮动 顺便补充一句，clear float(例如 clear: left) 是对某个元素设置，以避免其某一边有浮动元素，即对当前元素产生约束，约束的边界为其他的浮动元素。对于已经浮动的元素，设置 clear float 是无效的。 居中布局Centering in CSS: A Complete Guide：非常全面的居中定位博客，包括各种情况下的水平居中，垂直居中和水平垂直居中方案。有展示示例及相应的 HTML 和 CSS 代码文章大致结构： 1 水平居中 对于行内元素(inline)：text-align: center 对于块级元素(block)：设置宽度且 marigin-left 和 margin-right 是设成 auto 对于多个块级元素：对父元素设置 text-align: center;，对子元素设置 display: inline-block;；或者使用 flex 布局 2 垂直居中 对于行内元素(inline) 单行：设置上下 pandding 相等；或者设置 line-height 和 height 相等 多行：设置上下 pandding 相等；或者设置 display: table-cell; 和 vertical-align: middle;；或者使用 flex 布局；或者使用伪元素 对于块级元素(block)：下面前两种方案，父元素需使用相对布局 已知高度：子元素使用绝对布局 top: 50%;，再用负的 margin-top 把子元素往上拉一半的高度 未知高度：子元素使用绝对布局 position: absolute; top: 50%; transform: translateY(-50%) 使用 Flexbox：选择方向，justify-content: center 3 水平垂直居中 定高定宽：先用绝对布局 top: 50%; left: 50%;，再用和宽高的一半相等的负 margin 把子元素回拉 高度和宽度未知：先用绝对布局 top: 50%; left: 50%;，再设置 transform: translate(-50%, -50%) 使用 Flexbox：justify-content: center; align-items: center 响应式设计响应式设计（Responsive Design) 是一种让网站针对不同的浏览器和设备呈现不同显示效果的策略。 媒体查询(Media Queries)是做此事所需的最强大的工具。 注： Responsive Web Design ＝ RWD，Adaptive Web Design ＝ AWD RWD： 采用 CSS 的 media query 技术 流体布局（fluid grids） 自适应的图片/视频等资源素材（为小、中、大屏幕做一些优化，目的是让任何尺寸的屏幕空间都能得到充分利用） AWD： CSS media query 技术（仅针对有限几种预设的屏幕尺寸设计） 用 JavaScript 来操作 HTML 内容 在服务器端操作 HTML 内容（比如为移动端减少内容，为桌面端提供更多内容） 可以参考 Bootstrap 的网格系统：http://getbootstrap.com/css/#grid-less The Bootstrap 3 grid system has four tiers of classes: xs (phones), sm (tablets), md (desktops), and lg (larger desktops). 自己实现网格系统： Creating Your Own CSS Grid System Flexbox布局点我参考本博客另一篇文章。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>position</tag>
        <tag>absolute</tag>
        <tag>relative</tag>
        <tag>flex</tag>
        <tag>float</tag>
        <tag>margin</tag>
        <tag>center</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的DOM对象学习]]></title>
    <url>%2F2017%2F03%2F12%2FJavascript%E4%B8%AD%E7%9A%84DOM%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DOM 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 先来看看下面代码:12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html"; charset="gb2312"&gt;&lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;…&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作（DOM常见的API）: 注意:前两个是document方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>dom</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识集]]></title>
    <url>%2F2017%2F03%2F12%2FCSS%E7%9F%A5%E8%AF%86%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Info: CSS基础、布局、效果和动画、CSS工程化等 CSS非布局样式字体、字重、颜色、大小、行高字体族 serif 衬线字体族(Times New Roman、MS Georgia、宋体等) sans-serif 非衬线字体族(Arial、Helvetica、幼圆、隶书、楷体等) monospace 等宽字体族(Courier、MS Courier New、Prestige等) cursive 手写体族(Caflisch Script、Adobe Poetica、迷你简黄草、华文行草、静蕾体等) fantasy 梦幻字体族(WingDings、WingDings 2、Symbol等) 多字体fallback 屏显效果好的字体放前面 适用范围小的字体放前面 自定义字体、网络字体在style标签中使用@font-face来指定一个自定义的字体，从而在下面应用这个字体。 字重 font-weight取值范围: 100～900 font-weight: lighter 取决于父级字体大小 font-weight: normal 默认相当于400 font-weight: bold 默认相当于700 font-weight: bolder 取决于父级字体大小 字体 demo12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--字体--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;fonts&lt;/title&gt; &lt;style&gt; body&#123; /* font-family: "monaco"; */ /* font-family: "monaco", "PingFang SC"; */ font-family: "aaaaa", "monaco", "PingFang SC"; &#125; .chinese&#123; font-family: "PingFang SC", "Microsoft Yahei", monospace; /* font-family: "Microsoft Yahei", serif; */ /* font-family: "serif"; */ &#125; .weight&#123; font-weight: bold; font-weight: bolder; font-weight: lighter; font-weight: normal; font-weight: 100; &#125; @font-face &#123; font-family: "IF"; src: url("./IndieFlower.ttf"); &#125; .custom-font&#123; font-family: IF; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="body" id="body"&gt; Hello world 你好，世界 &lt;div class="chinese"&gt;你好&lt;/div&gt; &lt;!-- &lt;div class="weight"&gt;你好 Hello World&lt;/div&gt; --&gt; &lt;div class="custom-font"&gt;你好 Hello World&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; line height 行高会撑开div的高度。inline元素会默认在div里垂直居中，所以可以通过line-height的方式来做这个垂直居中。 行内元素的对齐方式是默认底线对齐(baseline)。可以通过vertical-align这个属性来更改inline元素对齐的方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 使用vertical-align:bottom 来解决经典的图片3px缝隙问题--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;line-height&lt;/title&gt; &lt;style&gt; .cc1&#123; font-size:12px; &#125; .cc2&#123; font-size:18px; &#125; .cc3&#123; font-size:24px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="border:solid 1px red;"&gt; &lt;span style="background:blue;color:#fff;font-size:20px;line-height:60px;"&gt; 居中xfg&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; &lt;/span&gt;&lt;/div&gt; &lt;div class="c1"&gt; &lt;span class="cc1"&gt;第一段&lt;/span&gt; &lt;span class="cc2"&gt;第二段&lt;/span&gt; &lt;span class="cc3"&gt;第三段&lt;/span&gt; &lt;/div&gt; &lt;div style="background:red"&gt; &lt;span&gt;文字&lt;/span&gt; &lt;img src="test.png"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style="float:left"&gt; &lt;span&gt;第一段&lt;/span&gt; &lt;/div&gt; &lt;div style="float:left"&gt; &lt;span&gt;第二段&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景、边框背景颜色 常见的颜色可以用单词来表示，但很少用(balck、white等) 通常可以使用十六进制的颜色代码或者rgb颜色代码来精准地表示一个颜色(#ffffff、#000000等) 人眼对rgb不是非常敏感，所以可以采用hsl(色相(0°～360°)、饱和度(0～100%)、亮度(0～100%))来表示一个颜色(hsl(0,100%,50%)、hsl(240,50%,65%)) rgba和hsla可以给颜色加上一个透明度 渐变色背景12345678&lt;!--老版IE写法--&gt;background: -webkit-linear-gradient(left, red, green);&lt;!--通用写法--&gt;background: linear-gradient(to right, red, green);&lt;!--0°代表从下往上、90°就代表从左往右，依此推算--&gt;background: linear-gradient(90deg, red, green);&lt;!--渐变区域，可以实现彩虹效果--&gt;background: linear-gradient(135deg, red 0, green 10%, yellow 50%, blue 100%); 多背景叠加1234&lt;!--可以实现网格效果--&gt;background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%), linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%);background-size: 30px 30px; linear-gradient demo12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;background&lt;/title&gt; &lt;style&gt; body&#123; background:white; &#125; .c1&#123; height:90px; /* background:rgba(255,0,0, .3); */ /* background:url(./test.png); */ &#125; .c2&#123; height:90px; /* background: -webkit-linear-gradient(left, red, green); */ /* background: linear-gradient(to right, red, green); */ /* background: linear-gradient(180deg, red, green); */ /* background: linear-gradient(135deg, red 0, green 10%, yellow 50%, blue 100%); */ background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%), linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%); background-size: 30px 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt; &lt;/div&gt; &lt;div class="c2"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景图片和属性（雪碧图）把小图标合成一张大图，通过给元素的公共css设置background-image为该合成图，这样每个元素都会以该合成图为背景，而且页面也只加载一张合成图，然后再给每个元素单独微调其background-position，把多个请求合并成一个。这样就达到了优化网页性能的效果。 base64和性能优化 可以通过在线工具将图片转化成base64编码的形式来引用，从而优化网页性能。 但是此时的图片大小会是之前的三分之四，而且这样引用也会增大CSS的体积。 所以该方法只适用于小图标而且少量的情况，比如一个常用的地方就是loading时候的小图标 多分辨率优化通过修改background-size修改相应的比例来让背景图在移动端设备上也能显示得很清楚。 背景 demo1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;background&lt;/title&gt; &lt;style&gt; .c1&#123; height:900px; background:red url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHoAAAA2CAYAAAAIw43zAAAMJGlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU0kXx+eVJCQktEAEpITeBOlVeo1UqYKNkAQSSgiBoGJHFxVYCyoWrMiqiG0tgCwqYlcWwd4XRFCUdbFgQ+WbJICu+5XzzTnz5nfu3Lnzv/PmzXkDgHIUWyTKRFUAyBLmiaOD/ZiTE5OYpE5ABtpADRgAYzYnV+QbFRUGYBlp/17e3QKItL1uLY31z/7/WlS5vFwOAEgU5BRuLicL8lEAcGeOSJwHAKEP2o1m5okgE6FKoC6GAiEbSzlNzq5STpFzmMwnNtofcjIAClQ2W5wGgJJUFzOfkwbjKJVCthVyBULIjZC9OHw2F/JnyOOysrIhK5tDNk/5Lk7a32KmjMZks9NGWZ6LrCgECHJFmezZ/+dy/O+SlSkZmcMIVipfHBItzVm6bhnZoVKmQr4oTImIhKwG+YaAK/OXcg9fEhI37P+Bk+sP1wwwAECpXHZAKGQdyIaSjDjfYfZii2VjoT+aVMCPTZDHR4Xi7Ojh+GiBMDMibDhOKZ/HGuFKXm5gzIhPqiCIBRm+Q7RekMeKHY55MV8QHwFZCfKD3IyY0OGxzwv4/hGjc0mipZrhO8dAVu5ILphxqjgoWu6POfMFrIhhe1gePzZEPhabzmHLNGhCTuflTg4b0cPlBQTK9WCFPGHcsE6sTJTnFz3sXyXKjBr2xxp5mcFSuyHk1tz8mJGx/Xlws8lzwUE6e2KUfF5cXZQXFSvXhjNBGPAHAYAJJLCmgGyQDgStfXV9YKQnCLCBGKQBHrAetoyMSJD1COEzBhSAPyHxQO7oOD9ZLw/kQ/uXUav8aQ1SZb35shEZoAdyFq6Ne+EeeBh8+sBqj7vibiPjmMojsxIDiQHEEGIQ0WKGoFD8Q1wm4MAMMmEVg1DY8mBWUg3CEe3f4hB6CO2Ex4SbhA7CXRAPnkA/wT8y/BZNMGoLBx0watBwdinfZ4ebQtVOuB/uCfVD7TgD1wbWuCPMxBf3hrk5Qeu3Vft32iUjqsm2ZJQ8huxDNv/RT8lSyWl0jDS373XKdaWMZuI/2vPjbP7f5caFbeiPntgy7Ah2ATuNXcIasTrAxE5h9VgLdkLKo3vjiWxvjMwWLdOTAeMIRnxsa2x7bT//MDd7eH6x7P2DPN6sPOmH458tmi0WpPHzmL7wtOYxWUKOzTimva2dCwDSs19+tLxhyM50hHH5my2nCQC3YmhM+2ZjwzPoeA8A9HffbEav4SewCoATbRyJOF9uw6UPAqAAZfilaAE9eHaZw4zsgTPwAD4gEEwEkSAWJILpcJ35IAuqngnmgkWgCJSAVWAd2AS2gZ1gD9gPDoM60AhOg/PgCmgDN8F9uFe6wQvQD96BQQRBSAgNoSNaiD5iglgh9ogr4oUEImFINJKIJCNpiBCRIHORxUgJUoZsQnYg1civyHHkNHIJaUfuIp1IL/Ia+YRiKBVVR3VRU3Q86or6oqFoLDoNTUNz0AJ0CboC3YBWovvQWvQ0egW9iXagL9ABDGCKGAMzwKwxV8wfi8SSsFRMjM3HirFyrBI7gDXAN30d68D6sI84EafjTNwa7tcQPA7n4Dn4fLwU34TvwWvxs/h1vBPvx78SaAQdghXBncAiTCakEWYSigjlhF2EY4Rz8JvqJrwjEokMohnRBX6ricR04hxiKXEL8SCxidhO7CIOkEgkLZIVyZMUSWKT8khFpI2kfaRTpGukbtIHBUUFfQV7hSCFJAWhQqFCucJehZMK1xSeKgySVcgmZHdyJJlLnk1eSa4iN5CvkrvJgxRVihnFkxJLSacsomygHKCcozygvFFUVDRUdFOcpChQXKi4QfGQ4kXFTsWPVDWqJdWfOpUqoa6g7qY2Ue9S39BoNFOaDy2JlkdbQaumnaE9on1QoivZKLGUuEoLlCqUapWuKb1UJiubKPsqT1cuUC5XPqJ8VblPhaxiquKvwlaZr1KhclzltsqAKl3VTjVSNUu1VHWv6iXVZ2okNVO1QDWu2hK1nWpn1LroGN2I7k/n0BfTq+jn6N3qRHUzdZZ6unqJ+n71VvV+DTUNR414jVkaFRonNDoYGMOUwWJkMlYyDjNuMT6N0R3jO4Y3ZvmYA2OujXmvOVbTR5OnWax5UPOm5ictplagVobWaq06rYfauLal9iTtmdpbtc9p941VH+sxljO2eOzhsfd0UB1LnWidOTo7dVp0BnT1dIN1Rbobdc/o9ukx9Hz00vXW6p3U69Wn63vpC/TX6p/Sf87UYPoyM5kbmGeZ/QY6BiEGEoMdBq0Gg4ZmhnGGhYYHDR8aUYxcjVKN1ho1G/Ub6xuHG881rjG+Z0I2cTXhm6w3uWDy3tTMNMF0qWmd6TMzTTOWWYFZjdkDc5q5t3mOeaX5DQuihatFhsUWizZL1NLJkm9ZYXnVCrVythJYbbFqH0cY5zZOOK5y3G1rqrWvdb51jXWnDcMmzKbQps7m5Xjj8UnjV4+/MP6rrZNtpm2V7X07NbuJdoV2DXav7S3tOfYV9jccaA5BDgsc6h1eOVo58hy3Ot5xojuFOy11anb64uziLHY+4NzrYuyS7LLZ5barumuUa6nrRTeCm5/bArdGt4/uzu557ofd//Kw9sjw2OvxbILZBN6EqgldnoaebM8dnh1eTK9kr+1eHd4G3mzvSu/HPkY+XJ9dPk99LXzTfff5vvSz9RP7HfN77+/uP8+/KQALCA4oDmgNVAuMC9wU+CjIMCgtqCaoP9gpeE5wUwghJDRkdchtli6Lw6pm9U90mThv4tlQamhM6KbQx2GWYeKwhnA0fGL4mvAHESYRwoi6SBDJilwT+TDKLCon6rdJxElRkyom9UTbRc+NvhBDj5kRszfmXaxf7MrY+3HmcZK45njl+Knx1fHvEwISyhI6Jo+fPG/ylUTtREFifRIpKT5pV9LAlMAp66Z0T3WaWjT11jSzabOmXZquPT1z+okZyjPYM44kE5ITkvcmf2ZHsivZAymslM0p/Rx/znrOC64Pdy23l+fJK+M9TfVMLUt9luaZtiatl+/NL+f3CfwFmwSv0kPSt6W/z4jM2J0xlJmQeTBLISs567hQTZghPJutlz0ru11kJSoSdeS456zL6ReHinflIrnTcuvz1OFPdovEXPKTpDPfK78i/8PM+JlHZqnOEs5qmW05e/nspwVBBb/Mwedw5jTPNZi7aG7nPN95O+Yj81PmNy8wWrBkQffC4IV7FlEWZSz6vdC2sKzw7eKExQ1LdJcsXNL1U/BPNUVKReKi20s9lm5bhi8TLGtd7rB84/KvxdziyyW2JeUln0s5pZd/tvt5w89DK1JXtK50Xrl1FXGVcNWt1d6r95SplhWUda0JX1O7lrm2eO3bdTPWXSp3LN+2nrJesr5jQ9iG+o3GG1dt/LyJv+lmhV/Fwc06m5dvfr+Fu+XaVp+tB7bpbivZ9mm7YPudHcE7aitNK8t3Enfm7+ypiq+68IvrL9W7tHeV7PqyW7i7Y0/0nrPVLtXVe3X2rqxBayQ1vfum7mvbH7C//oD1gR0HGQdLDoFDkkPPf03+9dbh0MPNR1yPHDhqcnTzMfqx4lqkdnZtfx2/rqM+sb79+MTjzQ0eDcd+s/ltd6NBY8UJjRMrT1JOLjk5dKrg1ECTqKnvdNrpruYZzffPTD5z4+yks63nQs9dPB90/swF3wunLnpebLzkfun4ZdfLdVecr9S2OLUc+93p92Otzq21V12u1re5tTW0T2g/ec372unrAdfP32DduHIz4mb7rbhbd25Pvd1xh3vn2d3Mu6/u5d8bvL/wAeFB8UOVh+WPdB5V/mHxx8EO544TnQGdLY9jHt/v4nS9eJL75HP3kh5aT/lT/afVz+yfNfYG9bY9n/K8+4XoxWBf0Z+qf25+af7y6F8+f7X0T+7vfiV+NfS69I3Wm91vHd82D0QNPHqX9W7wffEHrQ97Prp+vPAp4dPTwZmfSZ83fLH40vA19OuDoayhIRFbzJb9CmCwoqmpALzeDQAtEf47tAFAmSK/m8kKIr9Pygj8J5bf32TFGYDdPgDELQQgDP6jbIXVBDIVttLf8VgfgDo4jNbhkpvqYC+PRYU3HMKHoaE3ugCQGgD4Ih4aGtwyNPSlCoq9C0BTjvxOKC3SO+h2dSldmcUGP5Z/ATRNb+Gbl8cXAAAACXBIWXMAABYlAAAWJQFJUiTwAAABnGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj4xMjI8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NTQ8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KKEFk0AAAABxpRE9UAAAAAgAAAAAAAAAbAAAAKAAAABsAAAAbAAAEjVcWetQAAARZSURBVHgB7FpdTFRHFP52gQW6ErYszbaLRDCAwQpYBcH6s/FBiCbUB9SYiGlo0oSX9am+oA8Ek4b40KRJ+9ySJk3RohiJxIhNlUQEotmaVmKJBim/QX4CEu4WZD2wcO/M3dm7mGjQvbPJZs/MmTlz5vvmnJk7dy3Z2TkByE/UI2CRREc9x8sTlESbg2dIoiXRJkHAJNOUES2JNgkCJpmmjGizEd3ZeW9dp1xcXLKu40f74GpES6LfbapP79uFk1uTyclF+lqhPLkPT9vEmp2WRK8ZqvVteLbUgy8ybaoTyn8+eK6PqeVIgiQ6EkLviP5s6T4iOkH15o0RHbs5RTX6NoSFp3zakXu0McqSaGN8okYriY4aKo0nIok2xidqtJLoqKEyOJFs+ukVzMn0ROckO1CduwGBecASF4PpoWHU9v+/DJXFlohvizNRtMmFJHvsCnyL8Ct+PB8bRdeDp6gfeSmANbSqYnMajuW74f7IgXgrqyd7MxP4y9cL76MXrGLNsndbFg5tT4dT9ZG6zi/5OIz27qCPpie6LDcPdfs/VkENDPlQcm0M35Tk4ViBVq820AnTPZ04eGdaV6sVrcmpaCovgNvOsas1YKTA7AiaWx6ifsrC1IYXLTYHfju+ExkRbE/3+NBhzULZlg2qMdM9XpXlfIq6A24NALox+nkiA9VFTrXOSDAC7GhuLs7s32jUXaDzo6u1Hd5+439oWe2puFn5GTTqBKYMqoz8FnULe2HyvjxH64n2T9HzuSMF8frZzi/AT1eH8XF8ZIYD7Oi2PJzZI8oIlKppjMFJPxI+sMPpolSuH4tGam28jdqwkW1H89ef4xPelWUryvgonk0tIMmZArcjMWg5eOvJjRLOb64RU4g6opfnxgAz9u8/uNQ9iIYXK+k0xooKVwqO7MrCFlcSVlM9gwmsdhf+rMwPIVAZ7sX3N/pw2c+2jsd3pTuwJ5OPzcBUL0419gkPVtW7C1GV/yFrhK6wJ9F6uRu141ra3+lOw4XyrcGoX6RJWbWVIYlW4ZvBrasdqBnRgFNVK0IpHbDKE8bpEKVwqrrDHpSla/fKS8qBh3dR0THLtWMLp4m8kxx5i+hqaYN3UD9+Ihq/2ouMOLb3JK40dKNe0bclbpNp0Z0QLLo3ddf9vqbuIHx+3Lp4GzWTocCx8Ipkiy0VbVX83qmM/g1P87CoOVMXi18qDyDHrlWJ+hWmZ+HHw5laI5IGOu+gwselCU5fVVKI6gI+A8iIJoiUPnqFd4O/S+eQMygcob25htub59Da0I5aQbTpzRTRwfAH5mCI+QGc+6kHN5lzmf4tFDBH0dwujOZV+6KtRBKNBXQ1/QHv89eP5iVgQ4mgFNz2AEOx2v64SsDSb0JMzErxJRSbE4eKNzF7eyiJ+ufhwPhjnPq9X7iXa+MIsoXpUzdF0XmKohYmijTAIkkE6JeUfrW3gZE6RNBTNviVssHM6qITELbG7KNfIK8b0a8AAAD//7ooWjUAAAPeSURBVO2YS0hUURjH/6PWKDq+wxoyR/FVZpJK6pCaGgaBEmgItTCFQFq00pUFkZtahJtoYYRkD5IoJnoRmiFSJGiYlBWpSflkJCZ1cszHdCad+xjvnTkz6uLamc09j+/77nf/vzlPVVxcvBXk19n51vbgfj4xoVx5IwoLgz9FYTMyMkV12sqR+CRczNPy5vPDONf4CS3/vopvpiv5oLk8DzpfOmvXVrN4frcDF6ZVK6ar41uGepD7wugyVG1hNoqj+cQsP4jfM9d+9sCqzQbaavmO801fPAZ9i4CO5/W06+ThczVox/jWiQ/INIy5jM9AO4xo2hEirawPHEFYRsnIeUw/cqTj2lsl4lOOTAbaETSlcHbpxU+pqbWbTK3iZUbs405NjebKHOi28D60UzADva6ggWtlBUgL9uJIWM3fcOZOP955tOZzYbjCpaJc5Gm3cnVa0HXEr9ADP/uLNt0aTSucXQDH59lDWTiZECBoNuLG9R40LAma1lCsLcwlmyoeNMjmsY5sHp84/SP5w3Bajx38/w/uficD7QAtITIeTUejRK0DHS9xom99SFdlpaNiX4gg/hI6HrSietK+Mxd0rRQTtLFoKooWdTDQa1qjbVr6kXX0oGgdxfwoLjd+xEOno07EAWlBPpj6tYCv4maotoajvWI/1IJ2V9Dqj+VDH+Et8AAb0a5EE6klUylNSUVNZpio12oZx/1Hvbhikh95NoeSyAgcz0hAdJg3OUO3Cc7QfLj60sPQh4njDHe9QUm3mTdaKdVkp6N0j3AGWO5w9ztlp+5Vb9zghvW6MHFXAOnPUpNjVo7keXpyqB9t70fwyvgH0/CCLkCNxPBAJOoikBwVATW3o54joNslQUtNxbY8pob6cPv1MG7OqMiMoEFlTgrStX6SKbr7nQy0pIwgU2wonpanIUywAZIxlWmWB21zqC0gN12xlDcztu2BQx4M9JrXaJ6byluDe2UHoNM4qMybOCk5B21zrCdHJr3gyCQfbBaTJi+EB/Mr+38Ieje5697JabS2mzEujKhQtTcWpWlR0Pi6Bj5nNmFkkEztfWNoMLnevVVnJqE4RSvanAlfbjWPw2DohSk5g+zWg7guywC5yGmlv8jhpm4uAivIKpDq74f8XRroQjQIVC9Dty4uYNpsxohxBl0Tv9EyJ+vupMMLp2K2IX17ABd3ataMz0MTuDq+6MSPvouBptdK0ZYMtKLx0SfPQNNrpWhLBlrR+OiTZ6DptVK0JQOtaHz0yTPQ9Fop2pKBVjQ++uQZaHqtFG3JQCsaH33yDDS9Voq2ZKAVjY8+eQaaXitFW/4FdhzkzmcYrBcAAAAASUVORK5CYII=); background-repeat: no-repeat; /* background-position: center top; */ /* background-position: 20px 30px; */ /* background-size:100px 50px; */ &#125; .c2&#123; width:20px; height:20px; background:url(./test_bg.png) no-repeat; background-position: -17px -5px; background-size: 261px 113px; &#125; .c3&#123; width:20px; height:20px; background:url(./test_bg.png) no-repeat; background-position: -169px -23px; background-size: 261px 113px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt; &lt;/div&gt; &lt;!-- &lt;div class="c2"&gt; &lt;/div&gt; &lt;div class="c3"&gt; &lt;/div&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 边框使用边框来画一个梯形、三角形、扇形等 滚动、换行滚动行为和滚动条overflow属性有四个值可以取 文字换行CSS通常有三个属性来控制文字换行问题 CSS Hack CSS布局常用布局方法 table表格布局 float+margin布局 inline-block布局 flexbox布局 float+margin布局float基础特性 元素浮动 脱离文档流 但不脱离文本流 float对自身的影响 形成”块”(BFC) 位置尽可能靠上 位置尽可能靠左(右) float对兄弟的影响 上面一般贴着非float元素 旁边贴着float元素 不影响其它块级元素的位置 影响其它块级元素的内部文本 float对父级的影响 从布局上”消失” 高度塌陷 float demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!--经常使用的清除浮动的方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;float &lt;/title&gt; &lt;style&gt; .container&#123; background:red; width:400px; margin:20px; &#125; .p1&#123; background:green; float:left; width:200px; height:50px; &#125; .container2::after&#123; content: 'aaa'; clear:both; display: block; visibility: hidden; height:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;span class="p1"&gt; float &lt;/span&gt; &lt;div class="p2"&gt; 很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字 &lt;/div&gt; &lt;/div&gt; &lt;div class="container container2"&gt; &lt;span&gt;写几个字&lt;/span&gt; &lt;span class="p1"&gt; float &lt;/span&gt; &lt;span class="p1"&gt; float &lt;/span&gt; &lt;/div&gt; &lt;div class="container" style="height:200px;background:blue;"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; float+margin实现两栏/三栏布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width:800px; height:200px; &#125; .left&#123; background:red; /* float:left; */ /* height:100%; */ width:200px; position: absolute; height:200px; &#125; .right&#123; background:blue; float:right; width:200px; height:100%; &#125; .middle&#123; background: yellow; margin-left:200px; margin-right:200px; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt; 左 &lt;/div&gt; &lt;div class="right"&gt; 右 &lt;/div&gt; &lt;div class="middle"&gt; 中间 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; inline-block布局 像文本一样去排列block元素 没有清除浮动、高度塌陷等问题 但它需要处理间隙 处理间隙有两种方法： 将父级元素的font-size设为0，然后给子元素的font-size重新设为默认值。 将div标签之间的换行或者空格去除掉。 响应式设计和布局 在不同设备上正常使用 一般主要处理屏幕大小问题 主要方法： 隐藏+折行+自适应空间 rem / viewport / media query 响应式布局 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;responsive&lt;/title&gt; &lt;style&gt; .container&#123; margin:0 auto; max-width:800px; display: flex; border:1px solid black; &#125; .left&#123; display: flex; width: 200px; background:red; margin:5px; &#125; @media (max-width: 640px)&#123; .left&#123; display: none; &#125; &#125; .right&#123; display: flex; flex: 1; background:blue; margin:5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt; 这里是一些不重要的内容，比如友情链接、广告 &lt;/div&gt; &lt;div class="right"&gt; 这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;responsive&lt;/title&gt; &lt;style&gt; html&#123; font-size: 20px; &#125; .container&#123; margin:0 auto; max-width:800px; border:1px solid black; &#125; .intro&#123; display: inline-block; width:9rem; height:9rem; line-height: 9rem; text-align: center; border-radius: 4.5rem; border:1px solid red; margin:.3rem; &#125; @media (max-width: 375px)&#123; html&#123; font-size:24px; &#125; &#125; @media (max-width: 320px)&#123; html&#123; font-size:20px; &#125; &#125; @media (max-width: 640px)&#123; .intro&#123; margin:.3rem auto; display: block; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="intro"&gt; 介绍1 &lt;/div&gt; &lt;div class="intro"&gt; 介绍2 &lt;/div&gt; &lt;div class="intro"&gt; 介绍3 &lt;/div&gt; &lt;div class="intro"&gt; 介绍4 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS效果属性box-shadow 营造层次感（立体感） 充当没有宽度的边框 投影 特殊效果 box-shadow: (inset表示内阴影) [水平偏移量] [垂直偏移量] [模糊区域] [扩展区域] [半透明效果/颜色] box-shadow demo12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; background:red; width:150px; height:150px; margin: 50px; box-shadow: 5px 5px 10px 0 rgba(0,0,0,.5); /* box-shadow: inset 5px 5px 10px 0 rgba(0,0,0,.5); */ /* box-shadow: 0 0 0 5px green; */ &#125; .box2&#123; background:red; width:10px; height:10px; margin: 10px; border-radius: 5px; box-shadow: 20px 20px 0 4px green, 40px 20px 0 4px green, 30px 30px 0 -2px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用box-shadow来画哆啦A梦1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; position: relative; width: 36px; height: 36px; border-radius: 50%; margin: 300px auto; background-color: #C63D01; box-shadow: 0px 0px 0 1px #000, -20px -26px 0 -10px #333333, -34px -40px 0 15px #fff, -34px -40px 0 16px, 20px -26px 0 -10px #333333, 34px -40px 0 15px #fff, 34px -40px 0 16px, 0px 55px 0 75px #fff, 0px 55px 0 76px #000, 0 22px 0 120px #08BDEB, 0 22px 0 121px #000; &#125; /*叮当猫的鼻子*/ .container::before&#123; content: ''; position: absolute; bottom: -81px; left: 17px; height: 80px; width: 2px; background-color: #000; &#125; /*叮当猫的嘴巴*/ .container::after&#123; content: ''; position: absolute; bottom: -83px; left: -44px; width: 125px; height: 70px; border-bottom-right-radius: 28px; border-bottom: solid 2px black; border-bottom-left-radius: 28px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; clip-path 对容器进行裁剪 常见的几何图形(圆形、菱形、五角星等等) 可以做iOS的圆角 自定义路径 但是clip-path对有些浏览器的兼容性不是很好 clip-path demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 400px; height: 300px; border: 1px solid red; background:url(./panda.jpg); background-size: cover; background-repeat: no-repeat; background-position: center center; padding:10px; /* 矩形 内部裁剪 */ /* clip-path: inset(100px 50px); */ /* 菱形 */ /* clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); */ /* 圆形 带过渡动画 */ clip-path: circle(50px at 100px 100px); transition:clip-path .4s; /* 五角星 */ /* clip-path: url(#clipPath); */ &#125; .container:hover&#123; clip-path: circle(80px at 100px 100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; 你好，我是熊猫 &lt;/div&gt; &lt;svg&gt; &lt;defs&gt; &lt;clipPath id="clipPath"&gt; &lt;!-- &lt;circle cx="60" cy="60" r="50" fill="#34538b" /&gt; --&gt; &lt;polygon stroke="#979797" points="0.4921875 81.2070313 92.640625 81.2070313 121.601562 0.21875 153.648437 81.2070313 247.390625 80.7734375 173.394531 140.496094 200.308594 227.09375 121.601562 172.71875 53.4960937 227.09375 80.859375 140.496094"&gt;&lt;/polygon&gt; &lt;/clipPath&gt; &lt;/defs&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 2D/3D变换2D变换 transform变换 translate 偏移 scale 缩放 skew 斜切 rotate 旋转 3D变换 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; margin:50px; padding: 10px; border: 1px solid red; width: 200px; height: 200px; position: relative; perspective: 500px; &#125; #cube&#123; width:200px; height:200px; transform-style: preserve-3d; transform: translateZ(-100px); transition:transform .4s; &#125; #cube div&#123; width: 200px; height:200px; position: absolute; line-height: 200px; font-size:50px; text-align: center; &#125; #cube:hover&#123; /* transform: translateZ(-100px) rotateX(270deg); */ transform: translateZ(-100px) rotateX(90deg) rotateY(90deg); &#125; .front&#123; transform: translateZ(100px); /* transform: translateX(100px); */ /* transform: translateX(100px) translateY(10px) rotate(25deg); */ /* transform: rotate(25deg) translateX(100px) translateY(10px); */ background:rgba(255,0,0,.3); &#125; .back&#123; /* transform: translateZ(-100px); */ transform: translateZ(-100px) rotateY(180deg); background:rgba(0,255,0,.3); &#125; .left&#123; transform: translateX(-100px) rotateY(-90deg); background:rgba(0,0,255,.3); &#125; .right&#123; transform: translateX(100px) rotateY(90deg); background:rgba(255,255,0,.3); &#125; .top&#123; transform: translateY(-100px) rotateX(-90deg); background:rgba(255,0,255,.3); &#125; .bottom&#123; transform: translateY(100px) rotateX(90deg); background:rgba(0,255,255,.3); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="cube"&gt; &lt;div class="front"&gt;1&lt;/div&gt; &lt;div class="back"&gt;2&lt;/div&gt; &lt;div class="right"&gt;3&lt;/div&gt; &lt;div class="left"&gt;4&lt;/div&gt; &lt;div class="top"&gt;5&lt;/div&gt; &lt;div class="bottom"&gt;6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS动画 动画的原理: 视觉暂留作用 画面逐渐变化 动画的作用： 给用户愉悦感 引起用户注意 给用户操作反馈 掩饰后台加载 CSS动画类型 transition补间动画 keyframe关键帧动画 逐帧动画 transition补间动画 过渡动画需要有状态的变化 位置-平移(left/right/margin/transform) 方位-旋转(transform) 大小-缩放(transform) 透明度(opacity) 其它-线性变换(transform) transition demo1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; height: 100px; background: red; /* transition: width 1s, background 3s; transition-delay: 1s; */ transition: all 1s; /* transition-timing-function: ease-in-out; */ transition-timing-function: cubic-bezier(0.465, -0.460, 0.525, 1.435); &#125; .container:hover&#123; width: 800px; background:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; keyframe关键帧动画 相当于多个补间动画 但它与元素的状态变化无关 定义更加灵活 keyframe demo1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; height: 100px; background: red; animation: run 1s linear; /* 反向动画 */ /* animation-direction: reverse; */ /* 决定动画最后停在哪 */ /* animation-fill-mode: forwards; */ /* 动画次数 infinite为无限执行 */ animation-iteration-count: infinite; /* 播放状态 */ /* animation-play-state: paused; */ &#125; @keyframes run&#123; 0%&#123; width: 100px; &#125; 50%&#123; width: 800px; &#125; 100%&#123; width: 100px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 逐帧动画 其实还是属于关键帧动画的一种 适用于无法补间计算的动画 资源较大 使用steps(x): 指定两个关键帧之间有几个画面 逐帧动画 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!--实现猎豹跑动的动画--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; height: 100px; border: 1px solid red; background: url(./animal.png) no-repeat; animation: run 1s infinite; animation-timing-function: steps(1); &#125; @keyframes run&#123; 0%&#123; background-position: 0 0; &#125; 12.5%&#123; background-position: -100px 0; &#125; 25%&#123; background-position: -200px 0; &#125; 37.5%&#123; background-position: -300px 0; &#125; 50%&#123; background-position: 0 -100px; &#125; 62.5%&#123; background-position: -100px -100px; &#125; 75%&#123; background-position: -200px -100px; &#125; 87.5%&#123; background-position: -300px -100px; &#125; 100%&#123; background-position: 0 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS预处理器CSS预处理器简介 基于CSS的另一种语言 通过工具编译成CSS 添加了很多CSS不具备的特性 能提升CSS文件的组织方式 CSS预处理器特性 嵌套以反映层级和约束 变量和计算以减少重复代码 Extend和Mixin代码片段 循环以适用于复杂有规律的样式 import CSS文件以模块化 CSS预处理器框架 Less - Lesshat/EST SASS - Compass 提供现成的mixin 类似JS类库，封装常用功能 PostCSS后处理器 CSS工程化：组织 优化 构建 维护 PostCSS常见的插件 import 模块合并 将import的语句都内联进来，方便组织更好的代码 autoprefixier 自动加前缀 cssnano 压缩代码，一般放在配置项的最后面 cssnext 使用CSS新特性 precss变量、mixin、循环等等 autoprefixer的配置写法 cssnext precss 和预处理十分相似。 PostCSS支持的构建工具 CLI命令行工具 webpack postcss-loader Gulp gulp-postcss Grunt grunt-postcss Rollup rollup-postcss … webpack JS是整个应用的核心入口 一切资源均由JS管理依赖 一切资源均由webpack打包]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeCodeCamp上面的JS算法题]]></title>
    <url>%2F2017%2F03%2F11%2FFreeCodeCamp%E4%B8%8A%E9%9D%A2%E7%9A%84JS%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Info:Javascript中操作字符串和数组一些常见的方法。 Split Strings with split()12345var string = "Split me into an array";var array = [];array = string.split(" ");console.log(array); //[ 'Split', 'me', 'into', 'an', 'array' ] // split() 方法用于把一个字符串分割成字符串数组。// 提示： 如果把空字符串 (“ “) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。// 注意： split() 方法不改变原始字符串。 Get the sub string with substring/substr/slice()1234567891011var s = 'hello, world'var r1 = s.substring(0, 5); // 从索引0开始到5(不包括5)var r2 = s.substring(7); // 从索引7开始到结束var r3 = s.substr(2,4); //从索引开始找接下来的4个字符var r4 = s.slice(-5);console.log(r1); //helloconsole.log(r2); //worldconsole.log(r3); //llo,console.log(r4); //world Title Case a Sentence with toUpper/LowerCase()12345678910111213141516171819202122// 句中单词首字母大写:function titleCase(str) &#123; // 请把你的代码写在这里 arr = str.split(" "); var newStr = ""; for(var i = 0;i&lt;arr.length;i++)&#123; newStr += arr[i][0].toUpperCase(); for(var j = 1;j&lt;arr[i].length;j++)&#123; newStr += arr[i][j].toLowerCase(); &#125; if(i!=arr.length-1)&#123; newStr += " "; &#125;&#125; return newStr;&#125;var r = titleCase("I'm a little tea pot");console.log(r); //I'm A Little Tea Pot Get the index of string in a stringObj with indexOf/lastIndexOf()123456789var s = 'hello, world';var r1 = s.indexOf('world'); // 找到指定的子串,返回该子串第一次出现的位置var r2 = s.indexOf('sorld'); // 没有找到指定的子串，返回-1var r3 = s.lastIndexOf('l'); // 找到指定的子串，返回该子串最后一次出现的位置console.log(r1); //7console.log(r2); //-1console.log(r3); //10 Iterate over Arrays with map()1234567891011121314151617var oldArray = [1,2,3,4,5];// 只能在这一行下面写代码var newArray = oldArray.map(function(val)&#123; return val + 3;&#125;);console.log(newArray); //[ 4, 5, 6, 7, 8 ]// another// var numbers = [4, 9, 16, 25];// function myFunction() &#123;// x = document.getElementById("demo")// x.innerHTML = numbers.map(Math.sqrt);// &#125; // map() 方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。// map() 方法按照原始数组元素顺序依次处理元素。// 注意： map() 不会对空数组进行检测。// 注意： map() 不会改变原始数组。 Condense arrays with reduce()12345678910var array = [4,5,6,7,8];var singleVal = 0;// 只能在这一行下面写代码singleVal = array.reduce(function(pre,cur)&#123; return pre + cur ;&#125;);console.log(singleVal); //30 // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并(迭代)，最终计算为一个值。// 注意: reduce() 对于空数组是不会执行回调函数的。 Filter Arrays with filter()123456789var oldArray = [1,2,3,4,5,6,7,8,9,10];// 只能在这一行下面写代码var newArray = oldArray.filter(function(val)&#123; return val &lt; 6;&#125;);console.log(newArray); //[ 1, 2, 3, 4, 5 ] // filter 方法用来迭代一个数组，并且按给出的条件过滤出符合的元素。// filter 方法传入一个回调函数，这个回调函数会携带一个参数，参数为当前迭代的项（我们叫它 val ）。// 回调函数返回 true 的项会保留在数组中，返回 false 的项会被过滤出数组。 Sort Arrays with sort()1234567var array = [1, 21, 12, 2];array.sort(function(a, b) &#123; return b - a;&#125;); // 将数组元素从大到小排序console.log(array); //[ 21, 12, 2, 1 ] 1234567891011121314151617// 数组排序并找出元素索引:function where(arr, num) &#123; // 请把你的代码写在这里 var newArr = []; newArr = arr.concat(num); newArr.sort(function(a,b)&#123; return a-b; &#125;); for(var i =0;i&lt;newArr.length;i++)&#123; if(newArr[i] === num)&#123; return i;&#125; &#125;&#125;var r = where([40, 60], 50);console.log(r); //1 // sort() 方法将改变原数组，返回被排序后的数组。// sort() 可以把比较函数作为参数传入。比较函数有返回值，当 a 小于 b，返回一个负数；当 a 大于 b ，返回一个正数；相等时返回0。// 如果没有传入比较函数，它将把值全部转成字符串，并按照字母顺序进行排序。 Reverse Arrays with reverse()12345678var array = [1,2,3,4,5,6,7];var newArray = [];// 只能在这一行下面写代码newArray = array.reverse();console.log(newArray); //[ 7, 6, 5, 4, 3, 2, 1 ] // reverse()方法用于颠倒数组中元素的顺序。// reverse()方法会改变原来的数组，而不会创建新的数组。 Concatenate Arrays with concat()12345678var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe);console.log(newArray); //[ 1, 2, 3, 4, 5, 6 ] // concat()方法用于连接两个或多个数组。// concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 Join Strings with join()12345678var joinMe = ["Split","me","into","an","array"];var joinedString = ' ';// 只能在这一行下面写代码joinedString = joinMe.join(joinedString);console.log(joinedString); //Split me into an array // join() 方法用于把数组中的所有元素转换一个字符串。// 元素是通过指定的分隔符进行分隔的。 Find the Longest Word in a String with Math.max.apply()12345678910111213141516171819// 找到字符串中最长的单词function findLongestWord(str) &#123; var maxLength = 0; var arr = []; var s = str.split(" "); console.log(str); for(var i = 0;i&lt;s.length;i++)&#123; arr[i] = s[i].length; &#125; maxLength = Math.max.apply(null,arr); return maxLength;&#125;var r = findLongestWord("The quick brown fox jumped over the lazy dog");console.log(r); //6 //Math.max.apply()方法可以得到数组中最大的数,Math.max.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 Remove the smallest number in an array with splice()123456789function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); //[ 2, 3, 4, 1, 2, 5 ] //splice()方法:arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 es6的find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12345[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 [1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9; &#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9; &#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。另外，这两个方法都可以发现♂，弥补了数组的IndexOf方法的不足。 1234[NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>algorithm</tag>
        <tag>freecodecamp</tag>
        <tag>array</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习【二】]]></title>
    <url>%2F2017%2F03%2F08%2FJavascript%E5%AD%A6%E4%B9%A0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:JS学习的补充笔记，包括JS-Web-Api、事件绑定、事件冒泡、事件代理、AJAX、跨域和存储 日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date(); //Date()是一个构造函数，.now是他的一个属性函数dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月（0 - 11）dt.getDate(); //日（0 - 31）dt.getHours(); //小时（0 - 23）dt.getMinutes(); //分钟（0 - 59）dt.getSeconds(); //秒（0 - 59） MathMath.random()获取随机数 数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否至少有一个元素符合条件 sort 排序 map 对元素重新组装，生成一个新数组 filter 过滤符合条件的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.forEachvar arr = [1,2,3];arr.forEach( function(item, index) &#123; console.log(index,item);// 0 1 1 2 2 3&#125;);// 2.everyvar arr = [1,2,3];var result = arr.every(function(item,index)&#123; if(item &lt; 4)&#123; return true; &#125;&#125;)console.log(result); // true// 3.somevar arr = [1,2,3];var result = arr.some(function(item,index)&#123; if(item &lt; 2)&#123; return true; &#125;&#125;)console.log(result); //true// 4.sortvar arr = [1,4,3,5,2];var arr2 = arr.sort(function(a,b)&#123; return a - b; //从小到大排序&#125;)console.log(arr2); //[1,2,3,4,5]// 5.mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index)&#123; return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;)console.log(arr2); //[ '&lt;b&gt;1&lt;/b&gt;', '&lt;b&gt;2&lt;/b&gt;', '&lt;b&gt;3&lt;/b&gt;', '&lt;b&gt;4&lt;/b&gt;' ]// 6.filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index)&#123; //通过某个条件过滤数组 if(item &gt;= 2)&#123; return true; &#125;&#125;)console.log(arr2); //[2,3] 不管是forEach还是map在IE6-8下都不兼容（不兼容的情况下在Array.prototype上没有这两个方法） 对象API1234567891011var obj = &#123; x: 100, y: 200, z: 300&#125;var key;for (key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key,obj[key]); &#125;&#125; // x 100 y 200 z 300 事件通用事件绑定123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href="http://baidu.com" id="link1"&gt; &lt;button type="button" id="btn1"&gt;我是按钮&lt;/button&gt; &lt;/a&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById('btn1'); btn.addEventListener('click', function(event)&#123; console.log('clicked'); &#125;) function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var a = document.getElementById('link1'); bindEvent(a,'click', function(e)&#123; e.preventDefault(); //阻止默认行为 alert('clicked'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件冒泡12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var p1 = document.getElementById('p1'); var body = document.body; bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); //阻止事件冒泡 alert('激活'); &#125;) bindEvent(body,'click',function(e)&#123; alert('取消'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代理 （冒泡的应用）它还有一个名字叫事件委托，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul li &#123; display: block; height: 50px; width: 100px; text-align: center; line-height: 50px; background-color: #888; margin-bottom: 8px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="Inul"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;li&gt;555&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //不使用事件委托 /*window.onload = function()&#123; var oUL = document.getElementById("Inul"); var aLi = oUL.getElementsByTagName("li"); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125; &#125;*/ //使用事件委托 window.onload = function () &#123; var oUL = document.getElementById("Inul"); oUL.onclick = function () &#123; alert(123); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代理的两个优点：1.使得代码比较简洁2.给浏览器的压力比较小 AJAXAJAX的全称 Asynchronous Javascript And XML 异步JavaScript和XML XMLHttpRequest123456789101112var xhr = new XMLHttpRequest()xhr.open("GET","/api",true)xhr.onreadystatechange = function () &#123; // 第三个参数为true,这里的函数为异步执行 if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.send(null) 跨域什么是跨域 可以跨域的三个标签但是有三个标签可以跨域加载资源 &lt;img src = “XXX”&gt; （图片） &lt;link herf = “XXX”&gt; （CSS） &lt;script src = “XXX”&gt; （JS） 这三个标签的场景 &lt;img&gt;用于打点统计，统计网站可能是其他域 &lt;link&gt;&lt;script&gt;可以使用CDN，CDN的也是其他域 &lt;script&gt;可以用于JSONP 跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许就能够获取到，那就是浏览器的同源策略出现了漏洞 解决跨域的方法 JSONP JSONP的工作原理： 很简单，就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，形如：&lt;script src=”http://www.example.net/api?param1=1&amp;param2=2&quot;&gt; &lt;/script&gt;并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）形如:callback({“name”:”hax”,”gender”:”Male”})。 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 补充：“历史遗迹”的意思就是，如果在今天重新设计的话，也许就不会允许这样简单的跨域了嘿，比如可能像XHR一样按照CORS规范要求服务器发送特定的http头。 服务器端设置 http header（即CORS（跨域资源共享）） 存储 cookie localStorage 和 sessionStorage cookie与webStorage的区别]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>js-web-api</tag>
        <tag>ajax</tag>
        <tag>事件</tag>
        <tag>跨域</tag>
        <tag>cookie</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习【一】]]></title>
    <url>%2F2017%2F03%2F06%2FJavascript%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:之前JS学习的一些笔记，包括JS变量类型以及JS的三个重点：原型和原型链、作用域与闭包、异步和单线程 变量类型和计算引用类型（3种）对象、数组、函数。 引用类型的内存只存一份，而值类型是存多份 引用类型可以无限扩展属性 typeof（6种）undefined、number、string、boolean、object、function。 强制类型转换 字符串拼接； ==运算符； if条件语句； 逻辑运算（与或非)。 何时使用==if(obj.a == null){ … } //这里是简写，相当于obj.a === null || obj.a === undefined。其他时候全部用三等“===”。 if(…){ }条件为假的几种情况 0； NaN； “”; null; undefined; false。 JS中的内置函数（数据封装内对象） Object； Array； Boolean； Number； String； Function； Date； RegExp； Error。 如何理解JSON JSON.stringify({a:10,b:20}); // 把对象变成字符串 JSON.parse(‘{“a”:10,”b”:20}’)。 // 把字符串变成对象 （JSON只不过是一个JS对象）上面就是JSON常见的两个API。 原型与原型链构造函数12345678910111213function Foo(name,age)&#123; //构造函数首字母大写 this.name = name; this.age = age; this.class = 'class-1'; //return this; //返回这个对象&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);console.log(f); //Foo &#123; name: 'zhangsan', age: 20, class: 'class-1' &#125;console.log(f instanceof Object); //true 构造函数—拓展 var a = { } 其实是var a = new Object()的语法糖； var a = [ ] 其实是var a = new Array()的语法糖； function Foo(){…} 其实是var Foo = new Function()的语法糖； 使用instanceof判断一个函数是否是一个变量的构造函数。 原型规则和示例 所有的引用类型（对象、数组、函数）都具有对象特性，即可自由拓展属性（除了”null”之外）； 所有的引用类型（对象、数组、函数）都有一个__proto__（隐式原型）属性，属性值是一个普通的对象； 所有的函数都有一个prototype（显式原型）属性，属性值是一个普通的对象； 所有的引用类型（对象、数组、函数），__proto__属性值指向它的构造函数的prototype属性值； 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找。 123456789101112131415//第一条规则：var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn()&#123;&#125;; fn.a = 100;//第二条规则：console.log(obj.__proto__); //&#123;&#125;console.log(arr.__proto__); //[]console.log(fn.__proto__); //[Function]//第三条规则：console.log(fn.prototype); //fn &#123;&#125;//第四条规则：console.log(obj.__proto__ === Object.prototype); //true 12345678910111213141516171819202122// 第五条规则：// 构造函数function Foo (name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function()&#123; alert(this.name);&#125;// 创建示例var f = new Foo('zhangsan');f.printName = function () &#123; console.log(this.name);&#125;// 测试f.printName(); //zhangsanf.alertName(); //zhangsanf.toString(); //要去 f.__proto__.__proto__中去寻找//console.log(f.__proto__.__proto__.__proto__); //null 补充： 12345678var item;for(item in f)&#123; // 虽然高级浏览器已经在 for in 中屏蔽了来自原型的属性 // 但是还是建议加上这个判断，保证程序的健壮性 if(f.hasOwnProperty(item))&#123; console.log(item); &#125;&#125; 原型链 instanceof用于判断引用类型属于那个构造函数的方法。 关于原型和原型链的几个问题1.如何准确判断一个变量是数组类型： 123var arr = [];arr instanceof Array; //truetypeof arr; //Object(typeof是无法准确判断是否是数组的 2.写一个原型链继承的例子： 12345678910111213141516171819202122232425//普通版：// 动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125;// 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat() 12345678910111213141516171819202122232425262728293031323334//高级版（写一个封装DOM查询的例子）：function Elem (id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val)&#123; var elem = this.elem; if(val)&#123; elem.innerHTML = val; return this; //链式操作 &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function (type,fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem('div1');// console.log(div.html())div1.html('&lt;p&gt;hello world&lt;/p&gt;');div1.on('click',function () &#123; alert('clicked!');&#125;)//因为有第十行的“return this”（返回的是this这个对象），所以可以进行链式操作：// div1.html('&lt;p&gt;hello world&lt;/p&gt;').on('click',function()&#123;// alert('clicked!');// &#125;); 3.描述new一个变量的过程： 即考察对构造函数的理解。 创建一个新对象； this指向这个对象； 执行代码，即对this赋值； 返回this。 4.zepto（或其他框架）源码中如何使用原型链： zepto设计和源码分析 作用域与闭包执行上下文 范围：一段&lt;script&gt;或者一个函数 全局：变量定义、函数声明 （一段&lt;script&gt;） 函数：变量定义、函数声明、this、arguments （一个函数） 123456789console.log(a); //undefinedvar a = 100;fn('zhangsan');function fn (name) &#123; age = 20; console.log(name,age); //zhangsan 20 var age;&#125; this this要在执行时才能确认值，定义时无法确认。 作为构造函数执行； 作为对象属性执行； 作为普通函数执行； call()、apply()、bind()； 1234567891011121314151617181920212223242526272829303132333435363738394041//1.作为构造函数执行function Foo (name) &#123; this.name = name;&#125;var f = new Foo('zhangsan');//2.作为对象属性执行var obj = &#123; name: 'A', printName: function () &#123; console.log(this.name); &#125;&#125;obj.printName(); //A (this ===obj)//3.作为普通函数执行function fn()&#123; console.log(this);&#125;fn(); ///undefined (this === window)//4.call和apply（都用来改变this的值，call在实际工作中用的更多,两者传参方式不一样，apply用数组格式）function fn1(name,age)&#123; alert(name) alert(age) console.log(this)&#125;fn1.call(&#123;x:100&#125;,'zhangsan',22)//bind（同样用来改变this的值，注意函数声明要用函数表达式的方式）var fn2 = function (name,age)&#123; alert(name) alert(age) console.log(this)&#125;.bind(&#123;x:100&#125;)fn2('zhangsan',22) 作用域 JS没有块级作用域； 只有函数和全局作用域； 1234567891011121314// 无块级作用域if(true)&#123; var name = 'zhangsan';&#125; //大括号相当于一个块console.log(name); //zhangsan// 函数和全局作用域var a = 100;function fn () &#123; var a = 200; console.log('fn',a);&#125;fn(); //fn 200console.log('global',a); //global 100 作用域链1234567891011121314var a = 100;function fn1 () &#123; var b =200; function fn2 () &#123; var c = 300; //当前作用域没有定义的变量，即“自由变量”，自由变量要去声明时候的作用域去找，而不是执行时候的作用域 console.log(a); //a是自由变量，则要到当前fn2作用域的父级作用域去找，没有找到，则继续到fn1的父级作用域去找 console.log(b); //b是自由变量，则要到当前fn2作用域的父级作用域去找，即fn1的作用域，找到了 console.log(c); &#125; fn2();&#125;fn1(); //100 200 300 闭包闭包的使用场景 函数作为返回值； 函数作为参数传递； 123456789101112// 1.函数作为返回值： function fn1 () &#123; var a = 100; return function () &#123; // 返回一个函数（函数作为返回值） console.log(a); // 自由变量，父作用域查找 &#125;&#125;// fn1得到一个函数var f1 = fn1();var a = 200;f1(); //100 123456789101112131415// 2.函数作为参数传递function fn1 () &#123; var a = 100; return function () &#123; console.log(a); &#125;&#125;var f1 = fn1();function fn2 (fn) &#123; //函数作为参数传递 var a = 200; fn()&#125;fn2(f1); //100 闭包的示例12345678910111213141516171819202122// 1.查询是否是第一次载入：// 闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad () &#123; var _list = []; return function (id) &#123; if(_list.indexOf(id) &gt;= 0)&#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;// 使用var firstLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true// 在isFirstLoad函数外面，根本不可能改掉_list的值 123456789101112131415// 2.创建10个a标签，点击弹出相应的序号：var i;for(i = 0;i &lt; 10;i++)&#123; (function (i)&#123; // 自执行函数，就是不用调用，只要定义完成，立刻执行的函数 // 函数作用域 var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function(e)&#123; e.preventDefault(); alert(i); //自由变量，要去父级作用域获取值 &#125;) document.body.appendChild(a); &#125;)(i)&#125; 异步和单线程什么是异步（对比同步）1234567891011// 异步：console.log(100);setTimeout(function()&#123; console.log(200);&#125;,1000)console.log(300); //先打印100，然后打印300，过一秒钟再打印200// 对比同步：console.log(100);alert(200); //程序阻塞在这里，如果不点击确认就会卡在这里console.log(300); 何时需要异步 在可能发生等待的情况； 等待过程中不能像alert一样阻塞程序的执行； 因此，所有“等待的情况”都需要异步； //并非“阻塞的情况” 前端使用异步的场景 定时任务：setTimeout、setInterval； 网络请求：ajax请求、es6中的promise、动态&lt;img&gt;加载； 事件绑定； setTimeout(表达式,延时时间)和setInterval(表达式,延时时间)经常被用来处理延时和定时任务。setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,而setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。 很多人会将setTimeout包含于被执行函数中,然后在函数外再次使用setTimeout来达到定时执行的目的。这样,函数外的setTimeout在执行函数时再次触发setTimeout从而形成周而复始的定时效果； 使用的时候各有各的优势，使用setInterval，需要手动的停止tick触发。而使用方法中嵌套setTimeout，可以根据方法内部本身的逻辑不再调用setTimeout就等于停止了触发。其实两个东西完全可以相互模拟，具体使用那个，看当时的需要而定了。 12345678910111213141516171819202122// ajax请求代码示例：console.log('start');$.get('./datta1.json',function(data1)&#123; console.log(data1);&#125;)console.log('end');// &lt;img&gt;加载示例：console.log('start');var img = document.createElement('img');img.onload = function()&#123; console.log('loaded');&#125;img.src = '/xxx.img';console.log('end');// 事件绑定示例：console.log('start');document.getElementById('btn1').addEventListener('click', function()&#123; alert('clicked');&#125;)console.log('end'); 异步和单线程1234567891011// 单线程：一次只能干一件事，一个一个排队来console.log(100);setTimeout(function()&#123; console.log(200);&#125;)console.log(300);// 1. 执行第一行，打印100；// 2. 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）；// 3. 执行最后一行，打印300；// 4. 待所有的程序执行完，处于空闲状态时，会立马看有没有暂存起来的需要执行；// 5. 发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行； 关于异步和单线程的几个问题 同步和异步的区别是什么。分别举一个同步和异步的例子： 同步会阻塞代码执行，而异步不会； alert是同步，setTimeout是异步。 一个关于setTimeout的笔试题： 12345678910console.log(1);setTimeout(function()&#123; console.log(2)&#125;,0);console.log(3);setTimeout(function()&#123; console.log(4);&#125;,1000);console.log(5);// result: 1 3 5 2 4]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>异步</tag>
        <tag>JS变量类型</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
        <tag>单线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F03%2F04%2FGithub-Pages-Hexo%E5%8D%9A%E5%AE%A2-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这两天也算是摸爬滚打终于搭建成功了这个Hexo博客，然后也是想把过程记录一下，把整个步骤分享给大家（虽然可能也不会有人看到。。 Hexo本地环境搭建Git环境 首先我们需要一个git环境，MacOS的XCode是自带git的所以也无需重复安装。 如果是Windows用户的话，可以去Git官网根据自己的电脑操作系统位数下载相应的版本，下载完成后点击安装，一路next即可。 Windows用户还需要配置环境变量，具体操作可参考度娘上面的教程：Git的安装与配置 测试是否安装配置成功：win+R打开运行，输入cmd打开命令提示窗口，输入如下命令： git –version 如果正确打印出安装的Git版本号，则说明安装成功。 Node.js环境 Mac用户可以通过Homebrew来安装(推荐)，具体步骤如下： 先安装Homebrew： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 然后更新brew确保其可用： brew update 再安装环境所需的Node.js： brew install node 验证是否安装成功： node -vnpm -v 如果正确打印出安装的Node版本号，则说明安装成功。 Windows用户，可以去Node官网根据自己的操作系统位数下载安装（过程跟上述安装Git的步骤类似，在此不再赘述。。 Hexo环境Hexo是一款基于Node.js的静态博客框架，所以之前的那些步骤都是为了安装hexo所做的准备，具体安装hexo的步骤如下： 选择一个你喜欢的目录，用来存放你的hexo博客的所有文件，在此目录下运行你的Git Bash（Windows直接右键你所选择的目录会有个Git Bash选项，点击即可。Mac用户则是打开你的Terminal工具，cd到你所选择的目录再进行一系列的操作） 正式安装Hexo，输入如下指令： npm install -g hexo-cli 当然由于我国的社会主义核心建设，上述命令可能被墙，从而导致安装失败。此时将命令中的npm镜像源改成国内万能的某宝提供的镜像源即可： sudo npm install -g hexo-cli –registry=https://registry.npm.taobao.org 初始化hexo： hexo init hexo 正确初始化后会得到这样的反馈：INFO Start blogging with Hexo! 安装依赖文件： npm install 部署形成文件： hexo generate(或者 hexo g) 本地测试： hexo server(或者 hexo s) 正确完成到了这一步后，在浏览器输入 http://localhost:4000 后就能看到搭建好的hexo站点了。 接下来的步骤则是将本地的hexo放到github上托管，再重定向到你的个人域名以方便访问。 Github Pages注册Github如果不是程序员的话，可能会没有Github账号，这时就需要去Github官网去注册一个账号。注册成功后记得去你填的那个邮箱查收验证确认邮件。 新建一个仓库（new repository）注册登录成功后，去你的github主页点击”New repository”，取名为 “your_user_name.github.io”。 启用Github Pages 进入版本库后，点击右上方的setting，往下翻到Github Pages，点击Launch automatic page generator。 再然后来到New user site页面后点击右下角的Continue to layouts。 最后点击”Publish page”,发布github默认生成的一个静态站点。此时我们就可以通过在浏览器输入“your_user_name.github.io”来访问你的github站点主页。 将Hexo本地项目托管到GitHub Pages建立关联进入到你的本地hexo博客目录，有个_config.yml文件（全局配置文件），打开它，翻到最后面，将deploy改成如下所示： type: gitrepository: https://github.com/your_user_name/your_user_name.github.io.gitbranch: master 安装hexo-deployer-git插件在你的博客目录下输入如下命令： npm install hexo-deployer-git –save 将本地博客部署到GitHub Pages上依次执行下面三条命令： hexo cleanhexo generator 或 hexo ghexo deploy 或 hexo d 如果得到如下输出： INFO Deploy done: git 则说明部署成功。此时你可以通过在浏览器输入“your_user_name.github.io”来访问到你的hexo博客了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
        <tag>share</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F03%2FHello%20World%2F</url>
    <content type="text"><![CDATA[写在开始 阮一峰老师说，喜欢写blog的人，会经历三个阶段。 （1）第一阶段，刚接触blog，觉得很新鲜，试着注册一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我就是这个样子。本来用的博客园，但总感觉不属于自己，再加上个人对博客园的界面颇有微词，一个偶然间看到了别人的hexo个人网站，觉得简洁的风格很好看也挺geek，于是瞬间倒戈。。 再然后Hexo是一个基于Node.js的静态博客程序，生成的静态网页可以直接放到GitHub Pages上面（ps。顺便还能绿化一下GitHub的Contributions岂不是挺美滋滋？？ 然后我又想到自己之前买过腾讯家的服务器还送了域名，就准备将博客绑定下自己的域名，这样感觉就像是拥有了自己的小窝（虽然一系列的过程也是挺折腾的。。orz 到现在对着别人的“5分钟 就能搭建好免费个人博客”教程，折腾了好几个小时，中间还出现很意外的错误，终于是搞定下来了。。 当通过访问自己的域名看到博客加载下来之后，还是有些喜悦和成就感的。毕竟这也不是QQ空间、不是新浪微博、不是豆瓣小站。它更像是身为码农的我辛辛苦苦分到一块地，加以耕耘后不再需要在地主的土地上创造流量价值，感觉还是非常不错的。。 写在最后虽然感觉这个博客上也不会有什么人一起交流，但认为博客的价值还是在于记录，等你回头看你的博客时，能够让你你看到时光在你身上翻飞的样子。 总之，Hello World ～ 😘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>note</tag>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>
