<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FreeCodeCamp上面的JS算法题]]></title>
    <url>%2F2017%2F08%2F06%2FFreeCodeCamp%E4%B8%8A%E9%9D%A2%E7%9A%84JS%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Info:Javascript中操作字符串和数组一些常见的方法。 Split Strings with split()12345var string = "Split me into an array";var array = [];array = string.split(" ");console.log(array); //[ 'Split', 'me', 'into', 'an', 'array' ] // split() 方法用于把一个字符串分割成字符串数组。// 提示： 如果把空字符串 (“ “) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。// 注意： split() 方法不改变原始字符串。 Get the sub string with substring/substr/slice()1234567891011var s = 'hello, world'var r1 = s.substring(0, 5); // 从索引0开始到5(不包括5)var r2 = s.substring(7); // 从索引7开始到结束var r3 = s.substr(2,4); //从索引开始找接下来的4个字符var r4 = s.slice(-5);console.log(r1); //helloconsole.log(r2); //worldconsole.log(r3); //llo,console.log(r4); //world Title Case a Sentence with toUpper/LowerCase()12345678910111213141516171819202122// 句中单词首字母大写:function titleCase(str) &#123; // 请把你的代码写在这里 arr = str.split(" "); var newStr = ""; for(var i = 0;i&lt;arr.length;i++)&#123; newStr += arr[i][0].toUpperCase(); for(var j = 1;j&lt;arr[i].length;j++)&#123; newStr += arr[i][j].toLowerCase(); &#125; if(i!=arr.length-1)&#123; newStr += " "; &#125;&#125; return newStr;&#125;var r = titleCase("I'm a little tea pot");console.log(r); //I'm A Little Tea Pot Get the index of string in a stringObj with indexOf/lastIndexOf()123456789var s = 'hello, world';var r1 = s.indexOf('world'); // 找到指定的子串,返回该子串第一次出现的位置var r2 = s.indexOf('sorld'); // 没有找到指定的子串，返回-1var r3 = s.lastIndexOf('l'); // 找到指定的子串，返回该子串最后一次出现的位置console.log(r1); //7console.log(r2); //-1console.log(r3); //10 Iterate over Arrays with map()1234567891011121314151617var oldArray = [1,2,3,4,5];// 只能在这一行下面写代码var newArray = oldArray.map(function(val)&#123; return val + 3;&#125;);console.log(newArray); //[ 4, 5, 6, 7, 8 ]// another// var numbers = [4, 9, 16, 25];// function myFunction() &#123;// x = document.getElementById("demo")// x.innerHTML = numbers.map(Math.sqrt);// &#125; // map() 方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。// map() 方法按照原始数组元素顺序依次处理元素。// 注意： map() 不会对空数组进行检测。// 注意： map() 不会改变原始数组。 Condense arrays with reduce()12345678910var array = [4,5,6,7,8];var singleVal = 0;// 只能在这一行下面写代码singleVal = array.reduce(function(pre,cur)&#123; return pre + cur ;&#125;);console.log(singleVal); //30 // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并(迭代)，最终计算为一个值。// 注意: reduce() 对于空数组是不会执行回调函数的。 Filter Arrays with filter()123456789var oldArray = [1,2,3,4,5,6,7,8,9,10];// 只能在这一行下面写代码var newArray = oldArray.filter(function(val)&#123; return val &lt; 6;&#125;);console.log(newArray); //[ 1, 2, 3, 4, 5 ] // filter 方法用来迭代一个数组，并且按给出的条件过滤出符合的元素。// filter 方法传入一个回调函数，这个回调函数会携带一个参数，参数为当前迭代的项（我们叫它 val ）。// 回调函数返回 true 的项会保留在数组中，返回 false 的项会被过滤出数组。 Sort Arrays with sort()1234567var array = [1, 21, 12, 2];array.sort(function(a, b) &#123; return b - a;&#125;); // 将数组元素从大到小排序console.log(array); //[ 21, 12, 2, 1 ] 1234567891011121314151617// 数组排序并找出元素索引:function where(arr, num) &#123; // 请把你的代码写在这里 var newArr = []; newArr = arr.concat(num); newArr.sort(function(a,b)&#123; return a-b; &#125;); for(var i =0;i&lt;newArr.length;i++)&#123; if(newArr[i] === num)&#123; return i;&#125; &#125;&#125;var r = where([40, 60], 50);console.log(r); //1 // sort() 方法将改变原数组，返回被排序后的数组。// sort() 可以把比较函数作为参数传入。比较函数有返回值，当 a 小于 b，返回一个负数；当 a 大于 b ，返回一个正数；相等时返回0。// 如果没有传入比较函数，它将把值全部转成字符串，并按照字母顺序进行排序。 Reverse Arrays with reverse()12345678var array = [1,2,3,4,5,6,7];var newArray = [];// 只能在这一行下面写代码newArray = array.reverse();console.log(newArray); //[ 7, 6, 5, 4, 3, 2, 1 ] // reverse()方法用于颠倒数组中元素的顺序。// reverse()方法会改变原来的数组，而不会创建新的数组。 Concatenate Arrays with concat()12345678var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe);console.log(newArray); //[ 1, 2, 3, 4, 5, 6 ] // concat()方法用于连接两个或多个数组。// concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 Join Strings with join()12345678var joinMe = ["Split","me","into","an","array"];var joinedString = ' ';// 只能在这一行下面写代码joinedString = joinMe.join(joinedString);console.log(joinedString); //Split me into an array // join() 方法用于把数组中的所有元素转换一个字符串。// 元素是通过指定的分隔符进行分隔的。 Find the Longest Word in a String with Math.max.apply()12345678910111213141516171819// 找到字符串中最长的单词function findLongestWord(str) &#123; var maxLength = 0; var arr = []; var s = str.split(" "); console.log(str); for(var i = 0;i&lt;s.length;i++)&#123; arr[i] = s[i].length; &#125; maxLength = Math.max.apply(null,arr); return maxLength;&#125;var r = findLongestWord("The quick brown fox jumped over the lazy dog");console.log(r); //6 //Math.max.apply()方法可以得到数组中最大的数,Math.max.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 Remove the smallest number in an array with splice()123456789function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); //[ 2, 3, 4, 1, 2, 5 ] //splice()方法:arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>algorithm</tag>
        <tag>study</tag>
        <tag>freecodecamp</tag>
        <tag>array</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几道Codewars上面的编程题]]></title>
    <url>%2F2017%2F07%2F24%2F%E8%AE%B0%E5%87%A0%E9%81%93Codewars%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每次做完看到别人的答案：wtf ??? NO.1题目描述： 解法:12345678function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); Math.min()方法: 可以得到数组中最小的数,Math.min.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 splice()方法: arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 NO.2题目描述： 我的解法：123456function isTriangle(a,b,c)&#123; var p = (a + b + c)/2; var S = Math.sqrt(p*(p-a)*(p-b)*(p-c)); return S &gt; 0;&#125; 得票最高的解法： orz。。 NO.3题目描述： 我的解法：123456789101112function sumArray(array) &#123; if(!array || array == null)&#123;return 0&#125;; var max = Math.max.apply(null,array); var min = Math.min.apply(null,array); array.splice(array.indexOf(max),1); array.splice(array.indexOf(min),1); console.log(array); for(var sum = 0,i = 0;i &lt; array.length;i++)&#123; sum += array[i]; &#125; return sum;&#125; 得票最高的解法：1sumArray = a =&gt; a ? a.sort((x, y) =&gt; x - y).slice(1, -1).reduce((s, e) =&gt; s + e, 0) : 0 ??? (黑人问号脸。。 NO.4题目描述： 我的解法：1234567var gimme = function(inputArray) &#123; let min = inputArray.indexOf(Math.min(...inputArray)), max = inputArray.indexOf(Math.max(...inputArray)); if (min === 0 &amp;&amp; max === 2 || max === 0 &amp;&amp; min === 2) return 1; if (min === 1 &amp;&amp; max === 2 || max === 1 &amp;&amp; min === 2) return 0; if (min === 0 &amp;&amp; max === 1 || max === 0 &amp;&amp; min === 1) return 2;&#125;; 得票最高的解法： 溜了溜了。。 PS。虽然这些高票答案精简得不行，但至少我写的代码块可读性强啊。。（微笑]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>codewars</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【二】]]></title>
    <url>%2F2017%2F07%2F20%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO : 前端面试。 基础部分 1.prototype和proto的关系是什么2.meta viewport原理3.域名收敛是什么4.float和display：inline-block；的区别5.前端优化策略列举6.首屏、白屏时间如何计算7.闭包8.作用域链9.ajax如何实现、readyState五种状态的含义10.jsonp如何实现11.怎么处理跨域12.restful的method解释13.get和post的区别14.事件模型解释15.编写一个元素拖拽的插件16.编写一个contextmenu的插件17.编写web端cookie的设置和获取方法18.兼容ie６的水平垂直居中19.兼容ie的事件封装20.h5和原生android的优缺点21.编写h5需要注意什么22.xss和crsf的原理以及怎么预防23.css优先级24.如何实现点击radio的文字描述控制radio的状态（通过label实现）25.delegate如何实现 框架原理angularjs 1.angular的directive怎么写2.angular的脏检查（双向绑定）是如何实现的3.依赖注入如何实现4.scope如何实现5.$parse模块如何实现（主要自己写了一个类似的库） react 1.react在setState后发生了什么（直接说了setState源码）2.flux解释3.对react有什么了解（直接说了react中虚拟dom内部表示，mount过程源码和同步过程源码） jsBridge 如何说服对方使用jsBridge requirejs 1.amd和cmd区别，怎么了解到这些区别的，是否是去看了规范2.requirejs那些经常用的方法，然后对其进行解释 weex weex实现大致原理（只写过demo，面试管很好没有难为我，只问了这一个问题） http协议 1.accept是什么，怎么用2.http协议状态码，302和303的区别3.前端缓存如何实现、etag如何实现、etag和cache-control的max-age的优先级哪个比较高以及为什么、cache-control和expire优先级哪个比较高以及为什么 node 1.Buffer模块是干什么的2.Stream是什么，使用的两种模式3.http模块如何将异步处理方式实现成同步处理方式，具体解析请参考http模块如何将异步处理转成同步处理http://blog.csdn.net/wanglei20116527/article/details/62892070 其他问题 1.utf8和gbk的区别2.知道页面上某个点的坐标，如何获取该坐标上的所有元素3.angular、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）4.7点15分小于180度的夹角是多少5.大数相加6.给５升和６升的水杯如何倒出３升的水7.一班喜欢足球的人60%，喜欢排球的70%，喜欢篮球的80%，求喜欢足球和排球的占多少8.前端异常监测如何实现9.直播点赞按钮的冒泡功能如何实现10.js的uglify如何实现11.项目架构、如何带人（自己带过一个小团队）12.前端工程化方面做了哪些东西 面试中的收获 最开始面试时只阅读过angular源码，一面完后面试官对我说react用的不熟悉没关系，弄懂原理也可以，之后三天疯狂阅读react源码，对于react中虚拟dom内在表示、mount过程、setState的同步过程有了清晰的认识。面试官建议去阅读node的http模块和Stream模块源码，其中node-v0.1.100的http模块源码已经阅读完，并且写了一个基于net模块的http模块。node-v6.9.1的Stream模块源码现在还在阅读中。初步了解了前端异常监测，并且了解了百姓网、腾讯和阿里在前端异常监测的一些方案和框架。阅读了大量前端工程化方面的博文，对前端工程化有了进一步的理解。了解了angular和react产生背景。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html/css</tag>
        <tag>http</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【一】]]></title>
    <url>%2F2017%2F07%2F18%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO ：这段时间遇到的面试题。 1.前端页面由哪三层构成及各层的作用 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本语言负责。解决了页面上“内容应该如何对事件作出反应”的问题。 2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea; 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote; 空元素：br、meta、hr、link、input、img。 3.简述盒模型 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。CSS3中有个box-sizing属性可以控制盒子的计算方式。 W3C盒子模型：content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。 IE6盒子模型：border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。 4.什么是CSS Hack针对不同的浏览器写不同的CSS,就是 CSS Hack。IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：123456789101112131415 // 1、条件Hack&lt;!--[if IE]&gt; &lt;style&gt; .test&#123;color:red;&#125; &lt;/style&gt;&lt;![endif]--&gt;// 2、属性Hack .test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */ &#125;// 3、选择符Hack * html .test&#123;color:#090;&#125; /* For IE6 and earlier */ * + html .test&#123;color:#ff0;&#125; /* For IE7 */ 5.简述同步和异步 同步是阻塞模式：同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步是非阻塞模式：异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 6.浏览器的内核分别是什么 IE: trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 7.什么叫优雅降级和渐进增强及其区别 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 8.px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 9.浏览器本地存储 sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 10.web storage和cookie的区别 Cookie的大小是受限的； 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽； cookie还需要指定作用域，不可以跨域调用； Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie； Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生； IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage； 11.请列举几种可以清除浮动的方法 浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部由于不存在其他普通流元素了，表现出高度为0（高度塌陷）。 添加额外标签，例如&lt;div style=”clear:both”&gt;&lt;/div&gt; 使用br标签和其自身的html属性，例如&lt;br clear=”all” /&gt; 父元素设置 overflow：hidden；在IE6中还需要触发hasLayout，例如zoom:1； 父元素设置 overflow：auto 属性；同样IE6需要触发hasLayout； 父元素也设置浮动； 父元素设置display:table； 使用:after 伪元素；由于IE6-7不支持:after，使用 zoom:1触发hasLayout。 在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称BFC。 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。 IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。 12.对BFC规范的理解 BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动，防止与浮动元素重叠。 13.WEB应用从服务器主动推送Data到客户端有那些方式 Html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe &lt;script&gt;标签的长时间连接(可跨域) 14.网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 15.对标签语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 16.HTML与XHTML二者有什么区别 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 17.请列举几种隐藏元素的方法 visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。 opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 display: none；元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。 HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态 height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。 filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。 18.CSS的选择器 元素选择器：* 、E、 E#id、 E.class 关系选择器：E、F、E&gt;F、E+F、E~F 属性选择器：E[att]、E[att=”val”]、E[att~=”val”]、E[att^=”val”]、E[att$=”val”]、E[att*=”val”]、E[att|=”val”] 伪类选择器：E:link、E:visited、E:hover、E:active、E:focus、E:lang(fr)、E:not(s)、E:root、E:first-child、E:last-chil等 伪对象选择器：E:first-letter/E::first-letter、E:first-line/E::first-line、E:before/E::before、E:after/E::after、E::selection 19.CSS的权重规则 一个行内样式：+1000； 一个ID：+100； 属性选择器/class类/伪类选择器：+10； 一个元素名/伪对象选择器：+1。 20.CSS伪类与CSS伪对象的区别 CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西，根本区别在于：它们是否创造了新的元素（抽象） 伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类。 伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 21.position的几个取值 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）。 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。 static：默认值。没有定位，元素出现在正常的流中。 22.position的absolute与fixed的异同点 相同： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上 区别： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 23.外边距重叠 外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 24.什么是JavaScript闭包 当函数可以记住并访问所在的作用域时，就产生了闭包，即使函数是在当前作用域之外执行。闭包有如下特性： JavaScript允许你使用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量 闭包可以更新外部变量的值 用闭包模拟私有方法 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 25.JS如何实现面向对象和继承机制 创建对象方法： 利用json创建对象 使用JavaScript中的Object类型 通过创建函数来生成对象 继承机制： 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上 prototype模式，继承new函数的模式 直接继承函数的prototype属性，对b的一种改进 利用空对象作为中介 在ECMAScript5中定义了一个新方法Object.create()，用于创建一个新方法 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《JavaScript中的对象克隆》 26.对this指针的理解 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this指的是：调用函数的那个对象。 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 作为对象方法的调用，这时this就指这个上级对象。 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 27.JS常用的绑定事件的方法有哪些 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，查看事件列表。 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。 绑定事件监听函数，标准浏览器使用 addEventListener() ，IE11以下版本attachEvent() 来绑定事件监听函数，通称为DOM2事件系统。 28.解释下javascript的冒泡和捕获12345&lt;div id="click1"&gt; &lt;div id="click2"&gt; &lt;div id="click3"&gt;事件&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型。 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型。 W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段。 事件监听函数addEventListener()的第三个参数就是控制方法是捕获还是冒泡 29.jQuery的特点 一款轻量级的js库 丰富快速的DOM选择器 链式表达式 事件、样式、动画等特效支持 Ajax操作封装，支持跨域 跨浏览器兼容 插件扩展开发 30.js延迟加载的方式有哪些 将script节点放置在最后&lt;/body&gt;之前 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 通过监听onload事件，动态添加script节点 通过ajax下载js脚本，动态添加script节点 31.如何解决跨域问题 JSONP（JSON with Padding），填充式JSON iframe跨域 HTML5的window.postMessage方法跨域 通过设置img的src属性，进行跨域请求 跨域资源共享（CORS），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 32.哪些操作会造成内存泄漏 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。 闭包可以维持函数内局部变量，使其得不到释放。 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。 33.JavaScript中的变量声明提升 函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。 function优先声明于var。 函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。 123456789101112131415function foo() &#123; bar(); var x = 1;&#125;function foo() &#123;//等同于 var x; bar(); x = 1;&#125;function test() &#123; foo(); // TypeError "foo is not a function" bar(); // "this will run!" var foo = function () &#123; &#125;// 函数表达式被赋值给变量'foo' function bar() &#123; &#125;// 名为'bar'的函数声明&#125; 34.JavaScript原型和原型链 原型： 原型是一个对象，其他对象可以通过它实现属性继承。 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器proto。 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。 原型链： 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系称为原型链。 这条链的末端一般总是默认的对象原型。 35.JavaScript中的作用域和作用域链 变量的作用域（scope）：程序源代码中定义这个变量的区域。 作用域链：是一个对象列表或链表，这组对象定义了这段代码“作用域中”的变量。查找变量会从第一个对象开始查找，有则用，无则查找链上的下一个对象。 36.jQuery源码以及jQuery的实现原理 jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件), 一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想 37.输入完网址按下回车到看到网页这个过程中发生了什么 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 38.关于前端性能优化 请求优化：合并JS和CSS，减少DNS查找次数，避免重定向，使用GET完成AJAX请求，减小请求中的Cookie，缓存资源，使用CDN，开启GZip，压缩HTML页面，开启长连接，避免行内脚本阻塞并行下载，少用iframe（阻塞onload事件，影响并行下载）。 CSS优化：样式表置于页面顶部，避免使用CSS表达式，使用外部JS和CSS，压缩JS和CSS，避免滤镜。 JavaScript优化：脚本置于页面底部，减少DOM访问，减少重绘和重排，尽量使用局部变量，使用定时器分割大型任务，用合适的正则操作字符串，惰性模式减少分支，事件委托，第三方代码异步加载，节流与去抖动，使用localStorage替代cookie。 图片优化：内联图使用Data:URL，压缩图片或使用WebP格式，固定图片尺寸，图片预加载，图片延迟加载，使用字体矢量图标，Sprites图片。 39.减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 40.以前端角度出发做好SEO需要考虑什么 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 41.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 42.请求服务器时的状态码。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败 常见的有： 200 OK 访问正常表示成功访问,为网站可正常访问时的状态。 301 Moved Permanently 301重定向永久重定向对搜索引擎相对友好的跳转方式，当网站更换域名时可将原域名作301永久重定向到新域名，原域名权重可传递到新域名，也常有将不含www的域名301跳转到含www的，如xxx.com通过301跳转到www.xxx.com 302 Found 为临时重定向易被搜索引擎判为作弊,比如asp程序的response.Redirect()跳转、js跳转或静态http跳转。 Http/1.1 400 Bad Request 域名绑定错误一般是服务器上域名未绑定成功，未备案等情况。 403 Forbidden 没有权限访问此站你的IP被列入黑名单，连接的用户过多，可以过后再试，网站域名解析到了空间，但空间未绑定此域名等情况。 404 Not Found 文件或目录不存在表示请求文件、目录不存在或删除，设置404错误页时需确保返回值为404。常有因为404错误页设置不当导致不存在的网页返回的不是404而导致搜索引擎降权。 500 Internal Server Error 程序或服务器错误表示服务器内部程序错误，出现这样的提示一般是程序页面中出现错误，如小的语法错误，数据连接故障等。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html/css</tag>
        <tag>http</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则表达学习]]></title>
    <url>%2F2017%2F05%2F24%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是正则表达式正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，搜索模式可用于文本搜索和文本替换。 正则表达式的语法 /主体/修饰符(可选) 其中，第一个“/“是这个正则表达式的头部,主体是我们想要匹配的模式,第二个“/“是这个正则表达式的尾部，修饰符有三个： i（intensity）：大小写不敏感； g（global）：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行； m（multiple）：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用。 正则表达式的常用方法 test( ) : 在字符串中查找符合正则的内容，若查找到返回true,反之返回false。用法：正则.test(字符串) 123456789// 测试是否是数字：var str = '374829348791';var re = /\D/; // \D代表非数字if( re.test(str) )&#123; // 返回true,代表在字符串中找到了非数字。 console.log('不全是数字');&#125;else&#123; console.log('全是数字');&#125; search( ) ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回-1。用法：字符串.search(正则) 123456// 在字符串中找字母b，且不区分大小写：var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i'); 也可以这样写console.log( str.search(re) ); // 1 match( ) : 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。用法： 字符串.match(正则)量词：+ 至少出现一次 匹配不确定的次数（匹配就是搜索查找的意思）。 12345//找出指定格式的所有数字，如下找到 123，54，33，879var str = 'haj123sdk54hask33dkhalsd879';var re = /\d+/g; // 每次匹配至少一个数字 且全局匹配 如果不是全局匹配，当找到数字123，它就会停止了。就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，8，7，9并不是我们想要的，有了加号，每次匹配的数字就是至少一个了。console.log( str.match(re) ); // [123，54，33，879] match方法也会返回自己的子项，如下： 12345// 当match不加g的时候才可以获取到子项的集合:var str = 'abc';var re = /(a)(b)(c)/;console.log( str.match(re) ); //[abc,a,b,c](返回的是匹配结果,以及每个子项) replace() :查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。用法： 字符串.replace(正则,新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符） 12345678910111213141516171819202122//敏感词过滤，比如 我爱北京天安门，天安门上太阳升。------我爱*****，****上太阳升。即北京和天安门变成*号。~~//一开始我们可能会想到这样的方法：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,'*'); console.log(str2) //我爱**，*上太阳升 //这种只是把找到的变成了一个*，并不能几个字就对应几个*。~~//要想实现几个字对应几个*，我们可以用回调函数实现：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,function(str)&#123; console.log(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门 var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; //所以搜索到了几个字就返回几个* &#125;);console.log(str2) //我爱*****，***上太阳升 //整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。 正则表达式中的字符 ^ : 正则的最开始位置，就代表起始的意思。注意：/[ ^ a] / 和 / ^ [a]/ 是不一样的，前者是排除的意思，后者是代表首位。 eg:”^ The”–表示所有以”The”开始的字符串（”There”，”The cat”等）; 1234567// 判断是不是QQ号:// 首先想QQ号的规则：1.首位不能是0 ；2.必须是 5-12位的数字。 var str = '1445427773';var re = /^[1-9]\d&#123;4,11&#125;$/;console.log( re.match(str) ); $ : 正则的最后位置，就代表结束的意思。eg:”of despair$”–表示所以以”of despair”结尾的字符串; 12345678910// 去掉前后空格（面试题经常出现）:function trim(str)&#123; var re = /^\s+|\s+$/g; // |代表或者 \s代表空格 +至少一个 前面有至少一个空格 或者后面有至少一个空格 且全局匹配 return str.replace(re,''); //把空格替换成空&#125;var str = ' hello ';console.log('('+str+')');console.log( '('+trim(str)+')' ); //为了看出区别所以加的括号。 ( ) : 小括号，叫做分组符。就相当于数学里面的括号。如下： 12345678var str = '2013-6-7';var re1 = /\d-+/g; // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为： 3- 6-var re2 = /(\d-)+/g; // 全局匹配数字，横杠，数字和横杠整体数量至少为1 3-6-var re3 = /(\d+)(-)/g; // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-console.log(str.match(re1));console.log(str.match(re2));console.log(str.match(re3)); 同时，正则中的每一个带小括号的项，都叫做这个正则的子项。子项在某些时候非常的有用，比如下面这个例子： 123456789101112131415// 让2013-6-7 变成 2013.6.7：var str = '2013-6-7';var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; // replace()中如果有子项， // 第一个参数：$0（匹配成功后的整体结果 2013- 6-）, // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d 2013, 6) // 第三个参数 : $1(匹配成功的第二个分组，这里指的是- - - ) return $1 + '.'; // 分别返回2013. 6. &#125;);console.log( str ); // 整个过程就是利用子项把2013- 6- 分别替换成了2013. 6. 最终弹出2013.6.7 转义字符: \s : 空格 \S : 非空格 \d : 数字 \D : 非数字 \w : 字符 ( 字母 ，数字，下划线_ ) \W : 非字符 .（点）: 任意字符 . : 真正的点 \b : 独立的部分 （ 起始，结束，空格 ） \B : 非独立的部分 1234567var str1 = 'onetwo';var str2 ="one two";var re = /one\b/; // e后面必须是独立的 可以是起始，空格，或结束console.log( re.test(str1) ); // falseconsole.log( re.test(str2) ); // true 量词：代表出现的次数。 {n,m} : 至少出现n次，最多m次;“ab{3,5}”：表示一个字符串有一个a跟着3到5个b;“ab{2,}”：表示一个字符串有一个a跟着至少2个b; {n,} : 至少n次; * : 任意次,相当于{0,};“ab*”：表示一个字符串有一个a后面跟着零个或若干个b。（”a”, “ab”, “abbb”,……）； ？：零次或一次,相当于{0,1};“ab?”：表示一个字符串有一个a后面跟着零个或者一个b; + ：一次或任意次,相当于 {1,};“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多; {n} ：正好n次;“ab{2}”：表示一个字符串有一个a跟着2个b（”abb”). [ ]： 表示某个集合中的任意一个。方括号表示某些字符允许在一个字符串中的某一特定位置出现。“[ab]”：表示一个字符串有一个”a”或”b”（相当于”a¦b”);“[a-d]”：表示一个字符串包含小写的’a’到’d’中的一个（相当于”a¦b¦c¦d”或者”[abcd]”);“ ^ [a-zA-Z]”：表示一个以字母开头的字符串;“[0-9]%”：表示一个百分号前有一位的数字;“, [a-zA-Z0-9] \$ “ ：表示一个字符串以一个逗号后面跟着一个字母或数字结束。你也可以在方括号里用’ ^ ‘表示不希望出现的字符，’ ^ ‘应在方括号里的第一位。（如：”%[ ^ a-zA-Z]%”表示两个百分号中不应该出现字母)。为了逐字表达，你必须在” ^ .$ ( ) ¦ * + ? { \ “这些字符前加上转移字符’ \ ‘。请注意在方括号中，不需要转义字符。 12345// 匹配HTML标签 比如&lt;div class="b"&gt;hahahah &lt;/div&gt; 找出标签&lt;div class="b"&gt;&lt;/div&gt;var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号 中间至少一个非右括号的内容(因为标签里面还有属性等一些东西)，然后匹配右括号var re = /&lt;[\w\W]+&gt;/g; //匹配左括号 中间至少一个字符或者非字符的内容，然后匹配右括号// 其实就是找到左括号，然后中间可以有至少一个内容，一直到找到右括号就代表是一个标签。 \a ：表示重复的某个子项。比如： \1 : 重复的第一个子项; \2 : 重复的第二个子项; 12/ (a) (b) (c) \1/ // 匹配 abca/ (a) (b) (c) \2/ // 匹配 abcb 12345678910111213141516171819202122// 找重复项最多的字符个数(面试题中经常问到）:var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split(''); // 把字符串转换为数组str = arr.sort().join(''); // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串console.log(str); // aaddjjkklsssssssssssssssssvar value = '';var index = 0; var re = /(\w)\1+/g; // 匹配字符，且重复这个字符，重复次数至少一次。str.replace(re,function($0,$1)&#123; // alert($0); 代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss // alert($1); 代表每次匹配成功的第一个子项，也就是\w: a d j k l S if(index&lt;$0.length)&#123; // 如果index保存的值小于$0的长度就进行下面的操作 index = $0.length; // 这样index一直保存的就在最大的长度 value = $1; // value保存的是出现最多的这个字符 &#125;&#125;); console.log('最多的字符:'+value+',重复的次数:'+index); // s 17 split( ):字符串中的方法，把字符串转成数组。sort( ):数组中的排序方法，按照ACALL码进行排序。join( ):数组中的方法，把数组转换为字符串 常用的一些正则表达式 校验是否全由数字组成（[0-9]中的字符出现次数的范围是1到20次): /\^[0-9]{1,20}$ / 校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串: /\^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$ / 校验用户姓名：只能输入1-30个以字母开头的字串: /\^[a-zA-Z]{1,30}$/ 校验密码：只能输入6-20个字母、数字、下划线: /\^(\w){6,20}$/ 校验普通电话、传真号码：可以“+”或数字开头，可含有”-“ 和 “ “ /\^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/ 校验URL: /\^http[s]{0,1}:\/\/.+$/ 校验身份证： /[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x/ 校验Email(起始至少为一个字符(\w字母，数字或者下划线)，然后匹配@,接着为任意个字母或者数字，\.代表真正的点，.后面为至少一个的字符（a-z）,同时这个(比如.com)整体为一个子项作为结束，可以出现1-3次。因为有的邮箱是这样的.cn.net。)： /\^\w+@[a-z0-9]+(.[a-z]+){1,3}$ /]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个测试颜色辨识度的小游戏]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A2%9C%E8%89%B2%E8%BE%A8%E8%AF%86%E5%BA%A6%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[testColorResolution A small game that can test your eyes for color recognition 简介之前有段时间网上有一个挺流行的小游戏叫做“看你有多色”。然后我看了网上的教程用createJS仿写了一个，具体实现后效果如下： 游戏开始 点击与其它方块颜色不一样的方块 一定步数之后，方块数量达到9*9后不再增加 以下是部分关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243var stage = new createjs.Stage("gameView");createjs.Ticker.setFPS(30);createjs.Ticker.addEventListener("tick",stage);var gameView = new createjs.Container();stage.addChild(gameView);var n = 2;function addRect()&#123; var cl = parseInt(Math.random()*1000000); var color = "#" + cl; var cl1 = cl+90000; var RectColor = "#" + cl1; var x = parseInt(Math.random()*n); var y = parseInt(Math.random()*n); for(var indexX = 0;indexX &lt; n ;indexX++)&#123; for(var indexY = 0;indexY &lt; n;indexY++)&#123; var r = new Rect(n,color,RectColor); gameView.addChild(r); r.x = indexX; r.y = indexY; if(r.x == x &amp;&amp; r.y == y)&#123; r.setRectType(2); &#125; r.x = indexX*(400/n); r.y = indexY*(400/n); if(r.getRectType() == 2)&#123; r.addEventListener("click",function()&#123; var audio = document.getElementById("clickSound"); audio.play(); if(n&lt;9)&#123; ++n; &#125; gameView.removeAllChildren(); addRect(); &#125;) &#125; &#125; &#125;&#125;addRect(); 表示颜色的时候用的十六进制而不是RGB，然后随机颜色用的是random函数。而唯一一个不同于其他方块的方块颜色是要比其他颜色浅一些的。点击其他方块没有任何特效，点击唯一正确的方块会进入下一关并且伴随有音效提示，同时整个游戏会有BGM。 源码地址：https://github.com/1996szw/testColorRecognition]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP的三次握手和四次挥手]]></title>
    <url>%2F2017%2F04%2F02%2F%E5%85%B3%E4%BA%8ETCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[1.TCP报文格式 几个重点字段： （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 需要注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。 2.三次握手 TCP(Transmission Control Protocol)即传输控制协议，TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 位码即tcp标志位,有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码)Acknowledge number(确认号码)establish 建立，创建 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。SYN攻击： 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： netstat -nap | grep SYN_RECV 3.四次挥手所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。 4.问答1.为什么建立连接是三次握手，而关闭连接却是四次挥手呢？答：这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>http</tag>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的DOM对象学习]]></title>
    <url>%2F2017%2F03%2F12%2FJavascript%E4%B8%AD%E7%9A%84DOM%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DOM先来看看下面代码: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html"; charset="gb2312"&gt;&lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;…&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作（DOM常见的API）: 注意:前两个是document方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记第二弹]]></title>
    <url>%2F2017%2F03%2F08%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Info:JS学习的补充笔记 日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date(); //Date()是一个构造函数，.now是他的一个属性函数dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月（0 - 11）dt.getDate(); //日（0 - 31）dt.getHours(); //小时（0 - 23）dt.getMinutes(); //分钟（0 - 59）dt.getSeconds(); //秒（0 - 59） MathMath.random()获取随机数 数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否至少有一个元素符合条件 sort 排序 map 对元素重新组装，生成一个新数组 filter 过滤符合条件的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.forEachvar arr = [1,2,3];arr.forEach( function(item, index) &#123; console.log(index,item);// 0 1 1 2 2 3&#125;);// 2.everyvar arr = [1,2,3];var result = arr.every(function(item,index)&#123; if(item &lt; 4)&#123; return true; &#125;&#125;)console.log(result); // true// 3.somevar arr = [1,2,3];var result = arr.some(function(item,index)&#123; if(item &lt; 2)&#123; return true; &#125;&#125;)console.log(result); //true// 4.sortvar arr = [1,4,3,5,2];var arr2 = arr.sort(function(a,b)&#123; return a - b; //从小到大排序&#125;)console.log(arr2); //[1,2,3,4,5]// 5.mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index)&#123; return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;)console.log(arr2); //[ '&lt;b&gt;1&lt;/b&gt;', '&lt;b&gt;2&lt;/b&gt;', '&lt;b&gt;3&lt;/b&gt;', '&lt;b&gt;4&lt;/b&gt;' ]// 6.filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index)&#123; //通过某个条件过滤数组 if(item &gt;= 2)&#123; return true; &#125;&#125;)console.log(arr2); //[2,3] 对象API1234567891011var obj = &#123; x: 100, y: 200, z: 300&#125;var key;for (key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key,obj[key]); &#125;&#125; // x 100 y 200 z 300 事件通用事件绑定12345678910111213var btn = document.getElementById('btn1');btn.addEventListener('click', function(event)&#123; console.log('clicked');&#125;)function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn);&#125;var a = document.getElementById('link1');bindEvent(a,'click', function(e)&#123; e.preventDefault(); //阻止默认行为 alert('clicked');&#125;) 冒泡123456789101112131415161718192021222324&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var p1 = document.getElementById('p1'); var body = document.body; bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); alert('激活'); &#125;) bindEvent(body,'click',function(e)&#123; alert('取消'); &#125;) &lt;/script&gt;&lt;/body&gt; 代理]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记]]></title>
    <url>%2F2017%2F03%2F06%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Info:之前JS学习的一些笔记，包括JS的三个重点：原型和原型链、作用域与闭包、异步和单线程 一.变量类型和计算：引用类型（3种）对象、数组、函数。 引用类型的内存只存一份，而值类型是存多份 typeof（6种）undefined、number、string、boolean、object、function。 强制类型转换 字符串拼接； ==运算符； if条件语句； 逻辑运算（与或非)。 何时使用==if(obj.a == null){ … } //这里是简写，相当于obj.a === null || obj.a === undefined。其他时候全部用三等“===”。 if(…){ }条件为假的几种情况 0； NaN； “”; null; undefined; false。 JS中的内置函数（数据封装内对象） Object； Array； Boolean； Number； String； Function； Date； RegExp； Error。 如何理解JSON JSON.stringify({a:10,b:20}); JSON.parse(‘{“a”:10,”b”:20}’)。 （JSON只不过是一个JS对象）上面就是JSON常见的两个API。 二.原型与原型链：构造函数12345678910111213function Foo(name,age)&#123; //构造函数首字母大写 this.name = name; this.age = age; this.class = 'class-1'; //return this; //返回这个对象&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);console.log(f); //Foo &#123; name: 'zhangsan', age: 20, class: 'class-1' &#125;console.log(f instanceof Object); //true 构造函数—拓展 var a = { } 其实是var a = new Object()的语法糖； var a = [ ] 其实是var a = new Array()的语法糖； function Foo(){…} 其实是var Foo = new Function()的语法糖； 使用instanceof判断一个函数是否是一个变量的构造函数。 原型规则和示例 所有的引用类型（对象、数组、函数）都具有对象特性，即可自由拓展属性（除 了”null”之外）； 所有的引用类型（对象、数组、函数）都有一个proto（隐式原型）属性，属性值是一个普通的对象； 所有的函数都有一个prototype（显式原型）属性，属性值是一个普通的对象； 所有的引用类型（对象、数组、函数），proto属性值指向它的构造函数的prototype属性值； 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的proto(即它的构造函数的prototype)中寻找。 123456789101112131415//第一条规则：var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn()&#123;&#125;; fn.a = 100;//第二条规则：console.log(obj.__proto__); //&#123;&#125;console.log(arr.__proto__); //[]console.log(fn.__proto__); //[Function]//第三条规则：console.log(fn.prototype); //fn &#123;&#125;//第四条规则：console.log(obj.__proto__ === Object.prototype); //true 12345678910111213141516171819202122// 第五条规则：// 构造函数function Foo (name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function()&#123; alert(this.name);&#125;// 创建示例var f = new Foo('zhangsan');f.printName = function () &#123; console.log(this.name);&#125;// 测试f.printName(); //zhangsanf.alertName(); //zhangsanf.toString(); //要去 f.__proto__.__proto__中去寻找//console.log(f.__proto__.__proto__.__proto__); //null 补充： 12345678var item;for(item in f)&#123; // 虽然高级浏览器已经在 for in 中屏蔽了来自原型的属性 // 但是还是建议加上这个判断，保证程序的健壮性 if(f.hasOwnProperty(item))&#123; console.log(item); &#125;&#125; 原型链 instanceof用于判断引用类型属于那个构造函数的方法。 关于原型和原型链的几个问题1.如何准确判断一个变量是数组类型： 123var arr = [];arr instanceof Array; //truetypeof arr; //Object(typeof是无法准确判断是否是数组的 2.写一个原型链继承的例子： 1234567891011121314151617181920//普通版：// 动物function Animal () &#123; this.eat = function () &#123; console.log('animal eat'); &#125;&#125;// 狗function Dog () &#123; this.bark = function () &#123; console.log('dog bark'); &#125;&#125;Dog.prototype = new Animal();// 哈士奇var hashiqi = new Dog(); 12345678910111213141516171819202122232425262728293031323334//高级版（写一个封装DOM查询的例子）：function Elem (id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val)&#123; var elem = this.elem; if(val)&#123; elem.innerHTML = val; return this; //链式操作 &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function (type,fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem('div1');// console.log(div.html())div1.html('&lt;p&gt;hello world&lt;/p&gt;');div1.on('click',function () &#123; alert('clicked!');&#125;)//因为有第十行的“return this”（返回的是this这个对象），所以可以进行链式操作：// div1.html('&lt;p&gt;hello world&lt;/p&gt;').on('click',function()&#123;// alert('clicked!');// &#125;); 3.描述new一个变量的过程： 即考察对构造函数的理解。 创建一个新对象； this指向这个对象； 执行代码，即对this赋值； 返回this。 4.zepto（或其他框架）源码中如何使用原型链： zepto设计和源码分析 三.作用域与闭包：执行上下文 范围：一段&lt;script&gt;或者一段函数 全局：变量定义、函数声明 （一段&lt;script&gt;） 函数：变量定义、函数声明、this、arguments （函数） 123456789console.log(a); //undefinedvar a = 100;fn('zhangsan');function fn (name) &#123; age = 20; console.log(name,age); //zhangsan 20 var age;&#125; this this要在执行时才能确认值，定义时无法确认。 作为构造函数执行； 作为对象属性执行； 作为普通函数执行； call()、apply()、bind()； 1234567891011121314151617181920212223//1.作为构造函数执行function Foo (name) &#123; this.name = name;&#125;var f = new Foo('zhangsan');var a = &#123; name: 'A', fn: function () &#123; console.log(this.name); &#125;&#125;//2.作为对象属性执行a.fn(); //A (this === a)//3.作为普通函数执行var fn1 = a.fn;fn1(); ///undefined (this === window)//4.call（改变this的值）a.fn.call(&#123;name: 'B'&#125;); //B (this === &#123;name: 'B'&#125;) 作用域 JS没有块级作用域； 只有函数和全局作用域； 1234567891011121314// 无块级作用域if(true)&#123; var name = 'zhangsan';&#125; //大括号相当于一个块console.log(name); //zhangsan// 函数和全局作用域var a = 100;function fn () &#123; var a = 200; console.log('fn',a);&#125;fn(); //fn 200console.log('global',a); //global 100 作用域链1234567891011121314var a = 100;function fn1 () &#123; var b =200; function fn2 () &#123; var c = 300; //当前作用域没有定义的变量，即“自由变量” console.log(a); //a是自由变量，则要到当前fn2作用域的父级作用域去找，没有找到，则继续到fn1的父级作用域去找 console.log(b); //b是自由变量，则要到当前fn2作用域的父级作用域去找，即fn1的作用域，找到了 console.log(c); &#125; fn2();&#125;fn1(); //100 200 300 闭包闭包的使用场景 函数作为返回值； 函数作为参数传递； 123456789101112// 1.函数作为返回值： function fn1 () &#123; var a = 100; return function () &#123; //返回一个函数（函数作为返回值） console.log(a); &#125;&#125;// fn1得到一个函数var f1 = fn1();var a = 200;f1(); //100 123456789101112131415// 2.函数作为参数传递function fn1 () &#123; var a = 100; return function () &#123; console.log(a); &#125;&#125;var f1 = fn1();function fn2 (fn) &#123; //函数作为参数传递 var a = 200; fn()&#125;fn2(f1); 闭包的示例12345678910111213141516171819202122// 1.查询是否是第一次载入：// 闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad () &#123; var _list = []; return function (id) &#123; if(_list.indexOf(id) &gt;= 0)&#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;// 使用var firstLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true// 在isFirstLoad函数外面，根本不可能改掉_list的值 123456789101112131415// 2.创建10个a标签，点击弹出相应的序号：var i;for(i = 0;i &lt; 10;i++)&#123; (function (i)&#123; // 自执行函数，就是不用调用，只要定义完成，立刻执行的函数 // 函数作用域 var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function(e)&#123; e.preventDefault(); alert(i); //自由变量，要去父级作用域获取值 &#125;) document.body.appendChild(a); &#125;)(i)&#125; 四.异步和单线程：什么是异步（对比同步）1234567891011// 异步：console.log(100);setTimeout(function()&#123; console.log(200);&#125;,1000)console.log(300); //先打印100，然后打印300，过一秒钟再打印200// 对比同步：console.log(100);alert(200); //程序阻塞在这里，如果不点击确认就会卡在这里console.log(300); 何时需要异步 在可能发生等待的情况； 等待过程中不能像alert一样阻塞程序的执行； 因此，所有“等待的情况”都需要异步； //并非“阻塞的情况” 前端使用异步的场景 定时任务：setTimeout、setInterval ； 网络请求：ajax请求、动态加载； 事件绑定； 12345678910111213141516171819202122// ajax请求代码示例：console.log('start');$.get('./datta1.json',function(data1)&#123; console.log(data1);&#125;)console.log('end');// &lt;img&gt;加载示例：console.log('start');var img = document.createElement('img');img.onload = function()&#123; console.log('loaded');&#125;img.src = '/xxx.img';console.log('end');// 事件绑定示例：console.log('start');document.getElementById('btn1').addEventListener('click', function()&#123; alert('clicked');&#125;)console.log('end'); 异步和单线程1234567891011// 单线程：一次只能干一件事，一个一个排队来console.log(100);setTimeout(function()&#123; console.log(200);&#125;)console.log(300);// 1. 执行第一行，打印100；// 2. 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）；// 3. 执行最后一行，打印300；// 4. 待所有的程序执行完，处于空闲状态时，会立马看有没有暂存起来的需要执行；// 5. 发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行； 关于异步和单线程的几个问题 同步和异步的区别是什么。分别举一个同步和异步的例子： 同步会阻塞代码执行，而异步不会； alert是同步，setTimeout是异步。 一个关于setTimeout的笔试题： 12345678910console.log(1);setTimeout(function()&#123; console.log(2)&#125;,0);console.log(3);setTimeout(function()&#123; console.log(4);&#125;,1000);console.log(5);// result: 1 3 5 2 4]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>study</tag>
        <tag>JS变量类型</tag>
        <tag>原型与原型链</tag>
        <tag>作用域与闭包</tag>
        <tag>异步和单线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F03%2F04%2FGithub-Pages-Hexo%E5%8D%9A%E5%AE%A2-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这两天也算是摸爬滚打终于搭建成功了这个Hexo博客，然后也是想把过程记录一下，把整个步骤分享给大家（虽然可能也不会有人看到。。 Hexo本地环境搭建Git环境 首先我们需要一个git环境，MacOS的XCode是自带git的所以也无需重复安装。 如果是Windows用户的话，可以去Git官网根据自己的电脑操作系统位数下载相应的版本，下载完成后点击安装，一路next即可。 Windows用户还需要配置环境变量，具体操作可参考度娘上面的教程：Git的安装与配置 测试是否安装配置成功：win+R打开运行，输入cmd打开命令提示窗口，输入如下命令： git –version 如果正确打印出安装的Git版本号，则说明安装成功。 Node.js环境 Mac用户可以通过Homebrew来安装(推荐)，具体步骤如下： 先安装Homebrew： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 然后更新brew确保其可用： brew update 再安装环境所需的Node.js： brew install node 验证是否安装成功： node -vnpm -v 如果正确打印出安装的Node版本号，则说明安装成功。 Windows用户，可以去Node官网根据自己的操作系统位数下载安装（过程跟上述安装Git的步骤类似，在此不再赘述。。 Hexo环境Hexo是一款基于Node.js的静态博客框架，所以之前的那些步骤都是为了安装hexo所做的准备，具体安装hexo的步骤如下： 选择一个你喜欢的目录，用来存放你的hexo博客的所有文件，在此目录下运行你的Git Bash（Windows直接右键你所选择的目录会有个Git Bash选项，点击即可。Mac用户则是打开你的Terminal工具，cd到你所选择的目录再进行一系列的操作） 正式安装Hexo，输入如下指令： npm install -g hexo-cli 当然由于我国的社会主义核心建设，上述命令可能被墙，从而导致安装失败。此时将命令中的npm镜像源改成国内万能的某宝提供的镜像源即可： sudo npm install -g hexo-cli –registry=https://registry.npm.taobao.org 初始化hexo： hexo init hexo 正确初始化后会得到这样的反馈：INFO Start blogging with Hexo! 安装依赖文件： npm install 部署形成文件： hexo generate(或者 hexo g) 本地测试： hexo server(或者 hexo s) 正确完成到了这一步后，在浏览器输入 http://localhost:4000 后就能看到搭建好的hexo站点了。 接下来的步骤则是将本地的hexo放到github上托管，再重定向到你的个人域名以方便访问。 Github Pages注册Github如果不是程序员的话，可能会没有Github账号，这时就需要去Github官网去注册一个账号。注册成功后记得去你填的那个邮箱查收验证确认邮件。 新建一个仓库（new repository）注册登录成功后，去你的github主页点击”New repository”，取名为 “your_user_name.github.io”。 启用Github Pages 进入版本库后，点击右上方的setting，往下翻到Github Pages，点击Launch automatic page generator。 再然后来到New user site页面后点击右下角的Continue to layouts。 最后点击”Publish page”,发布github默认生成的一个静态站点。此时我们就可以通过在浏览器输入“your_user_name.github.io”来访问你的github站点主页。 将Hexo本地项目托管到GitHub Pages建立关联进入到你的本地hexo博客目录，有个_config.yml文件（全局配置文件），打开它，翻到最后面，将deploy改成如下所示： type: gitrepository: https://github.com/your_user_name/your_user_name.github.io.gitbranch: master 安装hexo-deployer-git插件在你的博客目录下输入如下命令： npm install hexo-deployer-git –save 将本地博客部署到GitHub Pages上依次执行下面三条命令： hexo cleanhexo generator 或 hexo ghexo deploy 或 hexo d 如果得到如下输出： INFO Deploy done: git 则说明部署成功。此时你可以通过在浏览器输入“your_user_name.github.io”来访问到你的hexo博客了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F03%2FHello%20World%2F</url>
    <content type="text"><![CDATA[写在开始 阮一峰老师说，喜欢写blog的人，会经历三个阶段。 （1）第一阶段，刚接触blog，觉得很新鲜，试着注册一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我就是这个样子。本来用的博客园，但总感觉不属于自己，再加上个人对博客园的界面颇有微词，一个偶然间看到了别人的hexo个人网站，觉得简洁的风格很好看也挺geek，于是瞬间倒戈。。 再然后Hexo是一个基于Node.JS的静态博客程序，生成的静态网页可以直接放到GitHub Pages上面（ps。顺便还能绿化一下GitHub的Contributions岂不是挺美滋滋？？ 然后我又想到自己之前买过腾讯家的服务器还送了域名，就准备将博客绑定下自己的域名，这样感觉就像是拥有了自己的小窝（虽然一系列的过程也是挺折腾的。。orz 到现在折腾了好几个小时，对着别人的“5分钟 就能搭建好免费个人博客”教程，中间还出现很意外的错误，终于是搞定下来了。。 当通过访问自己的域名看到博客加载下来之后，还是有些喜悦和成就感的。毕竟这也不是QQ空间、不是新浪微博、不是豆瓣小站。它更像是身为码农的我辛辛苦苦分到一块地，加以耕耘后不再需要在地主的土地上创造流量价值，感觉还是非常不错的。。 写在最后虽然感觉这个博客上也不会有什么人一起交流，但认为博客的价值还是在于记录，等你回头看你的博客时，能够让你你看到时光在你身上翻飞的样子。 总之，Hello World ～ 😘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>note</tag>
      </tags>
  </entry>
</search>
