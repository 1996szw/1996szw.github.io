<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记几道Codewars上面的编程题]]></title>
    <url>%2F2017%2F07%2F24%2F%E8%AE%B0%E5%87%A0%E9%81%93Codewars%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每次做完看到别人的答案：wtf ??? NO.1题目描述： 解法:12345678function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); Math.min()方法: 可以得到数组中最小的数,Math.min.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 splice()方法: arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 NO.2题目描述： 我的解法：123456function isTriangle(a,b,c)&#123; var p = (a + b + c)/2; var S = Math.sqrt(p*(p-a)*(p-b)*(p-c)); return S &gt; 0;&#125; 得票最高的解法： orz。。 NO.3题目描述： 我的解法：123456789101112function sumArray(array) &#123; if(!array || array == null)&#123;return 0&#125;; var max = Math.max.apply(null,array); var min = Math.min.apply(null,array); array.splice(array.indexOf(max),1); array.splice(array.indexOf(min),1); console.log(array); for(var sum = 0,i = 0;i &lt; array.length;i++)&#123; sum += array[i]; &#125; return sum;&#125; 得票最高的解法：1sumArray = a =&gt; a ? a.sort((x, y) =&gt; x - y).slice(1, -1).reduce((s, e) =&gt; s + e, 0) : 0 ??? (黑人问号脸。。 NO.4题目描述： 我的解法：1234567var gimme = function(inputArray) &#123; let min = inputArray.indexOf(Math.min(...inputArray)), max = inputArray.indexOf(Math.max(...inputArray)); if (min === 0 &amp;&amp; max === 2 || max === 0 &amp;&amp; min === 2) return 1; if (min === 1 &amp;&amp; max === 2 || max === 1 &amp;&amp; min === 2) return 0; if (min === 0 &amp;&amp; max === 1 || max === 0 &amp;&amp; min === 1) return 2;&#125;; 得票最高的解法： 溜了溜了。。 PS。虽然这些高票答案精简得不行，但至少我写的代码块可读性强啊。。（微笑]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【二】]]></title>
    <url>%2F2017%2F07%2F20%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO : 前端面试。 基础部分 1.prototype和proto的关系是什么2.meta viewport原理3.域名收敛是什么4.float和display：inline-block；的区别5.前端优化策略列举6.首屏、白屏时间如何计算7.闭包8.作用域链9.ajax如何实现、readyState五种状态的含义10.jsonp如何实现11.怎么处理跨域12.restful的method解释13.get和post的区别14.事件模型解释15.编写一个元素拖拽的插件16.编写一个contextmenu的插件17.编写web端cookie的设置和获取方法18.兼容ie６的水平垂直居中19.兼容ie的事件封装20.h5和原生android的优缺点21.编写h5需要注意什么22.xss和crsf的原理以及怎么预防23.css优先级24.如何实现点击radio的文字描述控制radio的状态（通过label实现）25.delegate如何实现 框架原理angularjs 1.angular的directive怎么写2.angular的脏检查（双向绑定）是如何实现的3.依赖注入如何实现4.scope如何实现5.$parse模块如何实现（主要自己写了一个类似的库） react 1.react在setState后发生了什么（直接说了setState源码）2.flux解释3.对react有什么了解（直接说了react中虚拟dom内部表示，mount过程源码和同步过程源码） jsBridge 如何说服对方使用jsBridge requirejs 1.amd和cmd区别，怎么了解到这些区别的，是否是去看了规范2.requirejs那些经常用的方法，然后对其进行解释 weex weex实现大致原理（只写过demo，面试管很好没有难为我，只问了这一个问题） http协议 1.accept是什么，怎么用2.http协议状态码，302和303的区别3.前端缓存如何实现、etag如何实现、etag和cache-control的max-age的优先级哪个比较高以及为什么、cache-control和expire优先级哪个比较高以及为什么 node 1.Buffer模块是干什么的2.Stream是什么，使用的两种模式3.http模块如何将异步处理方式实现成同步处理方式，具体解析请参考http模块如何将异步处理转成同步处理http://blog.csdn.net/wanglei20116527/article/details/62892070 其他问题 1.utf8和gbk的区别2.知道页面上某个点的坐标，如何获取该坐标上的所有元素3.angular、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）4.7点15分小于180度的夹角是多少5.大数相加6.给５升和６升的水杯如何倒出３升的水7.一班喜欢足球的人60%，喜欢排球的70%，喜欢篮球的80%，求喜欢足球和排球的占多少8.前端异常监测如何实现9.直播点赞按钮的冒泡功能如何实现10.js的uglify如何实现11.项目架构、如何带人（自己带过一个小团队）12.前端工程化方面做了哪些东西 面试中的收获 最开始面试时只阅读过angular源码，一面完后面试官对我说react用的不熟悉没关系，弄懂原理也可以，之后三天疯狂阅读react源码，对于react中虚拟dom内在表示、mount过程、setState的同步过程有了清晰的认识。面试官建议去阅读node的http模块和Stream模块源码，其中node-v0.1.100的http模块源码已经阅读完，并且写了一个基于net模块的http模块。node-v6.9.1的Stream模块源码现在还在阅读中。初步了解了前端异常监测，并且了解了百姓网、腾讯和阿里在前端异常监测的一些方案和框架。阅读了大量前端工程化方面的博文，对前端工程化有了进一步的理解。了解了angular和react产生背景。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html／css</tag>
        <tag>http</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【一】]]></title>
    <url>%2F2017%2F07%2F18%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO ：这段时间遇到的面试题。 1.前端页面由哪三层构成及各层的作用 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本语言负责。解决了页面上“内容应该如何对事件作出反应”的问题。 2.简述盒模型 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。CSS3中有个box-sizing属性可以控制盒子的计算方式。 W3C盒子模型：content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。 IE6盒子模型：border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。 3.什么是CSS Hack针对不同的浏览器写不同的CSS,就是 CSS Hack。IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：123456789101112131415 // 1、条件Hack&lt;!--[if IE]&gt; &lt;style&gt; .test&#123;color:red;&#125; &lt;/style&gt;&lt;![endif]--&gt;// 2、属性Hack .test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */ &#125;// 3、选择符Hack * html .test&#123;color:#090;&#125; /* For IE6 and earlier */ * + html .test&#123;color:#ff0;&#125; /* For IE7 */ 4.简述同步和异步 同步是阻塞模式：同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步是非阻塞模式：异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 5.浏览器的内核分别是什么 IE: trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 6.什么叫优雅降级和渐进增强及其区别 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 7.px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 8.浏览器本地存储 sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 9.web storage和cookie的区别 Cookie的大小是受限的； 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽； cookie还需要指定作用域，不可以跨域调用； Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie； Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生； IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage； 10.请列举几种可以清除浮动的方法 浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部由于不存在其他普通流元素了，表现出高度为0（高度塌陷）。 添加额外标签，例如&lt;div style=”clear:both”&gt;&lt;/div&gt; 使用br标签和其自身的html属性，例如&lt;br clear=”all” /&gt; 父元素设置 overflow：hidden；在IE6中还需要触发hasLayout，例如zoom:1； 父元素设置 overflow：auto 属性；同样IE6需要触发hasLayout； 父元素也设置浮动； 父元素设置display:table； 使用:after 伪元素；由于IE6-7不支持:after，使用 zoom:1触发hasLayout。 在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称BFC。 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。 IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。 11.对BFC规范的理解 BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动，防止与浮动元素重叠。 12.WEB应用从服务器主动推送Data到客户端有那些方式 Html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe &lt;script&gt;标签的长时间连接(可跨域) 13.网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 14.一次完整的HTTP事务是怎样的一个过程 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 15.对标签语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 16.HTML与XHTML二者有什么区别 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 17.请列举几种隐藏元素的方法 visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。 opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 display: none；元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。 HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态 height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。 filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。 18.CSS的选择器 元素选择器：* 、E、 E#id、 E.class 关系选择器：E、F、E&gt;F、E+F、E~F 属性选择器：E[att]、E[att=”val”]、E[att~=”val”]、E[att^=”val”]、E[att$=”val”]、E[att*=”val”]、E[att|=”val”] 伪类选择器：E:link、E:visited、E:hover、E:active、E:focus、E:lang(fr)、E:not(s)、E:root、E:first-child、E:last-chil等 伪对象选择器：E:first-letter/E::first-letter、E:first-line/E::first-line、E:before/E::before、E:after/E::after、E::selection 19.CSS的权重规则 一个行内样式：+1000； 一个ID：+100； 属性选择器/class类/伪类选择器：+10； 一个元素名/伪对象选择器：+1。 20.CSS伪类与CSS伪对象的区别 CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西，根本区别在于：它们是否创造了新的元素（抽象） 伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类。 伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 21.position的几个取值 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）。 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。 static：默认值。没有定位，元素出现在正常的流中。 22.position的absolute与fixed的异同点 相同： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上 区别： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 23.外边距重叠 外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 24.什么是JavaScript闭包 当函数可以记住并访问所在的作用域时，就产生了闭包，即使函数是在当前作用域之外执行。闭包有如下特性： JavaScript允许你使用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量 闭包可以更新外部变量的值 用闭包模拟私有方法 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 25.JS如何实现面向对象和继承机制 创建对象方法： 利用json创建对象 使用JavaScript中的Object类型 通过创建函数来生成对象 继承机制： 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上 prototype模式，继承new函数的模式 直接继承函数的prototype属性，对b的一种改进 利用空对象作为中介 在ECMAScript5中定义了一个新方法Object.create()，用于创建一个新方法 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《JavaScript中的对象克隆》 26.对this指针的理解 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this指的是：调用函数的那个对象。 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 作为对象方法的调用，这时this就指这个上级对象。 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 27.JS常用的绑定事件的方法有哪些 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，查看事件列表。 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。 绑定事件监听函数，标准浏览器使用 addEventListener() ，IE11以下版本attachEvent() 来绑定事件监听函数，通称为DOM2事件系统。 28.解释下javascript的冒泡和捕获12345&lt;div id="click1"&gt; &lt;div id="click2"&gt; &lt;div id="click3"&gt;事件&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型。 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型。 W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段。 事件监听函数addEventListener()的第三个参数就是控制方法是捕获还是冒泡 29.jQuery的特点 一款轻量级的js库 丰富快速的DOM选择器 链式表达式 事件、样式、动画等特效支持 Ajax操作封装，支持跨域 跨浏览器兼容 插件扩展开发 30.js延迟加载的方式有哪些 将script节点放置在最后&lt;/body&gt;之前 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 通过监听onload事件，动态添加script节点 通过ajax下载js脚本，动态添加script节点 31.如何解决跨域问题 JSONP（JSON with Padding），填充式JSON iframe跨域 HTML5的window.postMessage方法跨域 通过设置img的src属性，进行跨域请求 跨域资源共享（CORS），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 32.哪些操作会造成内存泄漏 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。 闭包可以维持函数内局部变量，使其得不到释放。 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。 33.JavaScript中的变量声明提升 函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。 function优先声明于var。 函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。 123456789101112131415function foo() &#123; bar(); var x = 1;&#125;function foo() &#123;//等同于 var x; bar(); x = 1;&#125;function test() &#123; foo(); // TypeError "foo is not a function" bar(); // "this will run!" var foo = function () &#123; &#125;// 函数表达式被赋值给变量'foo' function bar() &#123; &#125;// 名为'bar'的函数声明&#125; 34.JavaScript原型和原型链 原型： 原型是一个对象，其他对象可以通过它实现属性继承。 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器proto。 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。 原型链： 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系称为原型链。 这条链的末端一般总是默认的对象原型。 35.JavaScript中的作用域和作用域链 变量的作用域（scope）：程序源代码中定义这个变量的区域。 作用域链：是一个对象列表或链表，这组对象定义了这段代码“作用域中”的变量。查找变量会从第一个对象开始查找，有则用，无则查找链上的下一个对象。 36.jQuery源码以及jQuery的实现原理 jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件), 一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想 37.输入完网址按下回车到看到网页这个过程中发生了什么 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 38.关于前端性能优化 请求优化：合并JS和CSS，减少DNS查找次数，避免重定向，使用GET完成AJAX请求，减小请求中的Cookie，缓存资源，使用CDN，开启GZip，压缩HTML页面，开启长连接，避免行内脚本阻塞并行下载，少用iframe（阻塞onload事件，影响并行下载）。 CSS优化：样式表置于页面顶部，避免使用CSS表达式，使用外部JS和CSS，压缩JS和CSS，避免滤镜。 JavaScript优化：脚本置于页面底部，减少DOM访问，减少重绘和重排，尽量使用局部变量，使用定时器分割大型任务，用合适的正则操作字符串，惰性模式减少分支，事件委托，第三方代码异步加载，节流与去抖动，使用localStorage替代cookie。 图片优化：内联图使用Data:URL，压缩图片或使用WebP格式，固定图片尺寸，图片预加载，图片延迟加载，使用字体矢量图标，Sprites图片。 39.减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 40.以前端角度出发做好SEO需要考虑什么 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html／css</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个测试颜色辨识度的小游戏]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A2%9C%E8%89%B2%E8%BE%A8%E8%AF%86%E5%BA%A6%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[testColorResolution A small game that can test your eyes for color recognition 简介之前有段时间网上有一个挺流行的小游戏叫做“看你有多色”。然后我看了网上的教程用createJS仿写了一个，具体实现后效果如下： 游戏开始 点击与其它方块颜色不一样的方块 一定步数之后，方块数量达到9*9后不再增加 以下是部分关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243var stage = new createjs.Stage("gameView");createjs.Ticker.setFPS(30);createjs.Ticker.addEventListener("tick",stage);var gameView = new createjs.Container();stage.addChild(gameView);var n = 2;function addRect()&#123; var cl = parseInt(Math.random()*1000000); var color = "#" + cl; var cl1 = cl+90000; var RectColor = "#" + cl1; var x = parseInt(Math.random()*n); var y = parseInt(Math.random()*n); for(var indexX = 0;indexX &lt; n ;indexX++)&#123; for(var indexY = 0;indexY &lt; n;indexY++)&#123; var r = new Rect(n,color,RectColor); gameView.addChild(r); r.x = indexX; r.y = indexY; if(r.x == x &amp;&amp; r.y == y)&#123; r.setRectType(2); &#125; r.x = indexX*(400/n); r.y = indexY*(400/n); if(r.getRectType() == 2)&#123; r.addEventListener("click",function()&#123; var audio = document.getElementById("clickSound"); audio.play(); if(n&lt;9)&#123; ++n; &#125; gameView.removeAllChildren(); addRect(); &#125;) &#125; &#125; &#125;&#125;addRect(); 表示颜色的时候用的十六进制而不是RGB，然后随机颜色用的是random函数。而唯一一个不同于其他方块的方块颜色是要比其他颜色浅一些的。点击其他方块没有任何特效，点击唯一正确的方块会进入下一关并且伴随有音效提示，同时整个游戏会有BGM。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的DOM对象学习]]></title>
    <url>%2F2017%2F03%2F12%2FJavascript%E4%B8%AD%E7%9A%84DOM%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DOM先来看看下面代码: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html"; charset="gb2312"&gt;&lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;…&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作: 注意:前两个是document方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F03%2F04%2FGithub-Pages-Hexo%E5%8D%9A%E5%AE%A2-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言这两天也算是摸爬滚打终于搭建成功了这个Hexo博客，然后也是想把过程记录一下，把整个步骤分享给大家（虽然可能也不会有人看到。。 Hexo本地环境搭建Git环境 首先我们需要一个git环境，MacOS的XCode是自带git的所以也无需重复安装。 如果是Windows用户的话，可以去Git官网根据自己的电脑操作系统位数下载相应的版本，下载完成后点击安装，一路next即可。 Windows用户还需要配置环境变量，具体操作可参考度娘上面的教程：Git的安装与配置 测试是否安装配置成功：win+R打开运行，输入cmd打开命令提示窗口，输入如下命令： git –version 如果正确打印出安装的Git版本号，则说明安装成功。 Node.js环境 Mac用户可以通过Homebrew来安装(推荐)，具体步骤如下： 先安装Homebrew： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 然后更新brew确保其可用： brew update 再安装环境所需的Node.js： brew install node 验证是否安装成功： node -vnpm -v 如果正确打印出安装的Node版本号，则说明安装成功。 Windows用户，可以去Node官网根据自己的操作系统位数下载安装（过程跟上述安装Git的步骤类似，在此不再赘述。。 Hexo环境Hexo是一款基于Node.js的静态博客框架，所以之前的那些步骤都是为了安装hexo所做的准备，具体安装hexo的步骤如下： 选择一个你喜欢的目录，用来存放你的hexo博客的所有文件，在此目录下运行你的Git Bash（Windows直接右键你所选择的目录会有个Git Bash选项，点击即可。Mac用户则是打开你的Terminal工具，cd到你所选择的目录再进行一系列的操作） 正式安装Hexo，输入如下指令： npm install -g hexo-cli 当然由于我国的社会主义核心建设，上述命令可能被墙，从而导致安装失败。此时将命令中的npm镜像源改成国内万能的某宝提供的镜像源即可： sudo npm install -g hexo-cli –registry=https://registry.npm.taobao.org 初始化hexo： hexo init hexo 正确初始化后会得到这样的反馈：INFO Start blogging with Hexo! 安装依赖文件： npm install 部署形成文件： hexo generate(或者 hexo g) 本地测试： hexo server(或者 hexo s) 正确完成到了这一步后，在浏览器输入 http://localhost:4000 后就能看到搭建好的hexo站点了。 接下来的步骤则是将本地的hexo放到github上托管，再重定向到你的个人域名以方便访问。 Github Pages注册Github如果不是程序员的话，可能会没有Github账号，这时就需要去Github官网去注册一个账号。注册成功后记得去你填的那个邮箱查收验证确认邮件。 新建一个仓库（new repository）注册登录成功后，去你的github主页点击”New repository”，取名为 “your_user_name.github.io”。 启用Github Pages 进入版本库后，点击右上方的setting，往下翻到Github Pages，点击Launch automatic page generator。 再然后来到New user site页面后点击右下角的Continue to layouts。 最后点击”Publish page”,发布github默认生成的一个静态站点。此时我们就可以通过在浏览器输入“your_user_name.github.io”来访问你的github站点主页。 将Hexo本地项目托管到GitHub Pages建立关联进入到你的本地hexo博客目录，有个_config.yml文件（全局配置文件），打开它，翻到最后面，将deploy改成如下所示： type: gitrepository: https://github.com/your_user_name/your_user_name.github.io.gitbranch: master 安装hexo-deployer-git插件在你的博客目录下输入如下命令： npm install hexo-deployer-git –save 将本地博客部署到GitHub Pages上依次执行下面三条命令： hexo cleanhexo generator 或 hexo ghexo deploy 或 hexo d 如果得到如下输出： INFO Deploy done: git 则说明部署成功。此时你可以通过在浏览器输入“your_user_name.github.io”来访问到你的hexo博客了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F03%2FHello%20World%2F</url>
    <content type="text"><![CDATA[**Hello My Blog** 写在开始 阮一峰老师说，喜欢写blog的人，会经历三个阶段。 （1）第一阶段，刚接触blog，觉得很新鲜，试着注册一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我就是这个样子。本来用的博客园，但总感觉不属于自己，再加上个人对博客园的界面颇有微词，一个偶然间看到了别人的hexo个人网站，觉得简洁的风格很好看也挺geek，于是瞬间倒戈。。 再然后Hexo是一个基于Node.JS的静态博客程序，生成的静态网页可以直接放到GitHub Pages上面（ps。顺便还能绿化一下GitHub的Contributions岂不是挺美滋滋？？ 然后我又想到自己之前买过腾讯家的服务器还送了域名，就准备将博客绑定下自己的域名，这样感觉就像是拥有了自己的小窝（虽然一系列的过程也是挺折腾的。。orz 到现在折腾了好几个小时，对着别人的“5分钟 就能搭建好免费个人博客”教程，中间还出现很意外的错误，终于是搞定下来了。。 当通过访问自己的域名看到博客加载下来之后，还是有些喜悦和成就感的。毕竟这也不是QQ空间、不是新浪微博、不是豆瓣小站。它更像是身为码农的我辛辛苦苦分到一块地，加以耕耘后不再需要在地主的土地上创造流量价值，感觉还是非常不错的。。 写在最后虽然感觉这个博客上也不会有什么人一起交流，但认为博客的价值还是在于记录，等你回头看你的博客时，能够让你你看到时光在你身上翻飞的样子。 总之，Hello World ～ 😘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
